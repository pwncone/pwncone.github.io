<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Store Hooks in struct and Loop</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Store Hooks in struct and Loop</h1></strong><br />All code yoinked from here:<br />• <a href="https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp">https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp</a><br />• <a href="https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.h">https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.h</a><br /><br />Create a struct containing the variables for your <code>HookFunction</code> function<br />and loop through it to hook all of your functions.<br />Much more effective than hooking functions 1 by 1 if you have a long list.<br /><br /><strong><h2>main.c</h2></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&quot;hook.h&quot;<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;i&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	InstallHooks();<br />	<br />	MessageBoxA(NULL,&nbsp;&quot;hello&quot;,&nbsp;&quot;hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&nbsp;good&nbsp;sir&quot;,&nbsp;&quot;hi&nbsp;#2&quot;,&nbsp;MB_OK);<br />	MessageBoxW(NULL,&nbsp;L&quot;what&nbsp;if&nbsp;i&nbsp;try&nbsp;with&nbsp;MessageBoxW?&quot;,&nbsp;L&quot;hi&nbsp;#3&quot;,&nbsp;MB_OK);<br />	MessageBoxW(NULL,&nbsp;L&quot;hello&nbsp;sir?&quot;,&nbsp;L&quot;hi&nbsp;#4&quot;,&nbsp;MB_OK);<br /><br />	UninstallHooks();<br />	<br />	MessageBoxA(NULL,&nbsp;&quot;i&nbsp;don&#39;t&nbsp;think&nbsp;he&nbsp;can&nbsp;hear&nbsp;me&nbsp;at&nbsp;all&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>hook.h</h2></strong><br /><div class="codebox"><div class="codebox">#pragma&nbsp;once<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />struct&nbsp;HOOK_ARRAY&nbsp;{<br />	char*&nbsp;dll_name;<br />	char*&nbsp;function_name;<br />	void*&nbsp;hooked_function;<br />	void**&nbsp;p_orig_function;<br />};<br /><br />//&nbsp;Functions<br />void&nbsp;InstallHooks(void);<br />void&nbsp;UninstallHooks(void);<br />BOOL&nbsp;HookFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function);<br />BOOL&nbsp;UnhookFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function);<br /><br />//&nbsp;Original&nbsp;&amp;&nbsp;Hooked&nbsp;functions<br />int(__stdcall*&nbsp;orig_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hooked_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br /><br />int(__stdcall*&nbsp;orig_MessageBoxW)(HWND&nbsp;hWnd,&nbsp;LPWSTR&nbsp;lpText,&nbsp;LPWSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hooked_MessageBoxW(HWND&nbsp;hWnd,&nbsp;LPWSTR&nbsp;lpText,&nbsp;LPWSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);</div></div><br /><br /><strong><h2>hook.c</h2></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;hook.h&quot;<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&quot;hde/hde32.h&quot;<br /><br />struct&nbsp;HOOK_ARRAY&nbsp;HookList[]&nbsp;=<br />{<br />	{&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;&amp;hooked_MessageBoxA,&nbsp;(LPVOID)&amp;orig_MessageBoxA},<br />	{&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxW&quot;,&nbsp;&amp;hooked_MessageBoxW,&nbsp;(LPVOID)&amp;orig_MessageBoxW}<br />};<br /><br />//&nbsp;Hooked&nbsp;functions<br />int&nbsp;__stdcall&nbsp;hooked_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxA&nbsp;intercepted!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;text:&nbsp;%s&nbsp;\n\t&nbsp;caption:&nbsp;%s&nbsp;\n\t&nbsp;type:&nbsp;%d&nbsp;\n&quot;,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br /><br />	return&nbsp;orig_MessageBoxA(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />int&nbsp;__stdcall&nbsp;hooked_MessageBoxW(HWND&nbsp;hWnd,&nbsp;LPWSTR&nbsp;lpText,&nbsp;LPWSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxW&nbsp;intercepted!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;text:&nbsp;%ws&nbsp;\n\t&nbsp;caption:&nbsp;%ws&nbsp;\n\t&nbsp;type:&nbsp;%d&nbsp;\n&quot;,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br /><br />	return&nbsp;orig_MessageBoxW(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />/*<br />Loop&nbsp;through&nbsp;a&nbsp;struct&nbsp;and&nbsp;install&nbsp;the&nbsp;provided&nbsp;hooks.<br />*/<br />void&nbsp;InstallHooks(void)<br />{<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	int&nbsp;i&nbsp;=&nbsp;0;<br />	int&nbsp;no_of_hooks&nbsp;=&nbsp;sizeof(HookList)&nbsp;/&nbsp;sizeof(struct&nbsp;HOOK_ARRAY);<br /><br />	printf(&quot;[*]&nbsp;installing&nbsp;hooks&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;*&nbsp;number&nbsp;of&nbsp;hooks:&nbsp;%d&nbsp;\n&quot;,&nbsp;no_of_hooks);<br /><br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;no_of_hooks;&nbsp;i++)<br />	{<br />		printf(&quot;\t&nbsp;*&nbsp;hooking&nbsp;%s...&nbsp;&quot;,&nbsp;HookList[i].function_name);<br />		b_ret&nbsp;=&nbsp;HookFunction(HookList[i].dll_name,&nbsp;HookList[i].function_name,&nbsp;HookList[i].hooked_function,&nbsp;HookList[i].p_orig_function);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;TRUE)<br />			printf(&quot;success!&nbsp;\n&quot;);<br />	}<br /><br />	printf(&quot;\n&quot;);<br /><br />	return;<br />}<br /><br />/*<br />Loop&nbsp;through&nbsp;a&nbsp;struct&nbsp;and&nbsp;uninstall&nbsp;the&nbsp;provided&nbsp;hooks.<br />*/<br />void&nbsp;UninstallHooks(void)<br />{<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	int&nbsp;i&nbsp;=&nbsp;0;<br />	int&nbsp;no_of_hooks&nbsp;=&nbsp;sizeof(HookList)&nbsp;/&nbsp;sizeof(struct&nbsp;HOOK_ARRAY);<br /><br />	printf(&quot;\n[*]&nbsp;uninstalling&nbsp;hooks&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;*&nbsp;number&nbsp;of&nbsp;hooks:&nbsp;%d&nbsp;\n&quot;,&nbsp;no_of_hooks);<br /><br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;no_of_hooks;&nbsp;i++)<br />	{<br />		printf(&quot;\t&nbsp;*&nbsp;unhooking&nbsp;%s...&nbsp;&quot;,&nbsp;HookList[i].function_name);<br />		b_ret&nbsp;=&nbsp;UnhookFunction(HookList[i].dll_name,&nbsp;HookList[i].function_name,&nbsp;HookList[i].hooked_function,&nbsp;HookList[i].p_orig_function);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;TRUE)<br />			printf(&quot;success!&nbsp;\n&quot;);<br />	}<br /><br />	return;<br />}<br /><br />/*<br />Hooks&nbsp;a&nbsp;function&nbsp;by&nbsp;overwriting&nbsp;the&nbsp;first&nbsp;5&nbsp;bytes&nbsp;with&nbsp;an&nbsp;E9&nbsp;(jmp&nbsp;relative&nbsp;instruction)&nbsp;to&nbsp;trampoline&nbsp;space.<br />From&nbsp;the&nbsp;trampoline&nbsp;space&nbsp;we&nbsp;jump&nbsp;to&nbsp;our&nbsp;hook&nbsp;code.<br />The&nbsp;trampoline&nbsp;space&nbsp;also&nbsp;stores&nbsp;the&nbsp;first&nbsp;5&nbsp;bytes&nbsp;of&nbsp;the&nbsp;original&nbsp;function&nbsp;as&nbsp;a&nbsp;well&nbsp;as&nbsp;a&nbsp;jump&nbsp;back&nbsp;so&nbsp;that&nbsp;we&nbsp;can&nbsp;execute&nbsp;the&nbsp;original&nbsp;function<br />if&nbsp;we&nbsp;want&nbsp;to.<br /><br />Parameters:<br />	char*&nbsp;dll_name&nbsp;-&nbsp;name&nbsp;of&nbsp;DLL&nbsp;in&nbsp;which&nbsp;function&nbsp;is&nbsp;located&nbsp;(User32.dll)<br />	char*&nbsp;function_name&nbsp;-&nbsp;function&nbsp;to&nbsp;hook&nbsp;(MessageBoxA)<br />	void*&nbsp;hooked_function&nbsp;-&nbsp;address&nbsp;of&nbsp;hook&nbsp;code&nbsp;(&amp;hooked_MessageBoxA)<br />	void**&nbsp;p_orig_function&nbsp;-&nbsp;address&nbsp;of&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;((LPVOID)&amp;orig_MessageBoxA&nbsp;&lt;-&nbsp;points&nbsp;to&nbsp;trampoline&nbsp;space)<br />*/<br />BOOL&nbsp;HookFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br /><br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;original_function&nbsp;=&nbsp;NULL;<br /><br />	DWORD&nbsp;instruction_space&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;p_instruction&nbsp;=&nbsp;NULL;<br />	hde32s&nbsp;instruction_disasm&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	LPVOID&nbsp;trampoline_addr&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;jmp_originalfunction&nbsp;=&nbsp;0;<br />	DWORD&nbsp;jmp_trampoline&nbsp;=&nbsp;0;<br />	DWORD&nbsp;jmp_hook&nbsp;=&nbsp;0;<br /><br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />	original_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(original_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;grab&nbsp;address&nbsp;of&nbsp;%s:&nbsp;%d&nbsp;\n&quot;,&nbsp;function_name,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	/*<br />	Allocate&nbsp;trampoline&nbsp;space<br />	Will&nbsp;contain:<br />		-&nbsp;(5&nbsp;bytes)&nbsp;jmp&nbsp;hook_function<br />		-&nbsp;(5&nbsp;bytes)&nbsp;5&nbsp;bytes&nbsp;from&nbsp;original&nbsp;function<br />		-&nbsp;(5&nbsp;bytes)&nbsp;jmp&nbsp;original_function&nbsp;+&nbsp;5<br />	*/<br />	trampoline_addr&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;15,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(trampoline_addr&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;allocate&nbsp;trampoline&nbsp;space:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Calculate&nbsp;jumps<br />	jmp_trampoline&nbsp;=&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;5)&nbsp;-&nbsp;(DWORD)original_function;				//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;original&nbsp;function&nbsp;+&nbsp;0&nbsp;to&nbsp;trampoline&nbsp;+&nbsp;10<br />	jmp_originalfunction&nbsp;=&nbsp;((DWORD)original_function)&nbsp;-&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;5);		//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;trampoline&nbsp;+&nbsp;5&nbsp;to&nbsp;original&nbsp;function<br />	jmp_hook&nbsp;=&nbsp;(DWORD)hooked_function&nbsp;-&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;10)&nbsp;-&nbsp;5;					//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;trampoline&nbsp;+&nbsp;10&nbsp;to&nbsp;hooked&nbsp;code<br /><br />	//&nbsp;Construct&nbsp;trampoline<br />	memcpy_s((BYTE*)trampoline_addr,&nbsp;5,&nbsp;original_function,&nbsp;5);					//&nbsp;Copy&nbsp;first&nbsp;5&nbsp;bytes&nbsp;from&nbsp;original&nbsp;function&nbsp;to&nbsp;trampoline&nbsp;space<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;5,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);							//&nbsp;Jump&nbsp;to&nbsp;original&nbsp;function&nbsp;+&nbsp;5&nbsp;(bypasses&nbsp;the&nbsp;hook)<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;6,&nbsp;4,&nbsp;&amp;jmp_originalfunction,&nbsp;4);<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;10,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);						//&nbsp;Jump&nbsp;to&nbsp;hook&nbsp;code<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;11,&nbsp;4,&nbsp;&amp;jmp_hook,&nbsp;4);<br /><br />	//&nbsp;Disassemble&nbsp;instructions&nbsp;at&nbsp;original&nbsp;function&nbsp;until&nbsp;we&nbsp;have&nbsp;5&nbsp;bytes&nbsp;to&nbsp;work&nbsp;with&nbsp;(to&nbsp;build&nbsp;a&nbsp;jmp)<br />	while&nbsp;(instruction_space&nbsp;&lt;&nbsp;5)<br />	{<br />		p_instruction&nbsp;=&nbsp;(LPVOID)((DWORD)original_function&nbsp;+&nbsp;(DWORD)instruction_space);<br />		instruction_space&nbsp;+=&nbsp;hde32_disasm(p_instruction,&nbsp;&amp;instruction_disasm);<br />	}<br /><br />	//&nbsp;Make&nbsp;original&nbsp;function&nbsp;writable<br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;make&nbsp;memory&nbsp;writable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Overwrite&nbsp;first&nbsp;5&nbsp;bytes&nbsp;of&nbsp;original&nbsp;function&nbsp;with&nbsp;jump&nbsp;to&nbsp;trampoline<br />	memcpy_s(original_function,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);<br />	memcpy_s((BYTE*)original_function&nbsp;+&nbsp;1,&nbsp;4,&nbsp;&amp;jmp_trampoline,&nbsp;4);<br /><br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;restore&nbsp;original&nbsp;memory&nbsp;protection:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;start&nbsp;of&nbsp;trampoline&nbsp;(trampoline&nbsp;will&nbsp;run&nbsp;function&nbsp;prologue&nbsp;and&nbsp;then&nbsp;jump&nbsp;to&nbsp;original&nbsp;function)<br />	*p_orig_function&nbsp;=&nbsp;trampoline_addr;<br /><br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;original_function,&nbsp;5);		//&nbsp;Not&nbsp;sure&nbsp;if&nbsp;necessarily&nbsp;needed<br /><br />	return&nbsp;okay;<br />}<br /><br />/*<br />Unhooks&nbsp;a&nbsp;function&nbsp;by&nbsp;restoring&nbsp;the&nbsp;first&nbsp;5&nbsp;original&nbsp;bytes&nbsp;of&nbsp;the&nbsp;function&nbsp;from&nbsp;trampoline&nbsp;space,<br />and&nbsp;then&nbsp;freeing&nbsp;the&nbsp;tramopline&nbsp;space.<br />*/<br />BOOL&nbsp;UnhookFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function)<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br /><br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;original_function&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;trampoline_addr&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />	original_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(original_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;grab&nbsp;address&nbsp;of&nbsp;%s:&nbsp;%d&nbsp;\n&quot;,&nbsp;function_name,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Make&nbsp;original&nbsp;function&nbsp;writable<br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;make&nbsp;memory&nbsp;writable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Restore&nbsp;first&nbsp;5&nbsp;bytes&nbsp;of&nbsp;original&nbsp;function&nbsp;with&nbsp;bytes&nbsp;from&nbsp;trampoline<br />	memcpy_s((BYTE*)original_function,&nbsp;5,&nbsp;*p_orig_function,&nbsp;5);<br /><br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;restore&nbsp;original&nbsp;memory&nbsp;protection:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Free&nbsp;the&nbsp;trampoline&nbsp;space&nbsp;(p_orig_function&nbsp;points&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;trampoline&nbsp;space)<br />	b_ret&nbsp;=&nbsp;VirtualFree((LPVOID)*p_orig_function,&nbsp;0,&nbsp;MEM_RELEASE);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;free&nbsp;trampoline&nbsp;space:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;original_function,&nbsp;5);		//&nbsp;Not&nbsp;sure&nbsp;if&nbsp;necessarily&nbsp;needed<br /><br />	return&nbsp;okay;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
