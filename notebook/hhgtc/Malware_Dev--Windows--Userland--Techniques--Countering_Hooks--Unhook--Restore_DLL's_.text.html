<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Restore DLL's .text</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Unhooking - Detect Hook &amp; Restore DLL&#39;s .text</h1></strong><br />If you can&#39;t be bothered to restore the original bytes of each hooked function, you could simply overwrite the entire .text section of the loaded DLL in your process (that has been modified with hooks) with the original DLL on disk.<br /><br />Examples (credit goes here):<br />• <a href="https://www.ired.team/offensive-security/defense-evasion/how-to-unhook-a-dll-using-c++">https://www.ired.team/offensive-security/defense-evasion/how-to-unhook-a-dll-using-c++</a><br />• <a href="https://github.com/NtRaiseHardError/AntiHook/blob/d214354cf98398553cc981aca7b95784f79af03a/AntiHook/AntiHook/AntiHook.c#L531">https://github.com/NtRaiseHardError/AntiHook/blob/d214354cf98398553cc981aca7b95784f79af03a/AntiHook/AntiHook/AntiHook.c#L531</a><br /><br /><strong><h2>## Demo</h2></strong><br />I&#39;m hooking <code>MessageBoxA</code> from <code>User32.dll</code><br />Here are my function calls:<br />• unhooked MessageBoxA<br />• hooked MessageBoxA<br />• hooked MessageBoxA<br />• unhookedMessageBoxA<br /><br /><div class="codebox"><div class="codebox">int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;i&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	HookFunction(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;&amp;hooked_MessageBoxA,&nbsp;(LPVOID)&amp;orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&quot;,&nbsp;&quot;hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&nbsp;good&nbsp;sir&quot;,&nbsp;&quot;hi&nbsp;#2&quot;,&nbsp;MB_OK);<br />	<br />	ReplaceTextSection(&quot;User32.dll&quot;);<br />	MessageBoxA(NULL,&nbsp;&quot;was&nbsp;he&nbsp;listening?&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Here&#39;s the first unhooked MessageBoxA<br /><a href=""><img src="images/1706-1.png" alt="images/1706-1.png" /></a><br /><br />Then we hook MessageBoxA and our function gets intercepted (the parameters get logged)<br /><a href=""><img src="images/1706-2.png" alt="images/1706-2.png" /></a><br /><br />The 2nd MessageBoxA gets intercepted too<br /><a href=""><img src="images/1706-3.png" alt="images/1706-3.png" /></a><br /><br />Then we replace User32.dll&#39;s .text section.<br />We call MessageBoxA again and see that the function is no longer hooked.<br /><a href=""><img src="images/1706-4.png" alt="images/1706-4.png" /></a><br /><br /><br /><strong><h2>## Code</h2></strong><br />Compiled as x86 Debug on Windows 10 x64 2004 in Visual Studio 2019.<br />The <code>ReplaceTextSection()</code> works for both x86 and x64, but the <code>HookFunction</code> function which was included for testing only works for x86 (in case you&#39;re wanting to test the code).<br /><br /><code>ReplaceTextSection()</code> HAS NO BASE RELOCATIONS.<br />This might cause problems when replacing some DLLs.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;psapi.h&gt;<br />#include&nbsp;&quot;hde/hde32.h&quot;<br /><br />int(__stdcall*&nbsp;orig_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hooked_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxA&nbsp;intercepted!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;text:&nbsp;%s&nbsp;\n\t&nbsp;caption:&nbsp;%s&nbsp;\n\t&nbsp;type:&nbsp;%d&nbsp;\n&quot;,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br /><br />	return&nbsp;orig_MessageBoxA(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />/*<br />x86&nbsp;only&nbsp;:/<br />*/<br />BOOL&nbsp;HookFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br /><br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;original_function&nbsp;=&nbsp;NULL;<br /><br />	DWORD&nbsp;instruction_space&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;p_instruction&nbsp;=&nbsp;NULL;<br />	hde32s&nbsp;instruction_disasm&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	LPVOID&nbsp;trampoline_addr&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;jmp_originalfunction&nbsp;=&nbsp;0;<br />	DWORD&nbsp;jmp_trampoline&nbsp;=&nbsp;0;<br />	DWORD&nbsp;jmp_hook&nbsp;=&nbsp;0;<br /><br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	printf(&quot;[+]&nbsp;hooking&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />	original_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(original_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;grab&nbsp;address&nbsp;of&nbsp;%s:&nbsp;%d&nbsp;\n&quot;,&nbsp;function_name,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	/*<br />	Allocate&nbsp;trampoline&nbsp;space<br />	Will&nbsp;contain:<br />		-&nbsp;(5&nbsp;bytes)&nbsp;jmp&nbsp;hook_function<br />		-&nbsp;(5&nbsp;bytes)&nbsp;5&nbsp;bytes&nbsp;from&nbsp;original&nbsp;function<br />		-&nbsp;(5&nbsp;bytes)&nbsp;jmp&nbsp;original_function&nbsp;+&nbsp;1<br />	*/<br />	trampoline_addr&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;15,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(trampoline_addr&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;gatecode&nbsp;space:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Calculate&nbsp;jumps<br />	jmp_trampoline&nbsp;=&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;5)&nbsp;-&nbsp;(DWORD)original_function;				//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;original&nbsp;function&nbsp;+&nbsp;0&nbsp;to&nbsp;trampoline&nbsp;+&nbsp;10<br />	jmp_originalfunction&nbsp;=&nbsp;((DWORD)original_function)&nbsp;-&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;5);		//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;trampoline&nbsp;+&nbsp;5&nbsp;to&nbsp;original&nbsp;function<br />	jmp_hook&nbsp;=&nbsp;(DWORD)hooked_function&nbsp;-&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;10)&nbsp;-&nbsp;5;					//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;trampoline&nbsp;+&nbsp;10&nbsp;to&nbsp;hooked&nbsp;code<br /><br />	//&nbsp;Construct&nbsp;trampoline<br />	memcpy_s((BYTE*)trampoline_addr,&nbsp;5,&nbsp;original_function,&nbsp;5);					//&nbsp;Copy&nbsp;first&nbsp;5&nbsp;bytes&nbsp;from&nbsp;original&nbsp;function&nbsp;to&nbsp;trampoline&nbsp;space<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;5,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);							//&nbsp;Jump&nbsp;to&nbsp;original&nbsp;function&nbsp;+&nbsp;5&nbsp;(bypasses&nbsp;the&nbsp;hook)<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;6,&nbsp;4,&nbsp;&amp;jmp_originalfunction,&nbsp;4);<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;10,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);						//&nbsp;Jump&nbsp;to&nbsp;hook&nbsp;code<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;11,&nbsp;4,&nbsp;&amp;jmp_hook,&nbsp;4);<br /><br />	//&nbsp;Disassemble&nbsp;instructions&nbsp;at&nbsp;original&nbsp;function&nbsp;until&nbsp;we&nbsp;have&nbsp;5&nbsp;bytes&nbsp;to&nbsp;work&nbsp;with&nbsp;(to&nbsp;build&nbsp;a&nbsp;jmp)<br />	while&nbsp;(instruction_space&nbsp;&lt;&nbsp;5)<br />	{<br />		p_instruction&nbsp;=&nbsp;(LPVOID)((DWORD)original_function&nbsp;+&nbsp;(DWORD)instruction_space);<br />		instruction_space&nbsp;+=&nbsp;hde32_disasm(p_instruction,&nbsp;&amp;instruction_disasm);<br />	}<br /><br />	//&nbsp;Make&nbsp;original&nbsp;function&nbsp;writable<br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;make&nbsp;memory&nbsp;writable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Overwrite&nbsp;first&nbsp;5&nbsp;bytes&nbsp;of&nbsp;original&nbsp;function&nbsp;with&nbsp;jump&nbsp;to&nbsp;trampoline<br />	memcpy_s(original_function,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);<br />	memcpy_s((BYTE*)original_function&nbsp;+&nbsp;1,&nbsp;4,&nbsp;&amp;jmp_trampoline,&nbsp;4);<br /><br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;restore&nbsp;original&nbsp;memory&nbsp;protection:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;start&nbsp;of&nbsp;trampoline&nbsp;(trampoline&nbsp;will&nbsp;run&nbsp;function&nbsp;prologue&nbsp;and&nbsp;then&nbsp;jump&nbsp;to&nbsp;original&nbsp;function)<br />	*p_orig_function&nbsp;=&nbsp;trampoline_addr;<br /><br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;original_function,&nbsp;7);		//&nbsp;Not&nbsp;sure&nbsp;if&nbsp;necessarily&nbsp;needed<br /><br />	return&nbsp;okay;<br />}<br /><br />/*<br />Replaces&nbsp;the&nbsp;specified&nbsp;DLL&#39;s&nbsp;.text&nbsp;section&nbsp;in&nbsp;memory&nbsp;with&nbsp;its&nbsp;.text&nbsp;section&nbsp;on&nbsp;disk.<br />Supports&nbsp;both&nbsp;x86&nbsp;and&nbsp;x64.<br />*/<br />BOOL&nbsp;ReplaceTextSection(char*&nbsp;dll_name)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	int&nbsp;i_ret&nbsp;=&nbsp;0;<br />	<br />	MODULEINFO&nbsp;mi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	HMODULE&nbsp;h_memDLL&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;mem_dll_base&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;mem_text_addr&nbsp;=&nbsp;NULL;<br />	<br />	char&nbsp;disk_dll_path[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	HANDLE&nbsp;h_diskDLL&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_diskDLLMap&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;disk_dll_base&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;disk_text_addr&nbsp;=&nbsp;NULL;<br />	PIMAGE_DOS_HEADER&nbsp;mem_DLL_DosHeader&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;mem_DLL_PeHeader&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;mem_DLL_SectionHeader&nbsp;=&nbsp;NULL;<br /><br />	DWORD&nbsp;text_offset&nbsp;=&nbsp;0;<br />	DWORD&nbsp;text_size&nbsp;=&nbsp;0;<br /><br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	<br />	printf(&quot;[+]&nbsp;replacing&nbsp;%s&#39;s&nbsp;.text&nbsp;section&nbsp;\n&quot;,&nbsp;dll_name);<br /><br />	//&nbsp;Grab&nbsp;address&nbsp;of&nbsp;DLL&nbsp;in&nbsp;memory<br />	h_memDLL&nbsp;=&nbsp;GetModuleHandleA(dll_name);<br />	GetModuleInformation(GetCurrentProcess(),&nbsp;h_memDLL,&nbsp;&amp;mi,&nbsp;sizeof(mi));<br />	mem_dll_base&nbsp;=&nbsp;mi.lpBaseOfDll;<br />	printf(&quot;\t&nbsp;*&nbsp;%s&nbsp;loaded&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_name,&nbsp;mem_dll_base);<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;the&nbsp;DLL&nbsp;in&nbsp;memory,&nbsp;find&nbsp;its&nbsp;.text&nbsp;section,&nbsp;and&nbsp;grab&nbsp;its&nbsp;offset&nbsp;and&nbsp;size<br />	mem_DLL_DosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)mem_dll_base;<br />	mem_DLL_PeHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((SIZE_T)mem_dll_base&nbsp;+&nbsp;(SIZE_T)mem_DLL_DosHeader-&gt;e_lfanew);<br />	mem_DLL_SectionHeader&nbsp;=&nbsp;IMAGE_FIRST_SECTION(mem_DLL_PeHeader);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;mem_DLL_PeHeader-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		if&nbsp;(strcmp(mem_DLL_SectionHeader-&gt;Name,&nbsp;&quot;.text&quot;)&nbsp;==&nbsp;0)<br />		{<br />			text_offset&nbsp;=&nbsp;mem_DLL_SectionHeader-&gt;VirtualAddress;<br />			text_size&nbsp;=&nbsp;mem_DLL_SectionHeader-&gt;Misc.VirtualSize;<br />			break;<br />		}<br />	}<br /><br />	printf(&quot;\t&nbsp;*&nbsp;.text&nbsp;offset:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;text_offset);<br />	printf(&quot;\t&nbsp;*&nbsp;.text&nbsp;size:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;text_size);<br /><br />	//&nbsp;Open&nbsp;disk&nbsp;DLL&nbsp;and&nbsp;map&nbsp;it&nbsp;into&nbsp;memory<br />	sprintf_s(disk_dll_path,&nbsp;MAX_PATH,&nbsp;&quot;C:\\Windows\\System32\\%s&quot;,&nbsp;dll_name);<br />	h_diskDLL&nbsp;=&nbsp;CreateFileA(disk_dll_path,&nbsp;GENERIC_READ,&nbsp;FILE_SHARE_READ,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;0,&nbsp;NULL);<br />	if&nbsp;(h_diskDLL&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;\t&nbsp;-&nbsp;failed&nbsp;to&nbsp;open&nbsp;DLL&nbsp;path:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	<br />	h_diskDLLMap&nbsp;=&nbsp;CreateFileMappingA(h_diskDLL,&nbsp;NULL,&nbsp;PAGE_READONLY&nbsp;|&nbsp;SEC_IMAGE,&nbsp;0,&nbsp;0,&nbsp;NULL);<br />	if&nbsp;(h_diskDLLMap&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;-&nbsp;failed&nbsp;to&nbsp;create&nbsp;file&nbsp;mapping&nbsp;of&nbsp;disk&nbsp;DLL:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	disk_dll_base&nbsp;=&nbsp;MapViewOfFile(h_diskDLLMap,&nbsp;FILE_MAP_READ,&nbsp;0,&nbsp;0,&nbsp;0);<br />	if&nbsp;(disk_dll_base&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;-&nbsp;failed&nbsp;to&nbsp;map&nbsp;disk&nbsp;DLL:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	<br />	printf(&quot;\t&nbsp;+&nbsp;mapped&nbsp;%s&nbsp;from&nbsp;disk&nbsp;into&nbsp;memory&nbsp;\n&quot;,&nbsp;dll_name);<br /><br />	//&nbsp;Make&nbsp;.text&nbsp;section&nbsp;writable&nbsp;and&nbsp;overwrite&nbsp;the&nbsp;memory&nbsp;.text&nbsp;section&nbsp;(which&nbsp;has&nbsp;hooked&nbsp;functions)&nbsp;with&nbsp;the&nbsp;disk&nbsp;.text&nbsp;section<br />	disk_text_addr&nbsp;=&nbsp;(LPVOID)((SIZE_T)disk_dll_base&nbsp;+&nbsp;text_offset);<br />	mem_text_addr&nbsp;=&nbsp;(LPVOID)((SIZE_T)mem_dll_base&nbsp;+&nbsp;text_offset);<br /><br />	b_ret&nbsp;=&nbsp;VirtualProtect(mem_text_addr,&nbsp;text_size,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;-&nbsp;failed&nbsp;to&nbsp;make&nbsp;.text&nbsp;section&nbsp;writable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	<br />	i_ret&nbsp;=&nbsp;memcpy_s(mem_text_addr,&nbsp;text_size,&nbsp;disk_text_addr,&nbsp;text_size);<br />	if&nbsp;(i_ret&nbsp;!=&nbsp;0)<br />	{<br />		printf(&quot;\t&nbsp;-&nbsp;failed&nbsp;to&nbsp;overwrite&nbsp;.text&nbsp;section:&nbsp;%d&nbsp;\n&quot;,&nbsp;i_ret);<br />		ok&nbsp;=&nbsp;FALSE;<br />	}<br />	printf(&quot;\t&nbsp;+&nbsp;wrote&nbsp;disk&nbsp;.text&nbsp;to:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;mem_text_addr);<br />	<br />	b_ret&nbsp;=&nbsp;VirtualProtect(mem_text_addr,&nbsp;text_size,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;TRUE)<br />		printf(&quot;\t&nbsp;+&nbsp;restored&nbsp;.text&#39;s&nbsp;original&nbsp;memory&nbsp;protection&nbsp;\n&quot;);<br /><br />	printf(&quot;\t&nbsp;+&nbsp;done!&nbsp;\n&quot;);<br /><br />cleanup:<br />	if&nbsp;(disk_dll_base)&nbsp;UnmapViewOfFile(disk_dll_base);<br />	if&nbsp;(h_diskDLLMap)&nbsp;CloseHandle(h_diskDLLMap);<br />	if&nbsp;(h_diskDLL)&nbsp;CloseHandle(h_diskDLL);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;i&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	HookFunction(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;&amp;hooked_MessageBoxA,&nbsp;(LPVOID)&amp;orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&quot;,&nbsp;&quot;hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&nbsp;good&nbsp;sir&quot;,&nbsp;&quot;hi&nbsp;#2&quot;,&nbsp;MB_OK);<br />	<br />	ReplaceTextSection(&quot;User32.dll&quot;);<br />	MessageBoxA(NULL,&nbsp;&quot;was&nbsp;he&nbsp;listening?&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
