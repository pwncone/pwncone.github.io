<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>NtGlobalFlags</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># NtGlobalFlags</h1></strong><br />• <a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag/">https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag/</a><br />• <a href="https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag">https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag</a><br />• <a href="https://github.com/cetfor/AntiDBG/blob/89f8fb7fb572aae326c2b0538e9e2b2cf56cf102/antidbg/antidbg.c#L179">https://github.com/cetfor/AntiDBG/blob/89f8fb7fb572aae326c2b0538e9e2b2cf56cf102/antidbg/antidbg.c#L179</a><br />• <a href="https://osandamalith.com/2016/04/23/debugger-detection-using-ntglobalflag/">https://osandamalith.com/2016/04/23/debugger-detection-using-ntglobalflag/</a> - has 64bit asm example at bottom<br /><br />The PEB stores a field called <code>NtGlobalFlag</code>.<br />On 32bit it&#39;s stored at PEB offset <code>0x68</code>.<br />On 64bit it&#39;s stored at PEB offset <code>0xbc</code>.<br /><br />When a process is being debugged, 3 flags are set:<br />• FLG_HEAP_ENABLE_TAIL_CHECK - 0x10<br />• FLG_HEAP_ENABLE_FREE_CHECK - 0x20<br />• FLG_HEAP_VALIDATE_PARAMETERS - 0x40<br /><br />To check if these flags are set, check for <code>0x70</code> (10 + 20 + 40).<br /><br />• This technique doesn&#39;t detect Visual Studio debugger.<br />• These flags are only set when the program is started by the debugger, not when a process is attached.<br />   ◇ source: <a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag/#detection-code">https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag/#detection-code</a><br /><br /><strong><h2>## Code</h2></strong><br />There are multiple ways to retrieve <code>NtGlobalFlag</code> from the PEB:<br />• via the undocumented <code>RtlGetNtGlobalFlags</code> function<br />   ◇ <a href="https://www.geoffchappell.com/studies/windows/win32/ntdll/api/rtl/regutil/getntglobalflags.htm">https://www.geoffchappell.com/studies/windows/win32/ntdll/api/rtl/regutil/getntglobalflags.htm</a><br />   ◇ <a href="https://github.com/kyREcon/GetNtGlobalFlags/blob/master/GetNtGlobalFlagsFunc.c">https://github.com/kyREcon/GetNtGlobalFlags/blob/master/GetNtGlobalFlagsFunc.c</a><br />• via pure assembly (32bit only if visual studio because it doesn&#39;t like x64 asm)<br />• via the PEB and manual offsets<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />typedef&nbsp;ULONG(__stdcall*&nbsp;t_RtlGetNtGlobalFlags)(void);<br /><br />/*<br />Use&nbsp;undocumented&nbsp;RtlGetNtGlobalFlags&nbsp;function&nbsp;to&nbsp;grab&nbsp;NtGlobalFlag&nbsp;from&nbsp;PEB.<br />*/<br />BOOL&nbsp;DebuggerCheck_NtGlobalFlags_Rtl(void)<br />{<br />	BOOL&nbsp;debugger_present&nbsp;=&nbsp;FALSE;<br />	ULONG&nbsp;nt_global_flags&nbsp;=&nbsp;0;<br /><br />	t_RtlGetNtGlobalFlags&nbsp;d_RtlGetNtGlobalFlags&nbsp;=&nbsp;(t_RtlGetNtGlobalFlags)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;),&nbsp;&quot;RtlGetNtGlobalFlags&quot;);<br />	nt_global_flags&nbsp;=&nbsp;d_RtlGetNtGlobalFlags();<br /><br />	if&nbsp;(nt_global_flags&nbsp;==&nbsp;0x70)		//&nbsp;112&nbsp;decimal<br />		debugger_present&nbsp;=&nbsp;TRUE;<br /><br />	//printf(&quot;%d&nbsp;\n&quot;,&nbsp;nt_global_flags);<br /><br />	return&nbsp;debugger_present;<br />}<br /><br />#ifndef&nbsp;_WIN64<br />/*<br />32bit&nbsp;only&nbsp;because&nbsp;inline&nbsp;ASM.<br />WORKS<br />*/<br />BOOL&nbsp;DebuggerCheck_NtGlobalFlags_32bitASM(void)<br />{<br />	BOOL&nbsp;debugger_present&nbsp;=&nbsp;FALSE;<br />	ULONG&nbsp;nt_global_flags&nbsp;=&nbsp;0;<br /><br />	_asm<br />	{<br />		xor&nbsp;eax,&nbsp;eax;					//&nbsp;clear&nbsp;eax<br />		mov&nbsp;eax,&nbsp;fs:[0x30];				//&nbsp;grab&nbsp;PEB,&nbsp;store&nbsp;in&nbsp;eax<br />		mov&nbsp;eax,&nbsp;[eax&nbsp;+&nbsp;0x68];			//&nbsp;grab&nbsp;NtGlobalFlag&nbsp;value&nbsp;at&nbsp;PEB&nbsp;+&nbsp;offset&nbsp;0x68,&nbsp;store&nbsp;in&nbsp;eax<br />		mov&nbsp;nt_global_flags,&nbsp;eax;		//&nbsp;copy&nbsp;flags&nbsp;from&nbsp;eax&nbsp;into&nbsp;variable<br />	}<br /><br />	if&nbsp;(nt_global_flags&nbsp;==&nbsp;0x70)<br />		debugger_present&nbsp;=&nbsp;TRUE;<br /><br />	//printf(&quot;%d&nbsp;\n&quot;,&nbsp;nt_global_flags);<br /><br />	return&nbsp;debugger_present;<br />}<br />#endif<br /><br />/*<br />Grab&nbsp;the&nbsp;PEB,&nbsp;add&nbsp;the&nbsp;PEB&nbsp;address&nbsp;+&nbsp;offset&nbsp;to&nbsp;NtGlobalFlag,&nbsp;and&nbsp;read&nbsp;the&nbsp;flag&nbsp;value.<br />When&nbsp;a&nbsp;process&nbsp;is&nbsp;being&nbsp;debugged,&nbsp;3&nbsp;flags&nbsp;are&nbsp;set:<br />-&nbsp;FLG_HEAP_ENABLE_TAIL_CHECK&nbsp;-&nbsp;0x10<br />-&nbsp;FLG_HEAP_ENABLE_FREE_CHECK&nbsp;-&nbsp;0x20<br />-&nbsp;FLG_HEAP_VALIDATE_PARAMETERS&nbsp;-&nbsp;0x40<br />	totalling&nbsp;0x70.<br />*/<br />BOOL&nbsp;DebuggerCheck_NtGlobalFlags_PEB(void)<br />{<br />	BOOL&nbsp;debugger_present&nbsp;=&nbsp;FALSE;<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />	PULONG&nbsp;p_nt_global_flags&nbsp;=&nbsp;0;<br /><br />	//&nbsp;grab&nbsp;PEB<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br /><br />	/*<br />	Calculate&nbsp;pointer&nbsp;to&nbsp;NtGlobalFlag&nbsp;in&nbsp;PEB&nbsp;by&nbsp;doing&nbsp;PEB&nbsp;+&nbsp;offset.<br />	-&nbsp;offset&nbsp;to&nbsp;NtGlobalFlag&nbsp;on&nbsp;64bit&nbsp;is&nbsp;0xBC<br />	-&nbsp;offset&nbsp;to&nbsp;NtGlobalFlag&nbsp;on&nbsp;32bit&nbsp;is&nbsp;0x68<br />	*/<br />#ifdef&nbsp;_WIN64<br />	p_nt_global_flags&nbsp;=&nbsp;(PULONG)((PBYTE)p_peb&nbsp;+&nbsp;0xbc);		//&nbsp;64bit<br />#else<br />	p_nt_global_flags&nbsp;=&nbsp;(PULONG)((PBYTE)p_peb&nbsp;+&nbsp;0x68);		//&nbsp;32bit<br />#endif<br /><br />	printf(&quot;peb&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_peb);<br />	printf(&quot;NtGlobalFlag&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_nt_global_flags);<br />	printf(&quot;\t&nbsp;value:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;*p_nt_global_flags);<br /><br />	if&nbsp;(*p_nt_global_flags&nbsp;==&nbsp;0x70)<br />		debugger_present&nbsp;=&nbsp;TRUE;<br /><br />	return&nbsp;debugger_present;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;debugger_present&nbsp;=&nbsp;FALSE;<br />	<br />	//debugger_present&nbsp;=&nbsp;DebuggerCheck_NtGlobalFlags_Rtl();<br />	//debugger_present&nbsp;=&nbsp;DebuggerCheck_NtGlobalFlags_32bitASM();<br />	debugger_present&nbsp;=&nbsp;DebuggerCheck_NtGlobalFlags_PEB();<br />	<br />	if&nbsp;(debugger_present&nbsp;==&nbsp;TRUE)<br />		return&nbsp;1;<br />	<br />	printf(&quot;hey&nbsp;:)&nbsp;\n&quot;);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Bypass</h2></strong><br />• <a href="https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag#Overcome_the_NtGlobalFlag_detection">https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag#Overcome_the_NtGlobalFlag_detection</a><br />• <a href="https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag/#change-the-initial-value-of-ntglobalflag">https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntglobalflag/#change-the-initial-value-of-ntglobalflag</a><br /><br />Here at the breakpoint we see <code>70</code> compared to the value in <code>EAX</code>.<br />In EAX is <code>70</code>.<br />70 means there&#39;s a debugger present.<br />If we modify the value in EAX to <code>0</code>, we can bypass the NtGlobalFlag check.<br /><a href=""><img src="images/1776-1.png" alt="images/1776-1.png" /></a><br /><br />We bypass the check and print <code>hey :)</code> !<br /><a href=""><img src="images/1776-2.png" alt="images/1776-2.png" /></a></div>
</body>
</html>
