<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PHP Type Juggling</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># PHP Type Juggling</h1></strong><br />References<br />• <a href="https://www.owasp.org/images/6/6b/PHPMagicTricks-TypeJuggling.pdf">Overview Presentation by Chris Smith</a><br />• <a href="https://hydrasky.com/network-security/php-string-comparison-vulnerabilities/">Good Cheat Sheet</a><br />• <a href="https://pen-testing.sans.org/blog/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing">San’s Blog</a><br />• <a href="https://www.whitehatsec.com/blog/magic-hashes/">Magic Hashes</a><br /><br /><strong><h2>## About</h2></strong><br />When comparing between data types, PHP has 2 levels of type comparison:<br />• <code>==</code> - loose<br />• <code>===</code> - stritct<br /><br /><strong><h3>### Strict Comparisons</h3></strong><br />Strict comparisons - <code>===</code> - have to be exactly the same<br /><br /><a href=""><img src="images/177-1.png" alt="images/177-1.png" /></a><br /><br /><strong><h3>### Loose Comparisons</h3></strong><br />Loose comparisons - <code>==</code> - don&#39;t have to be exaclty the same.<br />PHP will make predictions on the types being compared to compensate for human error.<br /><br /><em><strong>For example:</strong></em><br /><span style="text-decoration:underline;">Comparing 2 strings?</span><br />• If PHP decides that both operands look like numbers, despite them actually being strings, PHP will convert them both to integers and perform a comparison<br /><br /><code>“0e12345” == “0e54321”</code>  equals <code>TRUE</code><br /><code>“0e12345” &lt;= “1”</code>              equals <code>TRUE</code><br /><code>“0e12345” == “0”</code>              equals <code>TRUE</code><br /><code>“0xF” == “15”</code>                    equals <code>TRUE</code><br /><br /><span style="text-decoration:underline;">Comparing an integer and a string?</span><br />• PHP will attempt to convert the string to a number, and then perform a comparison<br />   ◇ string starts with 0? php converts the string to the number 0<br />   ◇ strings starts with 1? php converst the string to the number 1<br />   ◇ string starts with a letter? php convert the string to the number 0t<br /><br /><code>“0000” == int(0)</code>  equals <code>TRUE</code><br /><code>“0e12” == int(0)</code>  equals <code>TRUE</code><br /><code>“1abc” == int(1)</code>  equals <code>TRUE</code><br /><code>“0abc” == int(0)</code>  equals <code>TRUE</code><br /><code>“abc”  == int(0)</code>  equals <code>TRUE</code><br /><br /><a href=""><img src="images/177-2.png" alt="images/177-2.png" /></a><br /><br /><span style="text-decoration:underline;">0e</span><br />• <code>e</code> in php means <em>convert the number to an exponent</em> (a power)<br />   ◇ e.g. <code>24e12</code> translates to <code>24</code><code><sup>12</sup></code><br />• Because of loose type juggling, this causes a problem<br /><br /><em>For example</em>, you have 2 strings:<br />• <code>&quot;0e462097431906509019562988736854&quot;</code><br />• <code>&quot;0e830400451993494058024219903391&quot;</code><br />   ◇ You compare these 2 strings<br />   ◇ <code>&quot;0e462097431906509019562988736854&quot;</code> == <code>&quot;0e830400451993494058024219903391&quot;</code> equals <code>TRUE</code><br />   ◇ Because you used a loose comparison - <code>==</code> - these 2 strings are equal<br />      ▪ This is because:<br />         - PHP has decided that these strings actually look like numbers, despite them being strings<br />         - Because PHP sees them as numbers, it converts the strings to integers and, because of <code>e</code>. converts the numbers after <code>e</code> into exponents<br />            → <code>0e462097431906509019562988736854</code> now becomes <code>0e</code><code><sup>462097431906509019562988736854</sup></code><br />            → <code>0e830400451993494058024219903391</code> now becomes <code>0e</code><code><sup>830400451993494058024219903391</sup></code><br />         - Now PHP performs the integer comparison<br />         - Both integers are read as <code>0e</code>      <br />         - PHP runs <code>0e == 0e</code>, which equals true<br />         - These 2 hashes, despite being completely different, have been classed as numerically equal by PHP because of loose type casting<br /><br />• How to exploit <code>0e</code>?<br />   ◇ <code>0e</code> is exploitable if you&#39;re dealing with password hashes/logging into a system<br />   ◇ e.g. admin&#39;s md5 password hash is <code>0e462097431906509019562988736854</code><br />   ◇ To log in as admin, you need to find a password that, when md5 hashed, starts wtih <code>0e</code><br />      ▪ When PHP compares the password that we submit at login to the password in the database, it will only compare the <code>0e</code> part of the string (because the rest of it is converted into an exponent)<br />   ◇ <a href="https://www.whitehatsec.com/blog/magic-hashes/">https://www.whitehatsec.com/blog/magic-hashes/</a> has a collection of passwords that hash to <code>0e</code> in various different formats<br /><br />Examples:<br />• <em>hackthebox Falafel</em><br /></div>
</body>
</html>
