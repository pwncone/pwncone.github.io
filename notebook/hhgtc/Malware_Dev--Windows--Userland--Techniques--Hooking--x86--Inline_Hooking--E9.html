<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>E9</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x86 Inline Hooking - E9</h1></strong><br /><strong>Links</strong><br />• <a href="https://blog.nettitude.com/uk/windows-inline-function-hooking">https://blog.nettitude.com/uk/windows-inline-function-hooking</a><br />   ◇ <a href="https://github.com/nettitude/InlineFunctionHooking">https://github.com/nettitude/InlineFunctionHooking</a> - code for above<br />• <a href="http://www.rohitab.com/discuss/topic/33771-patch-hook/?p=10062694">http://www.rohitab.com/discuss/topic/33771-patch-hook/?p=10062694</a> - Inspiration for MalwareTech&#39;s BasicHook<br />• <a href="https://github.com/MalwareTech/BasicHook">https://github.com/MalwareTech/BasicHook</a><br />   ◇ <a href="https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html">https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html</a><br />   ◇ <a href="https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-2.html">https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-2.html</a><br /><br />Inline hooking refers to placing a hook inside the body of the function.<br />Not before it, not after it, but in the function body.<br /><br />To hook a function, <br />you overwrite its first 5 bytes with a jump to trampoline space.<br />This trampoline space stores the bytes we overwrote, followed by a jump to our hook code.<br /><br /><strong><h2>## MessageBoxA Diagram</h2></strong><br />This is a diagram of inline hooking MessageBoxA.<br />We&#39;ve overwritten the first 5 bytes of MessageBoxA with a jump to trampoline + 10.<br />In the trampoline space, we&#39;ve saved those bytes we overwrote.<br /><br />When a user calls MessageBoxA:<br />1. The hook code gets hit, and MessageBoxA jumps to trampoline + 10<br />2. Trampoline + 10 jumps to our hooked_MessageBoxA function<br />3. hooked_MessageBoxA does its thing, and then returns to the trampoline + 0<br />4. The trampoline space executes MessageBoxA&#39;s prologue code, and then jumps to MessageBoxA + 5<br />   - Jumping to MessageBoxA + 5 dodges to the jump to trampoline space<br />   and executes the original MessageBoxA function<br /><br />If you didn&#39;t want to execute the original MessageBoxA function,<br />you could simply return 0<br /><br /><a href=""><img src="images/1676-1.png" alt="images/1676-1.png" /></a><br /><br />Here&#39;s what MessageBoxA looks like before it&#39;s been hooked.<br /><code>mov edi, edi</code> <code>push ebp</code> <code>mov ebp, esp</code> is the function prologue we&#39;ll overwrite.<br /><a href=""><img src="images/1676-2.png" alt="images/1676-2.png" /></a><br /><br />Here&#39;s the trampoline space. You can see:<br />• MessageBoxA&#39;s prologue code<br />• a jump to to MessageBoxA + 5 - <code>jmp 7622E95</code><br />• and a jump to the hooked function - <code>jmp _hook_MessageBoxA</code><br /><a href=""><img src="images/1676-3.png" alt="images/1676-3.png" /></a><br /><br />And here&#39;s MessageBoxA after it&#39;s been hooked.<br />You can see we&#39;ve overwritten the first 5 bytes with a jump to trampoline + 10 at <code>0x0083000A</code>.<br /><a href=""><img src="images/1676-4.png" alt="images/1676-4.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br />Here&#39;s my demo code of inline hooking MessageBoxA.<br />The code is well commented, so hopefully it shouldn&#39;t need any extra explanation.<br /><br />NOTE:<br />• NO ATOMIC OPERATIONS<br />• NO DISASSEMBLER USED<br />   ◇ So installed hooks might have junk bytes at the end and thus might not work<br /><br />I&#39;ve done this so the code is kept simple.<br /><br /><div class="codebox"><div class="codebox">/*<br />x86&nbsp;inline&nbsp;hooking&nbsp;using&nbsp;E9&nbsp;relative&nbsp;jumps.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;hook_size&nbsp;=&nbsp;5;<br />int&nbsp;trampoline_size&nbsp;=&nbsp;15;<br /><br />int(__stdcall*&nbsp;orig_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hook_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxA&nbsp;intercepted!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;text:&nbsp;%s&nbsp;\n\t&nbsp;caption:&nbsp;%s&nbsp;\n\t&nbsp;type:&nbsp;%d&nbsp;\n&quot;,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br /><br />	return&nbsp;orig_MessageBoxA(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />/*<br />Hook&nbsp;a&nbsp;function.<br />Parameters:<br />	char*&nbsp;function&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;function&nbsp;to&nbsp;hook<br />	char*&nbsp;dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;DLL&nbsp;where&nbsp;the&nbsp;function&nbsp;resides<br />	void*&nbsp;detour&nbsp;&nbsp;&nbsp;-&nbsp;the&nbsp;function&nbsp;to&nbsp;detour&nbsp;to<br />	void**&nbsp;p_orig&nbsp;&nbsp;-&nbsp;address&nbsp;of&nbsp;the&nbsp;pointer&nbsp;to&nbsp;the&nbsp;original&nbsp;function<br />*/<br />BOOL&nbsp;hook(char*&nbsp;function,&nbsp;char*&nbsp;dll,&nbsp;void*&nbsp;detour,&nbsp;void**&nbsp;p_orig)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	<br />	//&nbsp;Grab&nbsp;address&nbsp;of&nbsp;target&nbsp;function&nbsp;and&nbsp;allocate&nbsp;trampoline&nbsp;space<br />	void*&nbsp;orig_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(dll),&nbsp;function);<br />	void*&nbsp;trampoline&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;trampoline_size,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	<br />	/*<br />	Calculate&nbsp;E9&nbsp;relative&nbsp;jumps.<br />	Formula&nbsp;is:&nbsp;(target&nbsp;-&nbsp;current_addr)<br />	*/<br />	DWORD&nbsp;jmp_originalfunction&nbsp;=&nbsp;(DWORD)orig_func&nbsp;-&nbsp;((DWORD)trampoline&nbsp;+&nbsp;5);<br />	DWORD&nbsp;jmp_hook&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(DWORD)detour&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;((DWORD)trampoline&nbsp;+&nbsp;15);<br />	DWORD&nbsp;jmp_trampoline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;((DWORD)trampoline&nbsp;+&nbsp;10)&nbsp;-&nbsp;((DWORD)orig_func&nbsp;+&nbsp;5);<br />	<br />	/*<br />	Construct&nbsp;trampoline.&nbsp;<br />	Structure&nbsp;should&nbsp;be:<br />	0		8B&nbsp;FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edi,edi	;&nbsp;Prologue&nbsp;of&nbsp;original&nbsp;function<br />	2		55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ebp<br />	3		8B&nbsp;EC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ebp,esp<br />	5		E9&nbsp;5B&nbsp;ED&nbsp;54&nbsp;76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7782ED65	;&nbsp;Relative&nbsp;jump&nbsp;to&nbsp;original&nbsp;function<br />	A		E9&nbsp;25&nbsp;13&nbsp;11&nbsp;FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;003f1334	;&nbsp;Relative&nbsp;jump&nbsp;to&nbsp;hook&nbsp;code<br />	*/<br />	memcpy_s((BYTE*)trampoline,&nbsp;5,&nbsp;orig_func,&nbsp;5);<br />	*(BYTE*)((DWORD)trampoline&nbsp;&nbsp;+&nbsp;5)&nbsp;&nbsp;=&nbsp;0xE9;<br />	*(DWORD*)((DWORD)trampoline&nbsp;+&nbsp;6)&nbsp;&nbsp;=&nbsp;jmp_originalfunction;<br />	*(BYTE*)((DWORD)trampoline&nbsp;&nbsp;+&nbsp;10)&nbsp;=&nbsp;0xE9;<br />	*(DWORD*)((DWORD)trampoline&nbsp;+&nbsp;11)&nbsp;=&nbsp;jmp_hook;<br /><br />	//&nbsp;Install&nbsp;hook&nbsp;at&nbsp;function<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	VirtualProtect(orig_func,&nbsp;hook_size,&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />	<br />	*(BYTE*)orig_func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0xE9;<br />	*(DWORD*)((DWORD)orig_func&nbsp;+&nbsp;1)&nbsp;=&nbsp;jmp_trampoline;<br /><br />	VirtualProtect(orig_func,&nbsp;hook_size,&nbsp;old_protect,&nbsp;&amp;old_protect);<br /><br />	/*<br />	Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;trampoline.<br />	When&nbsp;orig_Function()&nbsp;is&nbsp;called,&nbsp;it&nbsp;will&nbsp;execute&nbsp;the&nbsp;prologue&nbsp;@&nbsp;trampoline<br />	and&nbsp;follow&nbsp;the&nbsp;jump&nbsp;to&nbsp;the&nbsp;original&nbsp;hooked&nbsp;function.<br />	*/<br />	*p_orig&nbsp;=&nbsp;trampoline;<br />	<br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;orig_func,&nbsp;hook_size);<br />	return&nbsp;ok;<br />}<br /><br />/*<br />Unhook&nbsp;a&nbsp;function.<br />Parameters:<br />	char*&nbsp;function&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;function&nbsp;to&nbsp;unhook<br />	char*&nbsp;dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;DLL&nbsp;where&nbsp;the&nbsp;function&nbsp;resides<br />	void*&nbsp;trampoline&nbsp;&nbsp;-&nbsp;pointer&nbsp;to&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;trampoline&nbsp;space<br />*/<br />BOOL&nbsp;unhook(char*&nbsp;function,&nbsp;char*&nbsp;dll,&nbsp;void*&nbsp;trampoline)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;FALSE;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	/*<br />	Grab&nbsp;address&nbsp;of&nbsp;original&nbsp;function,<br />	make&nbsp;it&nbsp;writable,<br />	and&nbsp;restore&nbsp;its&nbsp;first&nbsp;5&nbsp;bytes&nbsp;by&nbsp;copying&nbsp;them&nbsp;from&nbsp;the&nbsp;trampoline&nbsp;space.<br />	*/<br />	void*&nbsp;orig_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(dll),&nbsp;function);<br />	VirtualProtect(orig_func,&nbsp;hook_size,&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />	memcpy_s(orig_func,&nbsp;hook_size,&nbsp;trampoline,&nbsp;5);<br />	VirtualProtect(orig_func,&nbsp;hook_size,&nbsp;old_protect,&nbsp;&amp;old_protect);<br /><br />	/*<br />	Free&nbsp;trampoline&nbsp;space<br />	and&nbsp;flush&nbsp;instruction&nbsp;cache&nbsp;at&nbsp;original&nbsp;function.<br />	*/<br />	VirtualFree(trampoline,&nbsp;0,&nbsp;MEM_RELEASE);<br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;orig_func,&nbsp;hook_size);<br />	<br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;I&nbsp;think&nbsp;I&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;Hmm...&quot;,&nbsp;MB_OK);<br />	<br />	hook(&quot;MessageBoxA&quot;,&nbsp;&quot;User32.dll&quot;,&nbsp;&amp;hook_MessageBoxA,&nbsp;(void*)&amp;orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&quot;,&nbsp;&quot;Hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&nbsp;good&nbsp;sir!&quot;,&nbsp;&quot;Hi&nbsp;#2&quot;,&nbsp;MB_OK);<br />	<br />	unhook(&quot;MessageBoxA&quot;,&nbsp;&quot;User32.dll&quot;,&nbsp;(void*)orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;Did&nbsp;he&nbsp;hear&nbsp;me&nbsp;ok?&quot;,&nbsp;&quot;Hmm...&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /></div>
</body>
</html>
