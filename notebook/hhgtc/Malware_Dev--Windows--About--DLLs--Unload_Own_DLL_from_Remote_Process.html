<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Unload Own DLL from Remote Process</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Unload Own DLL from Remote Process</h1></strong><br />Examples:<br />• <a href="https://www.unknowncheats.me/forum/642469-post15.html?s=fa31e5071751a1ddebd753bf91a3aa8c">https://www.unknowncheats.me/forum/642469-post15.html?s=fa31e5071751a1ddebd753bf91a3aa8c</a><br />• <a href="https://github.com/headmax/Cplus/blob/master/Projet4/Main.cpp">https://github.com/headmax/Cplus/blob/master/Projet4/Main.cpp</a><br /><br />I&#39;ve mainly seen this used in game cheats but it&#39;s useful for other programs too.<br /><br />Upon DLL attachment, you create a thread to watch for a user-request to unload the DLL.<br />For example, here the DLL watches for the DELETE key to be pressed every 1 second.<br />Calling FreeLibrary and ExitThread separately can cause a race condition, so you use <code>FreeLibraryAndExitThread</code> instead.<br /><div class="codebox"><div class="codebox">void&nbsp;WatchForUnload(HINSTANCE&nbsp;hinstDLL)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Infinite&nbsp;loop&nbsp;to&nbsp;check&nbsp;for&nbsp;unload&nbsp;request&nbsp;by&nbsp;user<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GetAsyncKeyState(VK_DELETE)&nbsp;&amp;&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;[!]&nbsp;UNLOAD&nbsp;request!&nbsp;\n&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Tell&nbsp;threads&nbsp;to&nbsp;stop&nbsp;running<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bRunThreads&nbsp;=&nbsp;FALSE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Wait&nbsp;5&nbsp;seconds&nbsp;for&nbsp;threads&nbsp;to&nbsp;exit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\t&nbsp;*&nbsp;waiting&nbsp;5&nbsp;seconds&nbsp;for&nbsp;threads&nbsp;to&nbsp;exit&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(5000);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Unload&nbsp;this&nbsp;library&nbsp;and&nbsp;exit&nbsp;this&nbsp;thread<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\t&nbsp;*&nbsp;FreeLibraryAndExitThread&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FreeLibraryAndExitThread(hinstDLL,&nbsp;0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(1000);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />A crucial part to this code is the <code>bRunThreads</code> variable, which is global.<br />This variable is used to terminate the rest of the threads your DLL has created.<br /><br />You can package your main execution loop inside of a while loop<br /><div class="codebox"><div class="codebox">void&nbsp;MainThread(HINSTANCE&nbsp;hinstDLL)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(bRunThreads&nbsp;==&nbsp;TRUE)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;this&nbsp;is&nbsp;the&nbsp;bulk&nbsp;of&nbsp;my&nbsp;program&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(2000);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;MainThread&nbsp;exiting...&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;ExitThread(0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Or if there isn&#39;t any main execution loop (like if you&#39;re installing hooks, there&#39;s no execution loop because the hooks do all the work) you can &quot;pause&quot; execution of your function using the <code>bRunThreads</code> variable before you clean up your funciton and exit.<br />e.g.<br /><div class="codebox"><div class="codebox">void&nbsp;MainThread(HINSTANCE&nbsp;hinstDLL)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;INSTALL&nbsp;HOOKS<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(bRunThreads&nbsp;==&nbsp;TRUE)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(1000);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;REMOVE&nbsp;HOOKS<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;MainThread&nbsp;exiting...&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;ExitThread(0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Example</h2></strong><br />Both the .exe and .dll are compiled as x86.<br />Demo is running on Windows 10 2004 x64.<br /><br /><strong><h3>### EmptyProgram.exe</h3></strong><br />Here&#39;s my empty program to test for unloading of the DLL.<br />It loads the test DLL and prints <code>main</code> in an infinite loop. After the DLL has unloaded itself, <code>main</code> should continue to print.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	HMODULE&nbsp;dll&nbsp;=&nbsp;NULL;<br />	dll&nbsp;=&nbsp;LoadLibraryA(&quot;C:\\Users\\bob\\source\\example_code\\DLLs\\unloadme\\Debug\\unloadme.dll&quot;);<br />	if&nbsp;(dll)<br />		printf(&quot;[+]&nbsp;library&nbsp;loaded&nbsp;\n&quot;);<br /><br />	while&nbsp;(1)<br />	{<br />		printf(&quot;main&nbsp;\n&quot;);<br />		Sleep(1500);<br />	}<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### unloadme.dll</h3></strong><br />This is my DLL that unloads itself.<br />Upon attach it creates a thread for the <code>MainThread</code> function.<br />The MainThread function then creates a thread to watch for the unload request (the DELETE key being pressed) and then executes its main loop (printing &quot;dll&quot; every 2 seconds).<br /><br />When the DELETE key is pressed, <code>bRunThreads</code> will be set to FALSE which will cause MainThread to stop executing while loop and move to exiting.<br /><br /><code>WatchForUnload</code> will sleep for 5 seconds to give a chance for the threads in the DLL to see that bRunThreads is set to FALSE, and then free and exit itself.<br /><br /><div class="codebox"><div class="codebox">/*<br />A&nbsp;DLL&nbsp;to&nbsp;be&nbsp;injected&nbsp;into&nbsp;a&nbsp;target&nbsp;process&nbsp;and&nbsp;then&nbsp;be&nbsp;unloaded&nbsp;from&nbsp;within&nbsp;the&nbsp;target&nbsp;process&nbsp;upon&nbsp;user&#39;s&nbsp;choice.<br />*/<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />BOOL&nbsp;bRunThreads&nbsp;=&nbsp;TRUE;&nbsp;&nbsp;&nbsp;//&nbsp;used&nbsp;to&nbsp;terminate&nbsp;threads<br />void&nbsp;MainThread(HINSTANCE&nbsp;hinstDLL);<br />void&nbsp;WatchForUnload(HINSTANCE&nbsp;hinstDLL);<br /><br />void&nbsp;MainThread(HINSTANCE&nbsp;hinstDLL)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Disable&nbsp;DLL_THREAD_ATTACH/DETACH&nbsp;notifications<br />&nbsp;&nbsp;&nbsp;&nbsp;DisableThreadLibraryCalls(hinstDLL);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;thread&nbsp;to&nbsp;watch&nbsp;for&nbsp;unload&nbsp;request<br />&nbsp;&nbsp;&nbsp;&nbsp;CreateThread(NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)WatchForUnload,&nbsp;hinstDLL,&nbsp;0,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(bRunThreads&nbsp;==&nbsp;TRUE)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;dll&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(2000);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;MainThread&nbsp;exiting...&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;ExitThread(0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />void&nbsp;WatchForUnload(HINSTANCE&nbsp;hinstDLL)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Infinite&nbsp;loop&nbsp;to&nbsp;check&nbsp;for&nbsp;unload&nbsp;request&nbsp;by&nbsp;user<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GetAsyncKeyState(VK_DELETE)&nbsp;&amp;&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;[!]&nbsp;UNLOAD&nbsp;request!&nbsp;\n&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Tell&nbsp;threads&nbsp;to&nbsp;stop&nbsp;running<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bRunThreads&nbsp;=&nbsp;FALSE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Wait&nbsp;5&nbsp;seconds&nbsp;for&nbsp;threads&nbsp;to&nbsp;exit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\t&nbsp;*&nbsp;waiting&nbsp;5&nbsp;seconds&nbsp;for&nbsp;threads&nbsp;to&nbsp;exit&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(5000);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Unload&nbsp;this&nbsp;library&nbsp;and&nbsp;exit&nbsp;this&nbsp;thread<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\t&nbsp;*&nbsp;FreeLibraryAndExitThread&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FreeLibraryAndExitThread(hinstDLL,&nbsp;0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(1000);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(fdwReason)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateThread(NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)MainThread,&nbsp;hinstDLL,&nbsp;0,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Example #2 - All within 1 function</h2></strong><br />The example above creates 1 thread that executes the program, and 1 thread that watches for unload.<br />You could just do this all within 1 function to keep it simple.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />void&nbsp;MainThread(HINSTANCE&nbsp;hinstDLL)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;DisableThreadLibraryCalls(hinstDLL);<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Install&nbsp;hooks<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Press&nbsp;END&nbsp;to&nbsp;unload&nbsp;DLL<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!GetAsyncKeyState(VK_END))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Main&nbsp;bulk&nbsp;of&nbsp;program<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Remove&nbsp;hooks<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Unload&nbsp;this&nbsp;DLL&nbsp;and&nbsp;exit<br />&nbsp;&nbsp;&nbsp;&nbsp;FreeLibraryAndExitThread(hinstDLL,&nbsp;0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(fdwReason)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateThread(NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)MainThread,&nbsp;hinstDLL,&nbsp;0,&nbsp;NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
