<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>64bit How-to</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># How-to on 64bit Windows</h1></strong><br />â€¢ <a href="https://www.ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs">https://www.ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs</a><br /><br />To execute syscalls ourself we just need to write the assembly code found in Ntdll.dll and link a typedef of the corresponding Nt function to it.<br /><br /><strong><h2>## Set up MASM to compile x64 assembly</h2></strong><br />Visual Studio doesn&#39;t support inline assembly for 64bit binaries, so all assembly code has to go in a separate file.<br /><br />Add a new source file call <code>syscalls.asm</code> (the name can be anything.asm)<br /><a href=""><img src="images/1719-1.png" alt="images/1719-1.png" /></a><br /><br />Right click on your project in the Solution Explorer &gt; Build Dependencies &gt; Build Customizations:<br /><a href=""><img src="images/1719-2.png" alt="images/1719-2.png" /></a><br /><br />Enable <code>masm</code> to compile the x64 assembly code.<br /><a href=""><img src="images/1719-3.png" alt="images/1719-3.png" /></a><br /><br />Right click on your <code>syscalls.asm</code> file &gt; Properties<br /><a href=""><img src="images/1719-4.png" alt="images/1719-4.png" /></a><br /><br />Set the item type to <code>Microsoft Macro Assembler</code><br /><a href=""><img src="images/1719-5.png" alt="images/1719-5.png" /></a><br /><br />Done!<br />Now all 64bit assembly code written in <code>syscalls.asm</code> will be compiled by MASM.<br /><br /><strong><h2>## Example Code - syscall NtQueryInformationProcess</h2></strong><br />In this demo I&#39;m calling <code>NtQueryInformationProcess</code> to grab the PEB base address of a target process.<br /><br />Here&#39;s how my project looks:<br /><a href=""><img src="images/1719-6.png" alt="images/1719-6.png" /></a><br /><br /><strong>syscalls.asm</strong><br />Here&#39;s my <code>syscalls.asm</code> file.<br />In here I&#39;ve written the assembly code to syscall <code>NtQueryInformationProcess</code><br /><div class="codebox"><div class="codebox">.code<br />	syscall_NtQueryInformationProcess&nbsp;proc<br />		mov&nbsp;r10,&nbsp;rcx<br />		mov&nbsp;eax,&nbsp;19h<br />		syscall<br />		ret<br />	syscall_NtQueryInformationProcess&nbsp;endp<br />end</div></div><br /><br /><strong>main.c</strong><br />And here is my main program code.<br /><br />At the top I have decalred an <code>extern</code> <code>syscall_NtQueryInformationProcess</code> function.<br /><code>extern</code> tells the compiler that the definition of the function (the actual code) exists somewhere else within my program (in syscall.asm).<br /><br />Below that is all preamble that sets up the parameters for calling NtQueryInformationProcess.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />extern&nbsp;__kernel_entry&nbsp;NTSTATUS&nbsp;syscall_NtQueryInformationProcess(<br />	HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />	PROCESSINFOCLASS&nbsp;ProcessInformationClass,<br />	PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformation,<br />	ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformationLength,<br />	PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength<br />);<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	if&nbsp;(argc&nbsp;!=&nbsp;2)<br />	{<br />		printf(&quot;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;%s&nbsp;&lt;process&nbsp;ID&gt;&nbsp;\n&quot;,&nbsp;argv[0]);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />	<br />	int&nbsp;process_id&nbsp;=&nbsp;atoi(argv[1]);<br />	HANDLE&nbsp;h_process&nbsp;=&nbsp;NULL;<br />	PROCESS_BASIC_INFORMATION&nbsp;pbi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	h_process&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;process_id);<br />	syscall_NtQueryInformationProcess(h_process,&nbsp;ProcessBasicInformation,&nbsp;&amp;pbi,&nbsp;sizeof(pbi),&nbsp;NULL);<br /><br />	printf(&quot;[+]&nbsp;PEB&nbsp;base&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pbi.PebBaseAddress);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### Demo</h3></strong><br />Here I&#39;ve queried Notepad.exe, which has a PID of 22604, for its PEB base address.<br />We can see that our code has syscalled <code>NtQueryInformationProcess</code> successfully and grabbed the correct PEB base address.<br /><a href=""><img src="images/1719-7.png" alt="images/1719-7.png" /></a></div>
</body>
</html>
