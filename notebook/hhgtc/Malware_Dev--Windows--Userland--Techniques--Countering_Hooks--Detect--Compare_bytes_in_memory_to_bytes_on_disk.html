<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Compare bytes in memory to bytes on disk</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Compare Bytes in Memory to Bytes on Disk</h1></strong><br />You could read the function&#39;s bytes in the DLL on disk and compare them to function&#39;s bytes in memory.<br />If the bytes are different, you can declare the function as hooked.<br /><br />This has 2 problems:<br />• it relies on the DLL on disk being correct <br />   ◇ What if an attacker modifies your DLL to contain the hook bytes? This requires Admin privileges, but still<br />• Addresses in <code>mov</code>, <code>cmp</code>, etc. instructions can be different on disk vs memory<br />   ◇ e.g. <code>mov edx, 69EA219Ch</code> on disk vs. <code>mov edx, 76A4219Ch</code> in memory<br />   ◇ therefore you have to be careful with how many bytes you choose to compare<br />   ◇ e.g. compare the <code>mov edx</code> byte - <code>BA</code> - and not the address<br /><br />Despite these issues, I think it&#39;s still an effective method.<br /><br /><strong><h2>## Code</h2></strong><br />Compiled as x86 Debug on Windows 10 x64 2004.<br /><br /><a href=""><img src="images/1701-1.png" alt="images/1701-1.png" /></a><br /><br /><a href=""><img src="images/1701-2.png" alt="images/1701-2.png" /></a><br /><br />The code is well commented so it should hopefully explain itself.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;Psapi.h&gt;<br />#include&nbsp;&lt;shlwapi.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Shlwapi.lib&quot;)<br /><br />#define&nbsp;N_BYTES_TO_COMPARE&nbsp;5		//&nbsp;you&nbsp;can&nbsp;run&nbsp;into&nbsp;problems&nbsp;if&nbsp;comparing&nbsp;more&nbsp;bytes&nbsp;(because&nbsp;mov/cmp&nbsp;addresses&nbsp;in&nbsp;disk&nbsp;vs.&nbsp;memory&nbsp;chanage)<br /><br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Loops&nbsp;through&nbsp;the&nbsp;export&nbsp;table&nbsp;and&nbsp;returns&nbsp;the&nbsp;raw&nbsp;address&nbsp;of&nbsp;the&nbsp;requested&nbsp;function.<br />*/<br />SIZE_T&nbsp;FindRawExportAddress(LPVOID&nbsp;file_buffer,&nbsp;char*&nbsp;target_function)<br />{<br />	SIZE_T&nbsp;export_addr&nbsp;=&nbsp;0;<br />	<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_directory&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;name_pointer_table&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;ordinal_table&nbsp;=&nbsp;NULL;<br />	<br />	DWORD*&nbsp;export_address_table&nbsp;=&nbsp;NULL;<br />	char*&nbsp;exported_function_name&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;exported_function_address&nbsp;=&nbsp;0;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />	export_directory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress));<br />	<br />	export_address_table&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;export_directory-&gt;AddressOfFunctions));<br />	name_pointer_table&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;export_directory-&gt;AddressOfNames));<br />	ordinal_table&nbsp;=&nbsp;(WORD*)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;export_directory-&gt;AddressOfNameOrdinals));<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;exports<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;export_directory-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		//&nbsp;Grab&nbsp;function&nbsp;name&nbsp;&amp;&nbsp;address<br />		exported_function_name&nbsp;=&nbsp;(char*)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;name_pointer_table[i]));<br />		exported_function_address&nbsp;=&nbsp;export_address_table[ordinal_table[i]];<br /><br />		if&nbsp;(strcmp(exported_function_name,&nbsp;target_function)&nbsp;==&nbsp;0)<br />		{<br />			export_addr&nbsp;=&nbsp;(SIZE_T)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;exported_function_address);<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;export_addr;<br />}<br /><br />/*<br />Compares&nbsp;the&nbsp;the&nbsp;function&#39;s&nbsp;bytes&nbsp;in&nbsp;memory&nbsp;with&nbsp;those&nbsp;in&nbsp;the&nbsp;DLL&nbsp;on&nbsp;disk.<br />If&nbsp;different,&nbsp;the&nbsp;function&nbsp;is&nbsp;hooked.<br />It&nbsp;DOES&nbsp;NOT&nbsp;check&nbsp;the&nbsp;function&#39;s&nbsp;hotpatch&nbsp;space.<br /><br />Restores&nbsp;hooks&nbsp;by&nbsp;replacing&nbsp;the&nbsp;hook&nbsp;bytes&nbsp;with&nbsp;the&nbsp;original&nbsp;bytes&nbsp;from&nbsp;the&nbsp;DLL&nbsp;on&nbsp;disk.<br /><br />Parameters:<br />	-&nbsp;target_dll_name&nbsp;-&nbsp;Name&nbsp;of&nbsp;DLL&nbsp;in&nbsp;which&nbsp;function&nbsp;resides&nbsp;(User32.dll)<br />	-&nbsp;function_name&nbsp;-&nbsp;the&nbsp;function&nbsp;to&nbsp;check&nbsp;(MessageBoxA)<br />	-&nbsp;restore&nbsp;-&nbsp;set&nbsp;to&nbsp;TRUE&nbsp;to&nbsp;restore&nbsp;the&nbsp;original&nbsp;bytes<br />*/<br />BOOL&nbsp;IsFunctionHooked(char*&nbsp;target_dll_name,&nbsp;char*&nbsp;function_name,&nbsp;BOOL&nbsp;restore)<br />{<br />	BOOL&nbsp;hooked&nbsp;=&nbsp;FALSE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	<br />	BOOL&nbsp;dll_loaded&nbsp;=&nbsp;FALSE;<br />	HMODULE&nbsp;loaded_dlls[64]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	DWORD&nbsp;bytes_needed&nbsp;=&nbsp;0;<br />	unsigned&nbsp;int&nbsp;i&nbsp;=&nbsp;0;<br /><br />	char&nbsp;loaded_dll_name[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	char&nbsp;target_dll_path[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	LPVOID&nbsp;func_addr_mem&nbsp;=&nbsp;NULL;<br />	SIZE_T&nbsp;func_addr_raw&nbsp;=&nbsp;0;<br /><br />	char&nbsp;disk_bytes[N_BYTES_TO_COMPARE]&nbsp;=&nbsp;{&nbsp;0&nbsp;};		//&nbsp;stores&nbsp;bytes&nbsp;@&nbsp;function&nbsp;in&nbsp;DLL<br />	char&nbsp;mem_bytes[N_BYTES_TO_COMPARE]&nbsp;=&nbsp;{&nbsp;0&nbsp;};			//&nbsp;stores&nbsp;bytes&nbsp;@&nbsp;function&nbsp;that&#39;s&nbsp;currently&nbsp;in&nbsp;memory<br /><br />	LPVOID&nbsp;dll_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;dll_buf_size&nbsp;=&nbsp;0;<br /><br />	int&nbsp;differences&nbsp;=&nbsp;0;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	printf(&quot;[*]&nbsp;Checking&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />#ifdef&nbsp;_WIN64<br />		sprintf_s(target_dll_path,&nbsp;MAX_PATH,&nbsp;&quot;C:\\Windows\\System32\\%s&quot;,&nbsp;target_dll_name);<br />#else<br />		sprintf_s(target_dll_path,&nbsp;MAX_PATH,&nbsp;&quot;C:\\Windows\\SysWOW64\\%s&quot;,&nbsp;target_dll_name);<br />#endif<br />	<br />	//&nbsp;Check&nbsp;if&nbsp;DLL&nbsp;is&nbsp;loaded&nbsp;into&nbsp;process.&nbsp;Grab&nbsp;address&nbsp;of&nbsp;target&nbsp;function&nbsp;if&nbsp;so<br />	EnumProcessModules(GetCurrentProcess(),&nbsp;loaded_dlls,&nbsp;sizeof(loaded_dlls),&nbsp;&amp;bytes_needed);<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;(bytes_needed&nbsp;/&nbsp;sizeof(HMODULE));&nbsp;i++)<br />	{<br />		GetModuleFileNameA(loaded_dlls[i],&nbsp;loaded_dll_name,&nbsp;MAX_PATH);<br />		PathStripPathA(loaded_dll_name);<br />		if&nbsp;(_stricmp(loaded_dll_name,&nbsp;target_dll_name)&nbsp;==&nbsp;0)<br />		{<br />			dll_loaded&nbsp;=&nbsp;TRUE;<br />			func_addr_mem&nbsp;=&nbsp;GetProcAddress(loaded_dlls[i],&nbsp;function_name);<br />			break;<br />		}<br />	}<br /><br />	if&nbsp;(dll_loaded&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;-&nbsp;function&nbsp;not&nbsp;present&nbsp;in&nbsp;binary&nbsp;\n&quot;);<br />		hooked&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Read&nbsp;DLL&nbsp;from&nbsp;disk&nbsp;into&nbsp;buffer&nbsp;and&nbsp;find&nbsp;address&nbsp;of&nbsp;target&nbsp;function<br />	dll_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(target_dll_path,&nbsp;&amp;dll_buf_size);<br />	if&nbsp;(dll_buffer&nbsp;==&nbsp;NULL)<br />	{<br />		hooked&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	func_addr_raw&nbsp;=&nbsp;FindRawExportAddress(dll_buffer,&nbsp;function_name);<br /><br />	//&nbsp;Read&nbsp;first&nbsp;N&nbsp;bytes&nbsp;from&nbsp;function&nbsp;on&nbsp;disk&nbsp;(in&nbsp;DLL)<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N_BYTES_TO_COMPARE;&nbsp;i++)<br />		memcpy_s((BYTE*)disk_bytes&nbsp;+&nbsp;i,&nbsp;1,&nbsp;(BYTE*)func_addr_raw&nbsp;+&nbsp;i,&nbsp;1);<br /><br />	printf(&quot;\t&nbsp;disk_bytes:&nbsp;&quot;);<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N_BYTES_TO_COMPARE;&nbsp;i++)<br />		printf(&quot;%02hhX&nbsp;&quot;,&nbsp;disk_bytes[i]);<br />	printf(&quot;\n&quot;);<br /><br />	//&nbsp;Read&nbsp;first&nbsp;N&nbsp;bytes&nbsp;from&nbsp;function&nbsp;in&nbsp;memory&nbsp;<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N_BYTES_TO_COMPARE;&nbsp;i++)<br />		memcpy_s((BYTE*)mem_bytes&nbsp;+&nbsp;i,&nbsp;1,&nbsp;(BYTE*)func_addr_mem&nbsp;+&nbsp;i,&nbsp;1);<br /><br />	printf(&quot;\t&nbsp;mem_bytes:&nbsp;&quot;);<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N_BYTES_TO_COMPARE;&nbsp;i++)<br />		printf(&quot;%02hhX&nbsp;&quot;,&nbsp;mem_bytes[i]);<br />	printf(&quot;\n&quot;);<br /><br />	//&nbsp;Compare&nbsp;the&nbsp;two<br />	differences&nbsp;=&nbsp;memcmp(disk_bytes,&nbsp;mem_bytes,&nbsp;N_BYTES_TO_COMPARE);<br />	if&nbsp;(differences&nbsp;==&nbsp;0)<br />		printf(&quot;\t&nbsp;not&nbsp;hooked!&nbsp;\n&quot;);<br />	else&nbsp;if&nbsp;(differences&nbsp;!=&nbsp;0)<br />	{<br />		hooked&nbsp;=&nbsp;TRUE;<br />		printf(&quot;\t&nbsp;%s&nbsp;is&nbsp;hooked!&nbsp;\n&quot;,&nbsp;function_name);<br />		printf(&quot;\t&nbsp;Bytes&nbsp;in&nbsp;memory:&nbsp;&quot;);<br />		for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N_BYTES_TO_COMPARE;&nbsp;i++)<br />			printf(&quot;%02hhX&nbsp;&quot;,&nbsp;mem_bytes[i]);<br />		printf(&quot;\n&quot;);<br /><br />		if&nbsp;(restore&nbsp;==&nbsp;TRUE)<br />		{<br />			//&nbsp;Make&nbsp;memory&nbsp;@&nbsp;function&nbsp;writable,&nbsp;overwrite&nbsp;hook&nbsp;bytes&nbsp;with&nbsp;bytes&nbsp;from&nbsp;disk,&nbsp;and&nbsp;restore&nbsp;memory&nbsp;protection<br />			b_ret&nbsp;=&nbsp;VirtualProtect(func_addr_mem,&nbsp;N_BYTES_TO_COMPARE,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />			if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />				goto&nbsp;cleanup;<br />			<br />			memcpy_s(func_addr_mem,&nbsp;N_BYTES_TO_COMPARE,&nbsp;(LPVOID)func_addr_raw,&nbsp;N_BYTES_TO_COMPARE);		//&nbsp;this&nbsp;is&nbsp;non-atomic.&nbsp;could&nbsp;cause&nbsp;problems<br />			VirtualProtect(func_addr_mem,&nbsp;N_BYTES_TO_COMPARE,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />			<br />			//&nbsp;Verify&nbsp;that&nbsp;hook&nbsp;has&nbsp;been&nbsp;restored<br />			differences&nbsp;=&nbsp;memcmp(func_addr_mem,&nbsp;(LPVOID)func_addr_raw,&nbsp;N_BYTES_TO_COMPARE);<br />			if&nbsp;(differences&nbsp;==&nbsp;0)<br />				printf(&quot;\t&nbsp;function&nbsp;restored!&nbsp;\n&quot;);<br />			else<br />				printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;restore&nbsp;function&nbsp;:/&nbsp;\n&quot;);<br />		}<br />	}<br />	<br />cleanup:<br />	if&nbsp;(dll_buffer)&nbsp;free(dll_buffer);<br /><br />	return&nbsp;hooked;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	IsFunctionHooked(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;TRUE);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&nbsp;world!&quot;,&nbsp;&quot;!&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /></div>
</body>
</html>
