<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>CryptoAPI</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># CryptoAPI</h1></strong><br />Microsoft&#39;s CryptoAPI is crap to use.<br />There&#39;s so much stuff and so many acronyms and so few clear-cut answers.<br /><br /><strong>Links</strong><br />• <a href="https://www.drdobbs.com/encrypting-and-decrypting-data-with-the/184416394?pgno=1">https://www.drdobbs.com/encrypting-and-decrypting-data-with-the/184416394?pgno=1</a> - Good intro<br />• <a href="https://www.blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/research/cryptoapi-in-malware/">https://www.blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/research/cryptoapi-in-malware/</a><br />• <a href="https://github.com/wyrover/CryptoAPI-examples">https://github.com/wyrover/CryptoAPI-examples</a><br />• <a href="https://www.youtube.com/watch?v=5iCekhs4hMo">https://www.youtube.com/watch?v=5iCekhs4hMo</a> - Dumping a CryptoAPI Keygen<br />• <a href="https://www.youtube.com/watch?v=LpBlAr2jPM8">https://www.youtube.com/watch?v=LpBlAr2jPM8</a> - Reversing a CryptoAPI<br /><br /><strong>MSDN Links</strong><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/encrypting-and-decrypting">https://docs.microsoft.com/en-us/windows/win32/seccrypto/encrypting-and-decrypting</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-setting-and-getting-session-key-parameters">https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-setting-and-getting-session-key-parameters</a><br />• <a href="https://docs.microsoft.com/en-gb/windows/win32/seccrypto/example-c-program-encrypting-a-file?redirectedfrom=MSDN">https://docs.microsoft.com/en-gb/windows/win32/seccrypto/example-c-program-encrypting-a-file?redirectedfrom=MSDN</a> - Crypting files<br /><br /><strong><h2>## About the Windows CryptoAPI</h2></strong><br />• <a href="https://www.drdobbs.com/encrypting-and-decrypting-data-with-the/184416394?pgno=1">https://www.drdobbs.com/encrypting-and-decrypting-data-with-the/184416394?pgno=1</a> - Good intro<br /><br /><strong><h3>### Cryptographic Service Providers (CSPs) and Provider Types</h3></strong><br />Microsoft offer a series of CSPs - Cryptographic Service Providers.<br />Each provider offersa provider type.<br />Each provider type offers different key exchange/signature/encryption/hashing functionality.<br /><br />Cryptographic Service Providers:<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/microsoft-cryptographic-service-providers">https://docs.microsoft.com/en-us/windows/win32/seccrypto/microsoft-cryptographic-service-providers</a><br />Provider types:<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types">https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types</a><br /><br />FOR EXAMPLE:<br />The <code>MS_DEF_PROV</code> CSP<br /><a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/microsoft-base-cryptographic-provider">https://docs.microsoft.com/en-us/windows/win32/seccrypto/microsoft-base-cryptographic-provider</a><br />offers the provider type <code>PROV_RSA_FULL</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/prov-rsa-full">https://docs.microsoft.com/en-us/windows/win32/seccrypto/prov-rsa-full</a><br /><code>PROV_RSA_FULL</code> supports:<br />• Key Exchange - RSA<br />• Signature - RSA<br />• Encryption - RC2, RC4<br />• Hashing - MD5, SHA<br /><br />The <code>MS_ENH_RSA_AES_PROV</code> CSP <br /><a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/microsoft-aes-cryptographic-provider">https://docs.microsoft.com/en-us/windows/win32/seccrypto/microsoft-aes-cryptographic-provider</a><br />offers the provider type <code>PROV_RSA_AES</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/prov-rsa-aes">https://docs.microsoft.com/en-us/windows/win32/seccrypto/prov-rsa-aes</a><br /><code>PROV_RSA_AES</code> supports:<br />• Key Exchange - RSA<br />• Signature - RSA<br />• Encryption - RC2, RC4, AES<br />• Hashing - MD2, MD4, MD5, SHA-1, SHA-2 (SHA-256, SHA-384, and SHA-512)<br /><br />You choose the CSP and provider type based on what encryption/hashing etc. that you want to do.<br />To choose a CSP and Provider Type, you use <code>CryptAcquireContext</code><br /><br /><strong>How the CSPs are Implemented</strong><br />The CSPs are implemented as a series of DLLs that export functions for encryption, decryption, key generation, and key storage.<br />Each CSP provides a key database used to store keys.<br />Each user has a key container. This key container gets used by applications.<br />Applications can also create their own key containers.<br />Each user has 2 public/private key pairs:<br />• one for encrypting session keys (key exchange pair)<br />• one for creating digital signatures (signature pair)<br /><br /><strong><h2>## About Crypto (in general)</h2></strong><br /><strong><h3>### Block Cipher vs Stream Cipher</h3></strong><br /><strong>#### Stream Ciphers</strong><br />Stream ciphers are ciphers which encrypt 1 byte at a time.<br />Examples:<br />• RC4<br />• Salsa20<br />• XOR<br />• etc.<br /><a href="https://en.wikipedia.org/wiki/Category:Stream_ciphers">https://en.wikipedia.org/wiki/Category:Stream_ciphers</a><br /><br />When encrypting using a stream cipher, the size of the encrypted text will be the same as the plaintext,<br /><br /><strong>#### Block Ciphers (and padding)</strong><br />Block Ciphers encrypt data in blocks, which means that it encrypts data in chunks and encrypts each chunk individually.<br /><br />The most common block cipher is AES.<br />In AES, the block size is 128 bits. <br />If the data you&#39;re encrypting doesn&#39;t reach 128bits, padding will be added to the end of the block to reach the required block size. This means the encrypted data is almost always larger than the original plaintext.<br /><br />The Windows CryptoAPI handles padding for you automatically.<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/secgloss/p-gly">https://docs.microsoft.com/en-us/windows/win32/secgloss/p-gly</a> (search for &quot;padding&quot;)<br />(I have no idea what padding mode it uses)<br />YOU JUST HAVE TO MAKE SURE THERE&#39;S ENOUGH ROOM IN YOUR ENCRYPTION BUFFER for padding to be added.<br />To do this, you can call <code>CryptEncrypt</code> with <code>pbData</code> set to NULL to &quot;calculate the required size for the ciphertext&quot;. You can then resize or allocate a new buffer that will fit the ciphertext<br /><br /><div class="codebox"><div class="codebox">/*&nbsp;<br />Run&nbsp;CryptEncrypt&nbsp;once&nbsp;to&nbsp;grab&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;encrypted&nbsp;data.<br />On&nbsp;input,&nbsp;bytes_required&nbsp;provides&nbsp;the&nbsp;plaintext&nbsp;data&nbsp;length<br />On&nbsp;ouptut,&nbsp;it&nbsp;stores&nbsp;the&nbsp;ciphertext&nbsp;length<br />*/<br />bytes_required&nbsp;=&nbsp;plaintext_len;<br />b&nbsp;=&nbsp;CryptEncrypt(key,&nbsp;0,&nbsp;TRUE,&nbsp;0,&nbsp;NULL,&nbsp;&amp;bytes_required,&nbsp;0);<br />if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />{<br />	printf(&quot;-&nbsp;Failed&nbsp;to&nbsp;grab&nbsp;length&nbsp;of&nbsp;encrypted&nbsp;text:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	i&nbsp;=&nbsp;1;<br />	goto&nbsp;cleanup;<br />}<br /><br />//&nbsp;Allocate&nbsp;memory&nbsp;buffer&nbsp;to&nbsp;store&nbsp;encrypted&nbsp;data<br />buffer&nbsp;=&nbsp;malloc(bytes_required);<br /><br />//&nbsp;Call&nbsp;CryptEncrypt&nbsp;agian&nbsp;to&nbsp;ecnrypt&nbsp;data</div></div><br /><br />More info on padding &amp; what to choose (if you have the choice)<br />• <a href="https://stackoverflow.com/questions/13572253/what-kind-of-padding-should-aes-use">https://stackoverflow.com/questions/13572253/what-kind-of-padding-should-aes-use</a><br />• PCKS#5 padding pads to 8 byte blocks (64 bits)<br />• PKCS#7 padding pads to 16 byte blocks (128 bits)<br /><br /><strong><h3>### Cipher Mode</h3></strong><br />I&#39;m pretty sure cipher mode is only relevant in reference to block ciphers<br />(DON&#39;T KNOW THOUGH)<br /><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptsetkeyparam">https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptsetkeyparam</a><br />The default mode set by the Microsoft Base Cryptographic Provider is <code>CRYPT_MODE_CBC</code><br />You probably won&#39;t need to use any other mode than what&#39;s default.<br /><br />If you do, what cipher mode do you choose?<br />• <a href="https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb?rq=1">https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb?rq=1</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/secgloss/c-gly">https://docs.microsoft.com/en-us/windows/win32/secgloss/c-gly</a> (search for &quot;cipher mode&quot;)<br />   ◇ ECB: A block cipher mode that uses no feedback.<br />   ◇ CBC: A block cipher mode that introduces feedback by combining ciphertext and plaintext.<br />   ◇ CFB: A block cipher mode that processes small increments of plaintext  into ciphertext, instead of processing an entire block at a time.<br />   ◇ OFB: A block cipher mode that uses feedback similar to CFB.<br /><br /><div class="codebox"><div class="codebox">//&nbsp;Set&nbsp;mode<br />DWORD&nbsp;mode&nbsp;=&nbsp;CRYPT_MODE_CBC;<br />CryptSetKeyParam(h_key,&nbsp;KP_MODE,&nbsp;(BYTE*)&amp;mode,&nbsp;0))</div></div><br /><br /><strong><h3>### IV - Initialisation Vector</h3></strong><br />• <a href="https://crypto.stackexchange.com/questions/39615/best-way-to-generate-a-iv-for-aes-cbc-when-encrypting-files">https://crypto.stackexchange.com/questions/39615/best-way-to-generate-a-iv-for-aes-cbc-when-encrypting-files</a><br /><br />The IV is the Initialisation Vector.<br />The IV <em>does not</em> need to be secret.<br />Generally, a random IV value is advised.<br /><br /><div class="codebox"><div class="codebox">//&nbsp;Random&nbsp;IV<br />char&nbsp;iv[16]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />CryptGenRandom(h_provider,&nbsp;16,&nbsp;(BYTE*)iv);<br />CryptSetKeyParam(h_key,&nbsp;KP_IV,&nbsp;iv,&nbsp;0);<br /><br />//&nbsp;Non-random&nbsp;IV<br />BYTE&nbsp;iv[16]&nbsp;=&nbsp;{&nbsp;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&nbsp;};<br />CryptSetKeyParam(h_key,&nbsp;KP_IV,&nbsp;iv,&nbsp;0);</div></div><br /><br />However, some modes of encryption don&#39;t require a random IV<br />e.g. CBC is safe with a non-random IV if the key is only used for 1 message.<br /><br />The IV only permutates (?) the first block of the plaintext when it encrypts.<br />In order to decrypt properly, you need to use the same IV.<br />For example,<br />here&#39;s the MS DOS header of a PE file being messed up after decryption because of using a random IV to encrypt and not using the same IV to decrypt.<br /><a href=""><img src="images/1594-1.png" alt="images/1594-1.png" /></a><br /><br />If you&#39;re generating a random IV, you&#39;ll have to save the IV somehow:<br />• export the key used to encrypt (and used it to decrypt)<br />• prepend the IV to the encrypted data<br />• etc.<br /><br /><br /><br /><br /><br /></div>
</body>
</html>
