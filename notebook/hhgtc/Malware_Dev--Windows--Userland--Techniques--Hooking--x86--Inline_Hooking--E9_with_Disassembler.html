<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>E9 with Disassembler</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x86 Inline Hooking - E9 with Disassembler</h1></strong><br />This an improved version of the E9 technique above that uses a disassembler.<br />With a disassembler, we can disassemble instructions @ the original function <br />until we have enough space for our hook (5 bytes).<br /><br />We can then fill any extra bytes within an instruction with NOPs so that we don&#39;t splice instructions.<br />e.g.<br />Need 5 bytes of space for hook. 3 instructions @ function total 7 bytes.<br />Fill the last 2 bytes with NOPs so that we don&#39;t have junk instructions after our hook.<br /><br />The disassembler in use is HDE - Hacker Disassembler Engine.<br />Both 32bit and 64bit versions can be found here:<br /><a href="https://github.com/TsudaKageyu/minhook/tree/master/src/hde">https://github.com/TsudaKageyu/minhook/tree/master/src/hde</a><br /><br /><strong><h2>## Code</h2></strong><br /><div class="codebox"><div class="codebox">/*<br />x86&nbsp;inline&nbsp;hooking&nbsp;using&nbsp;E9&nbsp;relative&nbsp;jumps.<br />This&nbsp;version&nbsp;uses&nbsp;a&nbsp;disassembler&nbsp;-&nbsp;Hacker&nbsp;Disassembler&nbsp;Engine&nbsp;(HDE).<br /><br />With&nbsp;a&nbsp;disassembler,&nbsp;we&nbsp;can&nbsp;disassemble&nbsp;instructions&nbsp;@&nbsp;the&nbsp;original&nbsp;function&nbsp;<br />until&nbsp;we&nbsp;have&nbsp;enough&nbsp;space&nbsp;for&nbsp;our&nbsp;hook&nbsp;(5&nbsp;bytes).<br /><br />We&nbsp;can&nbsp;then&nbsp;fill&nbsp;any&nbsp;extra&nbsp;bytes&nbsp;within&nbsp;an&nbsp;instruction&nbsp;with&nbsp;NOPs&nbsp;so&nbsp;that&nbsp;we&nbsp;don&#39;t&nbsp;splice&nbsp;instructions.<br />e.g.<br />Need&nbsp;5&nbsp;bytes&nbsp;of&nbsp;space&nbsp;for&nbsp;hook.&nbsp;3&nbsp;instructions&nbsp;@&nbsp;function&nbsp;total&nbsp;7&nbsp;bytes.<br />Fill&nbsp;the&nbsp;last&nbsp;2&nbsp;bytes&nbsp;with&nbsp;NOPs&nbsp;so&nbsp;that&nbsp;we&nbsp;don&#39;t&nbsp;have&nbsp;junk&nbsp;instructions&nbsp;after&nbsp;our&nbsp;hook.<br />*/<br />#define&nbsp;_CRT_SECURE_NO_WARNING<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&quot;hde/hde32.h&quot;<br /><br />int(__stdcall*&nbsp;orig_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hook_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxA&nbsp;intercepted!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;text:&nbsp;%s&nbsp;\n\t&nbsp;caption:&nbsp;%s&nbsp;\n\t&nbsp;type:&nbsp;%d&nbsp;\n&quot;,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br /><br />	return&nbsp;orig_MessageBoxA(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />/*<br />Hook&nbsp;a&nbsp;function.<br /><br />Parameters:<br />	char*&nbsp;function&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;function&nbsp;to&nbsp;hook<br />	char*&nbsp;dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;DLL&nbsp;where&nbsp;the&nbsp;function&nbsp;resides<br />	void*&nbsp;detour&nbsp;&nbsp;&nbsp;-&nbsp;the&nbsp;function&nbsp;to&nbsp;detour&nbsp;to<br />	void**&nbsp;p_orig&nbsp;&nbsp;-&nbsp;address&nbsp;of&nbsp;the&nbsp;pointer&nbsp;to&nbsp;the&nbsp;original&nbsp;function<br />Return:<br />	Number&nbsp;of&nbsp;bytes&nbsp;overwritten&nbsp;in&nbsp;the&nbsp;function.&nbsp;Use&nbsp;this&nbsp;value&nbsp;for&nbsp;Unhook().<br />*/<br />int&nbsp;Hook32(char*&nbsp;function,&nbsp;char*&nbsp;dll,&nbsp;void*&nbsp;detour,&nbsp;void**&nbsp;p_orig)<br />{<br />	//&nbsp;Grab&nbsp;address&nbsp;of&nbsp;target&nbsp;function<br />	void*&nbsp;orig_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(dll),&nbsp;function);<br /><br />	/*<br />	Disassemble&nbsp;instructions&nbsp;@&nbsp;function&nbsp;until&nbsp;we&nbsp;have&nbsp;enough&nbsp;space&nbsp;for&nbsp;hook.<br />	Fill&nbsp;any&nbsp;extra&nbsp;bytes&nbsp;within&nbsp;an&nbsp;instruction&nbsp;with&nbsp;NOPs&nbsp;so&nbsp;that&nbsp;we&nbsp;don&#39;t&nbsp;splice&nbsp;instructions.<br />	e.g.<br />	Need&nbsp;5&nbsp;bytes&nbsp;of&nbsp;space&nbsp;for&nbsp;hook.&nbsp;3&nbsp;instructions&nbsp;@&nbsp;function&nbsp;total&nbsp;7&nbsp;bytes.<br />	Fill&nbsp;the&nbsp;last&nbsp;2&nbsp;bytes&nbsp;with&nbsp;NOPs&nbsp;so&nbsp;that&nbsp;we&nbsp;don&#39;t&nbsp;have&nbsp;junk&nbsp;instructions&nbsp;after&nbsp;our&nbsp;hook.<br />	*/<br />	BOOL&nbsp;disassemble&nbsp;=&nbsp;TRUE;<br />	void*&nbsp;instruction&nbsp;=&nbsp;orig_func;<br />	int&nbsp;bytes_disassembled&nbsp;=&nbsp;0;<br />	do<br />	{<br />		hde32s&nbsp;hs&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />		unsigned&nbsp;int&nbsp;instruction_size&nbsp;=&nbsp;hde32_disasm(instruction,&nbsp;&amp;hs);<br />		if&nbsp;(hs.flags&nbsp;&amp;&nbsp;F_ERROR)		//&nbsp;Failed&nbsp;to&nbsp;disassemble<br />			return&nbsp;0;<br /><br />		//&nbsp;Quit&nbsp;if&nbsp;we&#39;ve&nbsp;disassembled&nbsp;enough&nbsp;instructions&nbsp;for&nbsp;our&nbsp;hook<br />		bytes_disassembled&nbsp;+=&nbsp;instruction_size;<br />		if&nbsp;(bytes_disassembled&nbsp;&gt;=&nbsp;5)<br />			break;<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;instruction<br />		(UINT_PTR)instruction&nbsp;+=&nbsp;instruction_size;<br />	}&nbsp;while&nbsp;(disassemble&nbsp;==&nbsp;TRUE);<br /><br />	/*<br />	Allocate&nbsp;trampoline&nbsp;space.<br />	Trampoline&nbsp;needs&nbsp;10&nbsp;extra&nbsp;bytes:<br />	-&nbsp;5&nbsp;for&nbsp;E9&nbsp;jump&nbsp;to&nbsp;original&nbsp;function<br />	-&nbsp;5&nbsp;for&nbsp;E9&nbsp;jump&nbsp;to&nbsp;hook&nbsp;function<br />	*/<br />	int&nbsp;trampoline_size&nbsp;=&nbsp;bytes_disassembled&nbsp;+&nbsp;10;<br />	void*&nbsp;trampoline&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;trampoline_size,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br /><br />	/*<br />	Construct&nbsp;trampoline.<br />	Formula&nbsp;for&nbsp;E9&nbsp;relative&nbsp;jumps&nbsp;is:&nbsp;(target&nbsp;-&nbsp;current_address)<br />	Structure&nbsp;should&nbsp;be:<br />	0		??&nbsp;??&nbsp;??&nbsp;??									;&nbsp;Prologue&nbsp;of&nbsp;original&nbsp;function<br />	5		E9&nbsp;5B&nbsp;ED&nbsp;54&nbsp;76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7782ED65	;&nbsp;Relative&nbsp;jump&nbsp;to&nbsp;original&nbsp;function<br />	A		E9&nbsp;25&nbsp;13&nbsp;11&nbsp;FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;003f1334	;&nbsp;Relative&nbsp;jump&nbsp;to&nbsp;hook&nbsp;code<br />	*/<br />	unsigned&nbsp;char&nbsp;trampoline_data[10]&nbsp;=&nbsp;{<br />		0xE9,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,<br />		0xE9,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00<br />	};<br />	DWORD&nbsp;jmp_originalfunction&nbsp;=&nbsp;((DWORD)orig_func&nbsp;+&nbsp;bytes_disassembled)&nbsp;-&nbsp;((DWORD)trampoline&nbsp;+&nbsp;bytes_disassembled&nbsp;+&nbsp;5);<br />	DWORD&nbsp;jmp_hook&nbsp;=&nbsp;(DWORD)detour&nbsp;-&nbsp;((DWORD)trampoline&nbsp;+&nbsp;bytes_disassembled&nbsp;+&nbsp;10);<br />	memcpy(trampoline_data&nbsp;+&nbsp;1,&nbsp;&amp;jmp_originalfunction,&nbsp;4);<br />	memcpy(trampoline_data&nbsp;+&nbsp;6,&nbsp;&amp;jmp_hook,&nbsp;4);<br /><br />	//&nbsp;Write&nbsp;data&nbsp;to&nbsp;trampoline<br />	memcpy(trampoline,&nbsp;orig_func,&nbsp;bytes_disassembled);<br />	memcpy((void*)((DWORD)trampoline&nbsp;+&nbsp;bytes_disassembled),&nbsp;trampoline_data,&nbsp;sizeof(trampoline_data));<br /><br />	/*<br />	Construct&nbsp;hook.&nbsp;5&nbsp;bytes&nbsp;long.<br />	Remaining&nbsp;bytes&nbsp;filled&nbsp;with&nbsp;NOPs:<br />	0&nbsp;&nbsp;&nbsp;E9&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;relative<br />	*/<br />	DWORD&nbsp;jmp_trampoline&nbsp;=&nbsp;((DWORD)trampoline&nbsp;+&nbsp;bytes_disassembled&nbsp;+&nbsp;5)&nbsp;-&nbsp;((DWORD)orig_func&nbsp;+&nbsp;5);<br /><br />	unsigned&nbsp;char*&nbsp;hook&nbsp;=&nbsp;malloc(bytes_disassembled);<br />	memset(hook,&nbsp;0xCC,&nbsp;bytes_disassembled);<br />	memcpy(hook,&nbsp;&quot;\xE9&quot;,&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;jmp&nbsp;relative<br />	memcpy(hook&nbsp;+&nbsp;1,&nbsp;&amp;jmp_trampoline,&nbsp;4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;trampoline_address&gt;<br /><br />	//&nbsp;Install&nbsp;hook&nbsp;at&nbsp;function<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	VirtualProtect(orig_func,&nbsp;bytes_disassembled,&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />	memcpy(orig_func,&nbsp;hook,&nbsp;bytes_disassembled);<br />	VirtualProtect(orig_func,&nbsp;bytes_disassembled,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />	<br />	free(hook);<br /><br />	/*<br />	Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;trampoline.<br />	When&nbsp;orig_Function()&nbsp;is&nbsp;called,&nbsp;it&nbsp;will&nbsp;execute&nbsp;the&nbsp;prologue&nbsp;@&nbsp;trampoline<br />	and&nbsp;follow&nbsp;the&nbsp;jump&nbsp;to&nbsp;the&nbsp;original&nbsp;hooked&nbsp;function.<br />	*/<br />	*p_orig&nbsp;=&nbsp;trampoline;<br /><br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;orig_func,&nbsp;bytes_disassembled);<br />	return&nbsp;bytes_disassembled;<br />}<br /><br />/*<br />Unhook&nbsp;a&nbsp;function.<br />Parameters:<br />	char*&nbsp;function&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;function&nbsp;to&nbsp;unhook<br />	char*&nbsp;dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;DLL&nbsp;where&nbsp;the&nbsp;function&nbsp;resides<br />	int&nbsp;bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;number&nbsp;of&nbsp;bytes&nbsp;ovewritten&nbsp;@&nbsp;function&nbsp;(value&nbsp;returned&nbsp;by&nbsp;Hook())<br />	void*&nbsp;trampoline&nbsp;&nbsp;-&nbsp;pointer&nbsp;to&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;trampoline&nbsp;space<br />*/<br />BOOL&nbsp;Unhook32(char*&nbsp;function,&nbsp;char*&nbsp;dll,&nbsp;int&nbsp;bytes,&nbsp;void*&nbsp;trampoline)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;FALSE;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	/*<br />	Grab&nbsp;address&nbsp;of&nbsp;original&nbsp;function,<br />	make&nbsp;it&nbsp;writable,<br />	and&nbsp;restore&nbsp;its&nbsp;first&nbsp;N&nbsp;bytes&nbsp;by&nbsp;copying&nbsp;them&nbsp;from&nbsp;the&nbsp;trampoline&nbsp;space.<br />	*/<br />	void*&nbsp;orig_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(dll),&nbsp;function);<br />	VirtualProtect(orig_func,&nbsp;bytes,&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />	memcpy(orig_func,&nbsp;trampoline,&nbsp;bytes);<br />	VirtualProtect(orig_func,&nbsp;bytes,&nbsp;old_protect,&nbsp;&amp;old_protect);<br /><br />	/*<br />	Free&nbsp;trampoline&nbsp;space<br />	and&nbsp;flush&nbsp;instruction&nbsp;cache&nbsp;at&nbsp;original&nbsp;function.<br />	*/<br />	VirtualFree(trampoline,&nbsp;0,&nbsp;MEM_RELEASE);<br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;orig_func,&nbsp;bytes);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;I&nbsp;think&nbsp;I&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;Hmm...&quot;,&nbsp;MB_OK);<br /><br />	int&nbsp;hooksize_MessageBoxA&nbsp;=&nbsp;Hook32(&quot;MessageBoxA&quot;,&nbsp;&quot;User32.dll&quot;,&nbsp;&amp;hook_MessageBoxA,&nbsp;(void*)&amp;orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&quot;,&nbsp;&quot;Hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&nbsp;good&nbsp;sir!&quot;,&nbsp;&quot;Hi&nbsp;#2&quot;,&nbsp;MB_OK);<br /><br />	Unhook32(&quot;MessageBoxA&quot;,&nbsp;&quot;User32.dll&quot;,&nbsp;hooksize_MessageBoxA,&nbsp;(void*)orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;Did&nbsp;he&nbsp;hear&nbsp;me&nbsp;ok?&quot;,&nbsp;&quot;Hmm...&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
