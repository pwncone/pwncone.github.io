<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Hotpatch Hooking</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x64 Hotpatch Hooking</h1></strong><br />The goal of x64 hotpatch hooking is to use the free bytes of space before a function.<br /><br />• <a href="https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx">https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx</a><br />• <a href="https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1502">https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1502</a><br />• <a href="https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for">https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for</a><br /><br /><strong><h2>## The Problem with Hotpatching on x64</h2></strong><br />I have no idea why things are different on x64.<br /><br /><strong><h3>### There isn&#39;t a 2 byte NOP - mov edi,edi - anymore</h3></strong><br />On x86, every function starts with a 2 byte NOP - mov edi, edi.<br />This is so it can be replaced with a 2 byte EB F9 to jump backwards into hotpatch space.<br />Here&#39;s MessageBoxA on x86.<br /><a href=""><img src="images/1685-1.png" alt="images/1685-1.png" /></a><br /><br />On x64, this doesn&#39;t exist anymore.<br />The function prologue immediately starts at the function&#39;s address.<br />Here&#39;s MessageBoxA on x64, which starts at address <code>0x00007FFE3F41AC30</code><br /><a href=""><img src="images/1685-2.png" alt="images/1685-2.png" /></a><br /><br />Because of this, it means you can&#39;t safely overwrite the start of the function anymore.<br />The 2 bytes that you write to address <code>0x00007FFE3F41AC30</code> will overwrite the function prologue and break the function.<br /><br />To solve this, you need to copy those bytes you overwrote - <code>sub rsp,38h</code> - to trampoline space.<br />That way, when you want to execute the original MessageBoxA, you can execute the prologue bytes in your trampoline and then jump to the original function.<br /><br /><strong><h3>### The size of hotpatch space before the function varies (and there&#39;s lots of function variety)</h3></strong><br />On x86, there reliably existed hotpatch space before the function.<br />Here&#39;s MessageBoxA on x86 with (at minimum) 5 bytes of space before the function.<br /><a href=""><img src="images/1685-3.png" alt="images/1685-3.png" /></a><br /><br />On x64, the amount of hotpatch space seems to vary wildly.<br />Here&#39;s MessageBoxA on x64 with 15 bytes of hotpatch space before it.<br /><a href=""><img src="images/1685-4.png" alt="images/1685-4.png" /></a><br /><br />Here&#39;s CreateDialogIndirectParamA on x64 with 16 bytes of hotpatch space before it.<br /><a href=""><img src="images/1685-5.png" alt="images/1685-5.png" /></a><br /><br />Here is GetCurrentProcessId from kernel32 on x64.<br />It seems to be in a weird-looking jump table, <br />and there&#39;s 10 bytes of space between each entry in the table.<br /><a href=""><img src="images/1685-6.png" alt="images/1685-6.png" /></a><br /><br />As a result, because of the varying lengths in hotpatch size,<br />there&#39;s catch-all solution to this.<br />You&#39;ll have to use a different method to reach your trampoline for each hook <br />depending on how many hotpatch bytes you have to work with.<br /><br />14 bytes? <br />Use an EB F0 to jump 14 bytes back and use an FF 25 00 00 00 00 &lt;trampoline address&gt; <br />to reach your tramopoline.<br /><br />For GetCurrentProcessId?<br />Try to find memory within a 2gb range and overwrite the FF 25 with the 32bit relative address of the memory in 2gb range. At that memory is a 64bit address, which is the address of your trampoline.<br /><br />The method for hotpatch hooking on x64 will vary for each function.<br /><br /><strong><h2>## The intended x64 hotpatch method? Uses 6 bytes of hotpatch space &amp; 2 bytes of the original function</h2></strong><br />This method is documented here:<br />x64 - Hotpatch Hooking - EB F8<br /><br />Apparently Microsoft says that you only need 6 bytes of free space on x64 for hotpatching.<br />(according to here at the x64 Function Patching heading, can&#39;t find their source for this:) <br /><a href="https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx">https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx</a><br /><br />There&#39;s a good explanation in the comments about how to do this:<br /><a href="https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx">https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx</a><br />And this article explains the concept too:<br /><a href="https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for">https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for</a><br /><br />However, <br />this technique relies on being able to find free memory within a 2gb range of the function you&#39;re patching.<br />(because FF 25 requries a 32bit value)<br />You:<br />• find free memory within a 2gb range of your target function<br />• write the 64bit address of your hook code there<br />• overwrite the first 6 bytes of hotpatch space with FF 25 &lt;addr of memory in 2gb range&gt;<br />• overwrite the first 2 bytes of the target function with jmp $-6 (jump 6 bytes back)<br /><br />Now whenever the target function is called it will:<br />• jump 6 bytes back (into the hotpatch space)<br />• run FF 25 and read the 64bit address from the free memory<br />• jump to the 64bit address, which will be your hook code</div>
</body>
</html>
