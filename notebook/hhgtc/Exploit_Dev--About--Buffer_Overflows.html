<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Buffer Overflows</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Buffer Overflows</h1></strong><br />Aleph One&#39;s article <code>Smashing The Stack For Fun And Profit</code> in Phrack hackerzine from 1996 was the first public discussion about buffer overflows:<br /><a href="http://phrack.org/issues/49/14.html">http://phrack.org/issues/49/14.html</a><br /><br />In short, a buffer overflow is where you write past the end of an allocated buffer in memory and overwrite the following memory values. If you can write past the end of the buffer and overwrite EIP, you can write an instruction into EIP and gain total control over the CPU.<br /><br />Stack overflows have, theoretically, been around for as long as the C language,<br />and exploitation of these vulnerabilities has occurred for over 25 years.<br /><br />Despite being well understood, due to human error stack overflow vulnerabilities can still be found in modern software today. However, nowadays there exists multiple compiler and OS protections that make it difficult for buffer overflows to be exploited.<br /><br /><strong><h2>## What is a buffer?</h2></strong><br />A buffer is a block of allocated memory<br />For example, you create an array - <code>int array[5] = {1,2,3,4,5}</code><br />That array will be allocated a buffer (a block of memory) to store its values in.<br /><br /><strong><h2>## Why are buffer overflows possible?</h2></strong><br />Buffer overflows are possible because there&#39;s no bounds checking in C or C++ languages by default.<br />   ◇ i.e. the language doesn&#39;t know if you&#39;ve written too much data to the buffer and written past the end of it<br />   ◇ bounds-checking would have to manually coded<br /><br /><strong><h3>### Read past the end of a buffer<br /></h3></strong>In the code below, we&#39;ve created an array that is 5 elements long - <code>int array[5];</code><br />However, when reading the values in the array we&#39;ve made a mistake - we&#39;ve forgotten that arrays start at 0.<br />To read the 5th element in the array like we intended, we should have written <code>array[4]</code> (not <code>array[5]</code>)<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />int&nbsp;main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;array[5]&nbsp;=&nbsp;{11,16,21,28,32};<br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d\n&quot;,&nbsp;array[5]);<br />}</div></div><br /><br />When we run our program, instead of getting <code>32</code> (the 5th element in the array) we get <code>134513712</code>.<br />What we&#39;ve got back is a bogus value, because we&#39;ve read past the end of the array buffer.<br /><div class="codebox"><div class="codebox">oak@ubuntu:~$&nbsp;./read<br />134513712</div></div><br /><br /><strong><h3>### Write past the end of a buffer</h3></strong><br />In the example above, you <em>read</em> past the end of a buffer.<br />More interestingly, you can <em>write</em> past the end of the buffer.<br /><br />In the code below, I&#39;ve created an array that is 5 elements long - <code>int array[5]</code><br />In the <code>for</code> loop, I am then assigning every element in my array to <code>10</code><br />However, I&#39;ve made a mistake - I&#39;m looping <code>255</code> times. <br />My array size is only <code>5</code>. Therefore, I&#39;ll be writing beyond my array buffer size - <code>5</code> - and overwriting other memory values.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;string.h&gt;<br /><br />int&nbsp;main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;array[5];<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;i&lt;=255;i++)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;	array[i]&nbsp;=&nbsp;10;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</div></div><br />(Most modern compilers will warn you if you try to compile like above)<br /><br />When we run the program, I get a seg fault.<br />This is (most likely) because I&#39;ve written beyond my array buffer and overwritten EIP (which contains the CPU&#39;s next instruction) with the value <code>10</code>.<br /><code>10</code> isn&#39;t a valid instruction for <code>EIP</code> to execute, therefore the program crashes and seg faults.<br /><div class="codebox"><div class="codebox">oak@ubuntu:~$&nbsp;./write<br />Segmentation&nbsp;fault&nbsp;(core&nbsp;dumped)</div></div><br /><br />If I found the point at which point was overwritten, e.g. loop <code>144</code> - I could write an instruction into EIP and gain control of the CPU.<br />This is what buffer overflows are.<br /></div>
</body>
</html>
