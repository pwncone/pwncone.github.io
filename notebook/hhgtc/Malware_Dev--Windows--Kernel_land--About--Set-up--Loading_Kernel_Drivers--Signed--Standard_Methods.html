<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Standard Methods</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1># Standard Loading Methods</h1><br />These are standard/legitimate methods to load a kernel driver<br />that is either signed or test-signed.<br /><br /><strong><h2>## OSR Driver Loader</h2></strong><br />This is an easy and convenient way of loading drivers.<br />• <a href="https://www.osronline.com/article.cfm%5Earticle=157.htm">https://www.osronline.com/article.cfm%5Earticle=157.htm</a><br />   ◇ I use the WINNET version (no idea what some of the diff versions are)<br /><br />To load:<br />1. <code>Register Service</code><br />2. <code>Start Service</code><br /><br />Unload by stopping and unregistering.<br /><br /><strong><h3>### Potential Errors</h3></strong><br /><strong><h4>#### The requsted control is not valid for this service</h4></strong><br />Happens when unloading because you haven&#39;t set a DriverUnload routine.<br /><br /><strong><h4>#### ACCESS DENIED / Trouble loading</h4></strong><br />If you get <code>ACCESS DENIED</code> or other problems when loading, try enabling <code>/integritychecks</code> when compiling your driver.<br /><a href=""><img src="images/1801-1.png" alt="images/1801-1.png" /></a><br /><br /><strong><h2>## Load driver manully using sc.exe</h2></strong><br />sc.exe controls services.<br /><a href="https://ss64.com/nt/sc.html">https://ss64.com/nt/sc.html</a><br /><br />Run all of this from an Administrator cmd/powershell prompt.<br /><br /><strong>Load</strong><br /><div class="codebox"><div class="codebox">cp&nbsp;driver.sys&nbsp;C:\Windows\system32\drivers\&nbsp;-verbose&nbsp;-force<br />sc.exe&nbsp;create&nbsp;driver.sys&nbsp;type=&nbsp;kernel&nbsp;start=&nbsp;demand&nbsp;error=&nbsp;normal&nbsp;binPath=&nbsp;C:\Windows\system32\drivers\driver.sys&nbsp;DisplayName=&nbsp;driver.sys<br />sc.exe&nbsp;start&nbsp;driver.sys</div></div><br /> <br /><strong>Unload</strong><br /><div class="codebox"><div class="codebox">sc.exe&nbsp;stop&nbsp;driver.sys<br />sc.exe&nbsp;delete&nbsp;driver.sys</div></div><br /><br /><strong><h2>## Load driver using PowerShell script</h2></strong><br />Alternatively, the process above is available as a PowerShell script.<br />Source:<br />• <a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/loading-a-windows-kernel-driver-osr-driver-loader-debugging-with-source-code#loading-a-driver-via-command-prompt-windbg">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/loading-a-windows-kernel-driver-osr-driver-loader-debugging-with-source-code#loading-a-driver-via-command-prompt-windbg</a><br /><br />Disable script prevention:<br /><code>Set-ExecutionPolicy Bypass -Scope Process</code><br /><br />Save below script as <code>.ps1</code> and execute as Administrator<br /><div class="codebox"><div class="codebox">function&nbsp;Install-Driver($name)<br /><span style="color:#000000;font-weight:400">{</span><br />	$cleanName&nbsp;=&nbsp;$name&nbsp;-replace&nbsp;&quot;.sys|.\\&quot;,&nbsp;&quot;&quot;<br /><br />	sc.exe&nbsp;stop&nbsp;$cleanName<br />	sc.exe&nbsp;delete&nbsp;$cleanName<br /><br />	cp&nbsp;$name&nbsp;c:\windows\system32\drivers\&nbsp;-verbose&nbsp;-force<br />	sc.exe&nbsp;create&nbsp;$cleanName&nbsp;type=&nbsp;kernel&nbsp;start=&nbsp;demand&nbsp;error=&nbsp;normal&nbsp;binPath=&nbsp;c:\windows\System32\Drivers\$cleanName.sys&nbsp;DisplayName=&nbsp;$cleanName<br /><br />	sc.exe&nbsp;start&nbsp;$cleanName<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h2>## Load driver using WinAPI</h2><br />• <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwloaddriver">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwloaddriver</a><br />• <a href="https://github.com/hfiref0x/DSEFix/blob/master/Source/DSEFix/instdrv.c">https://github.com/hfiref0x/DSEFix/blob/master/Source/DSEFix/instdrv.c</a> - Service Manager APIs<br />• <a href="https://github.com/Meowoverflow/Rootkits_Subverting_the_Windows_Kernel/blob/master/code/04.load_driver_the_correct_way/loader.cpp">https://github.com/Meowoverflow/Rootkits_Subverting_the_Windows_Kernel/blob/master/code/04.load_driver_the_correct_way/loader.cpp</a> - Using SCM - Service Control Manager<br /><br /><h2>## ZwSetSystemInformation</h2><br />• From Rootkits: Subverting the Windows Kernel (untested)<br />   ◇ <a href="https://github.com/Meowoverflow/Rootkits_Subverting_the_Windows_Kernel/blob/master/code/03.load_driver_using_quick_dirty_way/main.cpp">https://github.com/Meowoverflow/Rootkits_Subverting_the_Windows_Kernel/blob/master/code/03.load_driver_using_quick_dirty_way/main.cpp</a><br /><br />You can use ZwSetSystemInformation with SystemLoad AndCallImage parameter to load your driver into pageable memory.<br /><br /><strong>Problems</strong><br />It loads the driver into pageable memory, meaning your driver can swapped from memory to disk at any point.<br />This can cause problems for you.<br />Solution? Copy your driver&#39;s code into non-pageable memoroy once loaded (don&#39;t know how).</div>
</body>
</html>
