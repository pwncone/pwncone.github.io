<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>RC4 Crypt file</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># RC4 Crypt File</h1></strong><br /><br /><div class="codebox"><div class="codebox">/*<br />RC4&nbsp;file&nbsp;encryption.<br />A&nbsp;password&nbsp;is&nbsp;used&nbsp;for&nbsp;encryption:&nbsp;the&nbsp;password&nbsp;is&nbsp;hashed&nbsp;and&nbsp;then&nbsp;an&nbsp;encryption&nbsp;key&nbsp;is&nbsp;derived&nbsp;from&nbsp;the&nbsp;password&nbsp;hash.<br /><br />Usage:<br />Encrypt&nbsp;-&nbsp;`bin.exe&nbsp;e&nbsp;&lt;infile&gt;&nbsp;&lt;outfile&gt;`<br />Decrypt&nbsp;-&nbsp;`bin.exe&nbsp;d&nbsp;&lt;infile&gt;&nbsp;&lt;outfile&gt;`<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />#define&nbsp;CRYPTO_PROVIDER			MS_ENHANCED_PROV_A<br />#define&nbsp;CRYPTO_PROVIDER_TYPE	PROV_RSA_FULL<br />#define&nbsp;HASH_ALGORITHM			CALG_MD5<br />#define&nbsp;KEY_ALGORITHM			CALG_RC4<br />#define&nbsp;BLOCKSIZE				1		//&nbsp;RC4&nbsp;is&nbsp;stream&nbsp;cipher,&nbsp;so&nbsp;crypts&nbsp;bytes&nbsp;1&nbsp;by&nbsp;1<br /><br />BOOL&nbsp;DeriveKeyFromPassword(HCRYPTPROV&nbsp;provider,&nbsp;HCRYPTKEY*&nbsp;key,&nbsp;char*&nbsp;password)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br />	HCRYPTHASH&nbsp;hash&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Grab&nbsp;handle&nbsp;to&nbsp;CSP&nbsp;for&nbsp;hashing&nbsp;and&nbsp;hash&nbsp;the&nbsp;password<br />	b&nbsp;=&nbsp;CryptCreateHash(provider,&nbsp;HASH_ALGORITHM,&nbsp;0,&nbsp;0,&nbsp;&amp;hash);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;-&nbsp;CryptCreateHash&nbsp;failed:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	b&nbsp;=&nbsp;CryptHashData(hash,&nbsp;(BYTE*)password,&nbsp;strlen(password),&nbsp;0);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;-&nbsp;CryptHashData&nbsp;failed:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Create&nbsp;a&nbsp;RC4&nbsp;session&nbsp;key&nbsp;using&nbsp;the&nbsp;hashed&nbsp;password<br />	b&nbsp;=&nbsp;CryptDeriveKey(provider,&nbsp;KEY_ALGORITHM,&nbsp;hash,&nbsp;CRYPT_EXPORTABLE,&nbsp;key);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;-&nbsp;CryptDeriveKey&nbsp;failed:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(hash)&nbsp;CryptDestroyHash(hash);	//&nbsp;Destroy&nbsp;the&nbsp;password&nbsp;hash&nbsp;because&nbsp;we&nbsp;don&#39;t&nbsp;need&nbsp;it&nbsp;anymore<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	int&nbsp;i&nbsp;=&nbsp;0;<br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br /><br />	void*&nbsp;tmp_buf&nbsp;=&nbsp;NULL;<br />	char*&nbsp;infile&nbsp;=&nbsp;argv[2];<br />	char*&nbsp;outfile&nbsp;=&nbsp;argv[3];<br />	DWORD&nbsp;infile_size&nbsp;=&nbsp;0;<br />	DWORD&nbsp;outfile_size&nbsp;=&nbsp;0;<br />	DWORD&nbsp;buf_size&nbsp;=&nbsp;0;<br />	DWORD&nbsp;bytes_to_read&nbsp;=&nbsp;0;<br />	HANDLE&nbsp;h_infile&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_outfile&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;encrypt&nbsp;=&nbsp;FALSE;<br />	BOOL&nbsp;decrypt&nbsp;=&nbsp;FALSE;<br /><br />	printf(&quot;#&nbsp;rc4&nbsp;crypt&nbsp;file&nbsp;\n&quot;);<br /><br />	//&nbsp;Arguments<br />	if&nbsp;(argc&nbsp;!=&nbsp;4)<br />	{<br />		printf(&quot;incorrect&nbsp;args&nbsp;\n&quot;);<br />		printf(&quot;Usage:&nbsp;bin.exe&nbsp;e|d&nbsp;&lt;infile&gt;&nbsp;&lt;outfile&gt;&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	if&nbsp;(_stricmp(argv[1],&nbsp;&quot;e&quot;)&nbsp;==&nbsp;0)<br />		encrypt&nbsp;=&nbsp;TRUE;<br />	else&nbsp;if&nbsp;(_stricmp(argv[1],&nbsp;&quot;d&quot;)&nbsp;==&nbsp;0)<br />		decrypt&nbsp;=&nbsp;TRUE;<br />	else<br />	{<br />		printf(&quot;please&nbsp;specify&nbsp;&#39;e&#39;&nbsp;for&nbsp;encrypt&nbsp;or&nbsp;&#39;d&#39;&nbsp;for&nbsp;decrypt&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;Main<br />	//&nbsp;Open&nbsp;handles&nbsp;to&nbsp;infile&nbsp;and&nbsp;outfile<br />	h_infile&nbsp;=&nbsp;CreateFileA(infile,&nbsp;GENERIC_READ,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_outfile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;-&nbsp;failed&nbsp;to&nbsp;open&nbsp;infile:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		i&nbsp;=&nbsp;1;<br />		goto&nbsp;cleanup;<br />	}<br />	infile_size&nbsp;=&nbsp;GetFileSize(h_infile,&nbsp;NULL);<br /><br />	h_outfile&nbsp;=&nbsp;CreateFileA(outfile,&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_outfile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;-&nbsp;failed&nbsp;to&nbsp;create&nbsp;out&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		i&nbsp;=&nbsp;1;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	printf(&quot;[*]&nbsp;mode:&nbsp;%s&nbsp;\n&quot;,&nbsp;encrypt&nbsp;?&nbsp;&quot;ENCRYPTING&quot;&nbsp;:&nbsp;&quot;DECRYPTING&quot;);<br />	printf(&quot;[*]&nbsp;infile:&nbsp;%s&nbsp;\n&quot;,&nbsp;infile);<br />	printf(&quot;\t&nbsp;size:&nbsp;%d&nbsp;\n&quot;,&nbsp;infile_size);<br />	printf(&quot;[*]&nbsp;outfile:&nbsp;%s&nbsp;\n&quot;,&nbsp;outfile);<br /><br />	//&nbsp;Configure&nbsp;crypto<br />	HCRYPTKEY&nbsp;h_key&nbsp;=&nbsp;0;<br />	HCRYPTPROV&nbsp;h_provider&nbsp;=&nbsp;0;<br />	char&nbsp;password[]&nbsp;=&nbsp;&quot;Hello!&quot;;<br /><br />	b&nbsp;=&nbsp;CryptAcquireContextA(&amp;h_provider,&nbsp;NULL,&nbsp;CRYPTO_PROVIDER,&nbsp;CRYPTO_PROVIDER_TYPE,&nbsp;0);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		if&nbsp;(GetLastError()&nbsp;==&nbsp;NTE_BAD_KEYSET)<br />		{<br />			b&nbsp;=&nbsp;CryptAcquireContextA(&amp;h_provider,&nbsp;NULL,&nbsp;CRYPTO_PROVIDER,&nbsp;CRYPTO_PROVIDER_TYPE,&nbsp;CRYPT_NEWKEYSET);<br />			if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />			{<br />				i&nbsp;=&nbsp;1;<br />				goto&nbsp;cleanup;<br />			}<br />		}<br />		else<br />		{<br />			i&nbsp;=&nbsp;1;<br />			goto&nbsp;cleanup;<br />		}<br />	}<br /><br />	b&nbsp;=&nbsp;DeriveKeyFromPassword(h_provider,&nbsp;&amp;h_key,&nbsp;password);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;-&nbsp;failed&nbsp;to&nbsp;derive&nbsp;key&nbsp;from&nbsp;password:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		i&nbsp;=&nbsp;1;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	/*<br />	Determine&nbsp;max&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;encrypt/decrypt&nbsp;at&nbsp;a&nbsp;time&nbsp;(the&nbsp;block&nbsp;size)<br />	It&nbsp;must&nbsp;be&nbsp;a&nbsp;multiple&nbsp;of&nbsp;BLOCKSIZE<br />	*/<br />	bytes_to_read&nbsp;=&nbsp;1024&nbsp;-&nbsp;1024&nbsp;%&nbsp;BLOCKSIZE;	//&nbsp;will&nbsp;equal&nbsp;1024&nbsp;if&nbsp;BLOCKSIZE&nbsp;is&nbsp;0&nbsp;or&nbsp;1<br /><br />	if&nbsp;(encrypt&nbsp;==&nbsp;TRUE&nbsp;&amp;&amp;&nbsp;BLOCKSIZE&nbsp;&gt;&nbsp;1)<br />		buf_size&nbsp;=&nbsp;bytes_to_read&nbsp;+&nbsp;BLOCKSIZE;<br />	else<br />		buf_size&nbsp;=&nbsp;bytes_to_read;<br /><br />	printf(&quot;\n*&nbsp;reading&nbsp;file&nbsp;in&nbsp;chunks&nbsp;of:&nbsp;%d&nbsp;\n&quot;,&nbsp;bytes_to_read);<br />	printf(&quot;*&nbsp;buf&nbsp;size&nbsp;storing&nbsp;crypted&nbsp;data:&nbsp;%d&nbsp;\n&quot;,&nbsp;buf_size);<br /><br />	//&nbsp;Allocate&nbsp;buffer&nbsp;to&nbsp;store&nbsp;crypted&nbsp;data<br />	tmp_buf&nbsp;=&nbsp;malloc(buf_size);<br /><br />	//&nbsp;Read&nbsp;infile&nbsp;chunk&nbsp;by&nbsp;chunk,&nbsp;encrypt/decrypt,&nbsp;and&nbsp;write&nbsp;data&nbsp;out&nbsp;to&nbsp;outfile<br />	DWORD&nbsp;bytes_read&nbsp;=&nbsp;0;<br />	DWORD&nbsp;total_read&nbsp;=&nbsp;0;<br /><br />	BOOL&nbsp;end_of_file&nbsp;=&nbsp;FALSE;<br />	while&nbsp;(end_of_file&nbsp;==&nbsp;FALSE)<br />	{<br />		b&nbsp;=&nbsp;ReadFile(h_infile,&nbsp;tmp_buf,&nbsp;bytes_to_read,&nbsp;&amp;bytes_read,&nbsp;NULL);<br />		if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;-&nbsp;failed&nbsp;to&nbsp;read&nbsp;infile:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />			i&nbsp;=&nbsp;1;<br />			goto&nbsp;cleanup;<br />		}<br /><br />		total_read&nbsp;+=&nbsp;bytes_read;<br />		if&nbsp;(total_read&nbsp;==&nbsp;infile_size)<br />		{<br />			end_of_file&nbsp;=&nbsp;TRUE;<br />			printf(&quot;\n[!]&nbsp;reached&nbsp;final&nbsp;chunk&nbsp;\n\tbytes_read&nbsp;=&nbsp;%d&nbsp;\n\ttotal&nbsp;read:&nbsp;%d&nbsp;\n&quot;,&nbsp;bytes_read,&nbsp;total_read);<br />		}<br /><br />		if&nbsp;(encrypt&nbsp;==&nbsp;TRUE)<br />		{<br />			b&nbsp;=&nbsp;CryptEncrypt(h_key,&nbsp;0,&nbsp;end_of_file,&nbsp;0,&nbsp;tmp_buf,&nbsp;&amp;bytes_read,&nbsp;buf_size);<br />			if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />			{<br />				printf(&quot;-&nbsp;failed&nbsp;to&nbsp;encrypt&nbsp;chunk:&nbsp;%d.&nbsp;bytes_read&nbsp;=&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError(),&nbsp;bytes_read);<br />				i&nbsp;=&nbsp;1;<br />				goto&nbsp;cleanup;<br />			}<br />		}<br />		else&nbsp;if&nbsp;(decrypt&nbsp;==&nbsp;TRUE)<br />		{<br />			b&nbsp;=&nbsp;CryptDecrypt(h_key,&nbsp;0,&nbsp;end_of_file,&nbsp;0,&nbsp;tmp_buf,&nbsp;&amp;bytes_read);<br />			if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />			{<br />				printf(&quot;-&nbsp;failed&nbsp;to&nbsp;decrypt&nbsp;string:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />				i&nbsp;=&nbsp;1;<br />				goto&nbsp;cleanup;<br />			}<br />		}<br /><br />		b&nbsp;=&nbsp;WriteFile(h_outfile,&nbsp;tmp_buf,&nbsp;bytes_read,&nbsp;NULL,&nbsp;NULL);<br />		if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;-&nbsp;failed&nbsp;to&nbsp;write&nbsp;chunk&nbsp;into&nbsp;outfile:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />			i&nbsp;=&nbsp;1;<br />			goto&nbsp;cleanup;<br />		}<br />	}<br /><br />	printf(&quot;\n[+]&nbsp;done!&nbsp;\n&quot;);<br /><br />cleanup:<br />	if&nbsp;(h_key)&nbsp;CryptDestroyKey(h_key);<br />	if&nbsp;(h_provider)&nbsp;CryptReleaseContext(h_provider,&nbsp;0);<br />	if&nbsp;(h_outfile)&nbsp;CloseHandle(h_outfile);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
