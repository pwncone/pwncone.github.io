<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>xor</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># XOR Encrypt Strings</h1></strong><br />• <a href="http://www.rohitab.com/discuss/topic/41192-compile-time-encryption-vs2013/#entry10097152">http://www.rohitab.com/discuss/topic/41192-compile-time-encryption-vs2013/#entry10097152</a><br />• <a href="http://www.rohitab.com/discuss/topic/41192-compile-time-encryption-vs2013/#entry10097159">http://www.rohitab.com/discuss/topic/41192-compile-time-encryption-vs2013/#entry10097159</a><br />• <a href="https://github.com/mafonya/c_hide_strings/blob/master/hide.cc">https://github.com/mafonya/c_hide_strings/blob/master/hide.cc</a><br />• <a href="https://stackoverflow.com/a/34981003">https://stackoverflow.com/a/34981003</a><br />• <a href="https://github.com/JustasMasiulis/xorstr">https://github.com/JustasMasiulis/xorstr</a> - C++ header to xor at compile, unxor at runtime<br /><br /><strong><h2>## Crypt at compile time -&gt; Decrypt at runtime</h2></strong><br />Technique is super good. <br />But it&#39;s not custom and I don&#39;t understand it.<br />C++ only because it uses <code>constexpr</code><br /><br /><code>XorStr(&quot;string&quot;)</code> for ANSI.<br /><code>XorStrW(L&quot;string&quot;)</code> for Unicode.<br /><br /><strong>xor.hpp</strong><br />Source: <a href="https://stackoverflow.com/a/34981003">https://stackoverflow.com/a/34981003</a><br /><div class="codebox"><div class="codebox">#pragma&nbsp;once<br />#include&nbsp;&lt;string&gt;<br />#include&nbsp;&lt;array&gt;<br />#include&nbsp;&lt;cstdarg&gt;<br /><br />#define&nbsp;BEGIN_NAMESPACE(&nbsp;x&nbsp;)&nbsp;namespace&nbsp;x&nbsp;{<br />#define&nbsp;END_NAMESPACE&nbsp;}<br /><br />BEGIN_NAMESPACE(XorCompileTime)<br /><br />constexpr&nbsp;auto&nbsp;time&nbsp;=&nbsp;__TIME__;<br />constexpr&nbsp;auto&nbsp;seed&nbsp;=&nbsp;static_cast&lt;&nbsp;int&nbsp;&gt;(time[7])&nbsp;+&nbsp;static_cast&lt;&nbsp;int&nbsp;&gt;(time[6])&nbsp;*&nbsp;10&nbsp;+&nbsp;static_cast&lt;&nbsp;int&nbsp;&gt;(time[4])&nbsp;*&nbsp;60&nbsp;+&nbsp;static_cast&lt;&nbsp;int&nbsp;&gt;(time[3])&nbsp;*&nbsp;600&nbsp;+&nbsp;static_cast&lt;&nbsp;int&nbsp;&gt;(time[1])&nbsp;*&nbsp;3600&nbsp;+&nbsp;static_cast&lt;&nbsp;int&nbsp;&gt;(time[0])&nbsp;*&nbsp;36000;<br /><br />//&nbsp;1988,&nbsp;Stephen&nbsp;Park&nbsp;and&nbsp;Keith&nbsp;Miller<br />//&nbsp;&quot;Random&nbsp;Number&nbsp;Generators:&nbsp;Good&nbsp;Ones&nbsp;Are&nbsp;Hard&nbsp;To&nbsp;Find&quot;,&nbsp;considered&nbsp;as&nbsp;&quot;minimal&nbsp;standard&quot;<br />//&nbsp;Park-Miller&nbsp;31&nbsp;bit&nbsp;pseudo-random&nbsp;number&nbsp;generator,&nbsp;implemented&nbsp;with&nbsp;G.&nbsp;Carta&#39;s&nbsp;optimisation:<br />//&nbsp;with&nbsp;32-bit&nbsp;math&nbsp;and&nbsp;without&nbsp;division<br /><br />template&nbsp;&lt;&nbsp;int&nbsp;N&nbsp;&gt;<br />struct&nbsp;RandomGenerator<br />{<br />private:<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;a&nbsp;=&nbsp;16807;&nbsp;//&nbsp;7^5<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;m&nbsp;=&nbsp;2147483647;&nbsp;//&nbsp;2^31&nbsp;-&nbsp;1<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;s&nbsp;=&nbsp;RandomGenerator&lt;&nbsp;N&nbsp;-&nbsp;1&nbsp;&gt;::value;<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;lo&nbsp;=&nbsp;a&nbsp;*&nbsp;(s&nbsp;&amp;&nbsp;0xFFFF);&nbsp;//&nbsp;Multiply&nbsp;lower&nbsp;16&nbsp;bits&nbsp;by&nbsp;16807<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;hi&nbsp;=&nbsp;a&nbsp;*&nbsp;(s&nbsp;&gt;&gt;&nbsp;16);&nbsp;//&nbsp;Multiply&nbsp;higher&nbsp;16&nbsp;bits&nbsp;by&nbsp;16807<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;lo2&nbsp;=&nbsp;lo&nbsp;+&nbsp;((hi&nbsp;&amp;&nbsp;0x7FFF)&nbsp;&lt;&lt;&nbsp;16);&nbsp;//&nbsp;Combine&nbsp;lower&nbsp;15&nbsp;bits&nbsp;of&nbsp;hi&nbsp;with&nbsp;lo&#39;s&nbsp;upper&nbsp;bits<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;hi2&nbsp;=&nbsp;hi&nbsp;&gt;&gt;&nbsp;15;&nbsp;//&nbsp;Discard&nbsp;lower&nbsp;15&nbsp;bits&nbsp;of&nbsp;hi<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;lo3&nbsp;=&nbsp;lo2&nbsp;+&nbsp;hi;<br /><br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;max&nbsp;=&nbsp;m;<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;value&nbsp;=&nbsp;lo3&nbsp;&gt;&nbsp;m&nbsp;?&nbsp;lo3&nbsp;-&nbsp;m&nbsp;:&nbsp;lo3;<br />};<br /><br />template&nbsp;&lt;&gt;<br />struct&nbsp;RandomGenerator&lt;&nbsp;0&nbsp;&gt;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;unsigned&nbsp;value&nbsp;=&nbsp;seed;<br />};<br /><br />template&nbsp;&lt;&nbsp;int&nbsp;N,&nbsp;int&nbsp;M&nbsp;&gt;<br />struct&nbsp;RandomInt<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;constexpr&nbsp;auto&nbsp;value&nbsp;=&nbsp;RandomGenerator&lt;&nbsp;N&nbsp;+&nbsp;1&nbsp;&gt;::value&nbsp;%&nbsp;M;<br />};<br /><br />template&nbsp;&lt;&nbsp;int&nbsp;N&nbsp;&gt;<br />struct&nbsp;RandomChar<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;const&nbsp;char&nbsp;value&nbsp;=&nbsp;static_cast&lt;&nbsp;char&nbsp;&gt;(1&nbsp;+&nbsp;RandomInt&lt;&nbsp;N,&nbsp;0x7F&nbsp;-&nbsp;1&nbsp;&gt;::value);<br />};<br /><br />template&nbsp;&lt;&nbsp;size_t&nbsp;N,&nbsp;int&nbsp;K,&nbsp;typename&nbsp;Char&nbsp;&gt;<br />struct&nbsp;XorString<br />{<br />private:<br />&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;_key;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::array&lt;&nbsp;Char,&nbsp;N&nbsp;+&nbsp;1&nbsp;&gt;&nbsp;_encrypted;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;constexpr&nbsp;Char&nbsp;enc(Char&nbsp;c)&nbsp;const<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c&nbsp;^&nbsp;_key;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;Char&nbsp;dec(Char&nbsp;c)&nbsp;const<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c&nbsp;^&nbsp;_key;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;&nbsp;size_t...&nbsp;Is&nbsp;&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;constexpr&nbsp;__forceinline&nbsp;XorString(const&nbsp;Char*&nbsp;str,&nbsp;std::index_sequence&lt;&nbsp;Is...&nbsp;&gt;)&nbsp;:&nbsp;_key(RandomChar&lt;&nbsp;K&nbsp;&gt;::value),&nbsp;_encrypted{&nbsp;enc(str[Is])...&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;__forceinline&nbsp;decltype(auto)&nbsp;decrypt(void)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(size_t&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N;&nbsp;++i)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_encrypted[i]&nbsp;=&nbsp;dec(_encrypted[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_encrypted[N]&nbsp;=&nbsp;&#39;\0&#39;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_encrypted.data();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />};<br /><br />//--------------------------------------------------------------------------------<br />//--&nbsp;Note:&nbsp;XorStr&nbsp;will&nbsp;__NOT__&nbsp;work&nbsp;directly&nbsp;with&nbsp;functions&nbsp;like&nbsp;printf.<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To&nbsp;work&nbsp;with&nbsp;them&nbsp;you&nbsp;need&nbsp;a&nbsp;wrapper&nbsp;function&nbsp;that&nbsp;takes&nbsp;a&nbsp;const&nbsp;char*<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;parameter&nbsp;and&nbsp;passes&nbsp;it&nbsp;to&nbsp;printf&nbsp;and&nbsp;alike.<br />//<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Microsoft&nbsp;Compiler/Linker&nbsp;is&nbsp;not&nbsp;working&nbsp;correctly&nbsp;with&nbsp;variadic&nbsp;<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;templates!<br />//&nbsp;&nbsp;<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;the&nbsp;functions&nbsp;below&nbsp;or&nbsp;use&nbsp;std::cout&nbsp;(and&nbsp;similar)!<br />//--------------------------------------------------------------------------------<br /><br />static&nbsp;auto&nbsp;w_printf&nbsp;=&nbsp;[](const&nbsp;char*&nbsp;fmt,&nbsp;...)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;args;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_start(args,&nbsp;fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;vprintf_s(fmt,&nbsp;args);<br />&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);<br />};<br /><br />static&nbsp;auto&nbsp;w_printf_s&nbsp;=&nbsp;[](const&nbsp;char*&nbsp;fmt,&nbsp;...)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;args;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_start(args,&nbsp;fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;vprintf_s(fmt,&nbsp;args);<br />&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);<br />};<br /><br />static&nbsp;auto&nbsp;w_sprintf&nbsp;=&nbsp;[](char*&nbsp;buf,&nbsp;const&nbsp;char*&nbsp;fmt,&nbsp;...)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;args;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_start(args,&nbsp;fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;vsprintf(buf,&nbsp;fmt,&nbsp;args);<br />&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);<br />};<br /><br />static&nbsp;auto&nbsp;w_sprintf_ret&nbsp;=&nbsp;[](char*&nbsp;buf,&nbsp;const&nbsp;char*&nbsp;fmt,&nbsp;...)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;args;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_start(args,&nbsp;fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;vsprintf(buf,&nbsp;fmt,&nbsp;args);<br />&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;<br />};<br /><br />static&nbsp;auto&nbsp;w_sprintf_s&nbsp;=&nbsp;[](char*&nbsp;buf,&nbsp;size_t&nbsp;buf_size,&nbsp;const&nbsp;char*&nbsp;fmt,&nbsp;...)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;args;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_start(args,&nbsp;fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;vsprintf_s(buf,&nbsp;buf_size,&nbsp;fmt,&nbsp;args);<br />&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);<br />};<br /><br />static&nbsp;auto&nbsp;w_sprintf_s_ret&nbsp;=&nbsp;[](char*&nbsp;buf,&nbsp;size_t&nbsp;buf_size,&nbsp;const&nbsp;char*&nbsp;fmt,&nbsp;...)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;args;<br />&nbsp;&nbsp;&nbsp;&nbsp;va_start(args,&nbsp;fmt);<br />&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;vsprintf_s(buf,&nbsp;buf_size,&nbsp;fmt,&nbsp;args);<br />&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;<br />};<br /><br />//Old&nbsp;functions&nbsp;before&nbsp;I&nbsp;found&nbsp;out&nbsp;about&nbsp;wrapper&nbsp;functions.<br />//#define&nbsp;XorStr(&nbsp;s&nbsp;)&nbsp;(&nbsp;XorCompileTime::XorString&lt;&nbsp;sizeof(s)/sizeof(char)&nbsp;-&nbsp;1,&nbsp;__COUNTER__,&nbsp;char&nbsp;&gt;(&nbsp;s,&nbsp;std::make_index_sequence&lt;&nbsp;sizeof(s)/sizeof(char)&nbsp;-&nbsp;1&gt;()&nbsp;).decrypt()&nbsp;)<br />//#define&nbsp;XorStrW(&nbsp;s&nbsp;)&nbsp;(&nbsp;XorCompileTime::XorString&lt;&nbsp;sizeof(s)/sizeof(wchar_t)&nbsp;-&nbsp;1,&nbsp;__COUNTER__,&nbsp;wchar_t&nbsp;&gt;(&nbsp;s,&nbsp;std::make_index_sequence&lt;&nbsp;sizeof(s)/sizeof(wchar_t)&nbsp;-&nbsp;1&gt;()&nbsp;).decrypt()&nbsp;)<br /><br />//Wrapper&nbsp;functions&nbsp;to&nbsp;work&nbsp;in&nbsp;all&nbsp;functions&nbsp;below<br />#define&nbsp;XorStr(&nbsp;s&nbsp;)&nbsp;[]{&nbsp;constexpr&nbsp;XorCompileTime::XorString&lt;&nbsp;sizeof(s)/sizeof(char)&nbsp;-&nbsp;1,&nbsp;__COUNTER__,&nbsp;char&nbsp;&gt;&nbsp;expr(&nbsp;s,&nbsp;std::make_index_sequence&lt;&nbsp;sizeof(s)/sizeof(char)&nbsp;-&nbsp;1&gt;()&nbsp;);&nbsp;return&nbsp;expr;&nbsp;}().decrypt()<br />#define&nbsp;XorStrW(&nbsp;s&nbsp;)&nbsp;[]{&nbsp;constexpr&nbsp;XorCompileTime::XorString&lt;&nbsp;sizeof(s)/sizeof(wchar_t)&nbsp;-&nbsp;1,&nbsp;__COUNTER__,&nbsp;wchar_t&nbsp;&gt;&nbsp;expr(&nbsp;s,&nbsp;std::make_index_sequence&lt;&nbsp;sizeof(s)/sizeof(wchar_t)&nbsp;-&nbsp;1&gt;()&nbsp;);&nbsp;return&nbsp;expr;&nbsp;}().decrypt()<br /><br />END_NAMESPACE</div></div><br /><br /><strong>main.cpp</strong><br /><div class="codebox"><div class="codebox">#define&nbsp;_CRT_SECURE_NO_WARNINGS<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&quot;xor.hpp&quot;<br /><br />int&nbsp;WINAPI&nbsp;wWinMain(HINSTANCE&nbsp;hInstance,&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;PWSTR&nbsp;pCmdLine,&nbsp;int&nbsp;nCmdShow)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxW(NULL,&nbsp;XorStrW(L&quot;i&#39;m&nbsp;encrypted&nbsp;:)&quot;),&nbsp;XorStrW(L&quot;Title&nbsp;:)&quot;),&nbsp;MB_OK);	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Store encrypted -&gt; Decrypt at use</h2></strong><br />This is my own custom null-preserving XOR function.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />//&nbsp;function&nbsp;typedefs<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_Beep)(DWORD&nbsp;dwFreq,&nbsp;DWORD&nbsp;dwDuration);<br /><br />/*<br />Encrypted&nbsp;strings<br />XOR&nbsp;key&nbsp;=&nbsp;&quot;hey&quot;&nbsp;=&nbsp;&quot;\x68\x65\x79&quot;<br /><br />Encryption&nbsp;done&nbsp;at&nbsp;this&nbsp;URL:<br />https://gchq.github.io/CyberChef/#recipe=XOR(%7B&#39;option&#39;:&#39;Hex&#39;,&#39;string&#39;:&#39;%5C%5Cx68%5C%5Cx65%5C%5Cx79&#39;%7D,&#39;Standard&#39;,true)To_Hex(&#39;%5C%5Cx&#39;,0)<br />*/<br />char&nbsp;enc_str_smile[]&nbsp;=&nbsp;&quot;\x1b\x08\x10\x04\x65&quot;;<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;ANSI&nbsp;text.<br />The&nbsp;original&nbsp;string&nbsp;is&nbsp;XOR&#39;d&nbsp;and&nbsp;returned,&nbsp;so&nbsp;the&nbsp;function&nbsp;can&nbsp;be&nbsp;used&nbsp;like&nbsp;this:<br />	printf(&quot;%s&nbsp;\n&quot;,&nbsp;xorA(&quot;plaintext&quot;));<br /><br />NOTE:<br />This&nbsp;function&nbsp;modifies&nbsp;the&nbsp;original&nbsp;string.<br />If&nbsp;decrypting,&nbsp;XOR&nbsp;the&nbsp;string&nbsp;again&nbsp;after&nbsp;use&nbsp;to&nbsp;prevent&nbsp;the&nbsp;plaintext&nbsp;string<br />from&nbsp;being&nbsp;left&nbsp;in&nbsp;memory.<br />*/<br />char*&nbsp;xorA(char*&nbsp;str)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;h&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;y&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br />	int&nbsp;str_len&nbsp;=&nbsp;strlen(str);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;str_len;&nbsp;i++)<br />	{<br />		//&nbsp;If&nbsp;byte&nbsp;==&nbsp;00&nbsp;don&#39;t&nbsp;xor&nbsp;(because&nbsp;it&nbsp;shows&nbsp;key)<br />		//&nbsp;If&nbsp;byte&nbsp;is&nbsp;same&nbsp;as&nbsp;key&nbsp;don&#39;t&nbsp;XOR&nbsp;(because&nbsp;will&nbsp;produce&nbsp;00)<br />		if&nbsp;((str[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(str[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_length]))<br />			continue;<br />		else<br />			str[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_length];<br />	}<br /><br />	return&nbsp;str;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;Unicode&nbsp;text.<br />The&nbsp;original&nbsp;string&nbsp;is&nbsp;XOR&#39;d&nbsp;and&nbsp;returned,&nbsp;so&nbsp;the&nbsp;function&nbsp;can&nbsp;be&nbsp;used&nbsp;like&nbsp;this:<br />	printf(&quot;%s&nbsp;\n&quot;,&nbsp;xorA(&quot;plaintext&quot;));<br /><br />NOTE:<br />This&nbsp;function&nbsp;modifies&nbsp;the&nbsp;original&nbsp;string.<br />If&nbsp;decrypting,&nbsp;XOR&nbsp;the&nbsp;string&nbsp;again&nbsp;after&nbsp;use&nbsp;to&nbsp;prevent&nbsp;the&nbsp;plaintext&nbsp;string<br />from&nbsp;being&nbsp;left&nbsp;in&nbsp;memory.<br />*/<br />wchar_t*&nbsp;xorW(wchar_t*&nbsp;str)<br />{<br />	wchar_t&nbsp;key[]&nbsp;=&nbsp;{&nbsp;L&#39;h&#39;,&nbsp;L&#39;e&#39;,&nbsp;L&#39;y&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key)&nbsp;/&nbsp;2;		//&nbsp;sizeof(key)&nbsp;comes&nbsp;out&nbsp;as&nbsp;double&nbsp;key&nbsp;length&nbsp;(idk&nbsp;why),&nbsp;so&nbsp;must&nbsp;divide&nbsp;by&nbsp;2<br />	int&nbsp;str_len&nbsp;=&nbsp;wcslen(str);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;string_length;&nbsp;i++)<br />	{<br />		//&nbsp;If&nbsp;byte&nbsp;==&nbsp;00&nbsp;don&#39;t&nbsp;xor&nbsp;(because&nbsp;it&nbsp;shows&nbsp;key)<br />		//&nbsp;If&nbsp;byte&nbsp;is&nbsp;same&nbsp;as&nbsp;key&nbsp;don&#39;t&nbsp;XOR&nbsp;(because&nbsp;will&nbsp;produce&nbsp;00)<br />		if&nbsp;((str[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(str[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_length]))<br />			continue;<br />		else<br />			str[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_length];<br />	}<br /><br />	return&nbsp;string_copy;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;encrypted:&nbsp;%s&nbsp;\n&quot;,&nbsp;enc_str_smile);<br />	printf(&quot;decrypted:&nbsp;%s&nbsp;\n&quot;,&nbsp;xorA(enc_str_smile));<br />	printf(&quot;it&#39;s&nbsp;now&nbsp;plaintext&nbsp;in&nbsp;memory:&nbsp;%s&nbsp;\n&quot;,&nbsp;enc_str_smile);<br />	xorA(enc_str_smile);<br />	printf(&quot;look&nbsp;it&#39;s&nbsp;encrypted&nbsp;again:&nbsp;%s&nbsp;\n&quot;,&nbsp;enc_str_smile);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /><br /></div>
</body>
</html>
