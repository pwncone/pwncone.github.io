<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>MSDN Server Example - receive data until client stops sending</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'>I wrote this to learn Winsock.<br />Create a socket, then I followed the MSDN documentation here:<br /><a href="https://docs.microsoft.com/en-us/windows/win32/winsock/creating-a-socket-for-the-server">https://docs.microsoft.com/en-us/windows/win32/winsock/creating-a-socket-for-the-server</a><br /><br />More MSDN server example heres - simple &amp; advanced:<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/winsock/getting-started-with-winsock#advanced-winsock-samples">https://docs.microsoft.com/en-us/windows/win32/winsock/getting-started-with-winsock#advanced-winsock-samples</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind">https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;WinSock2.h&gt;<br />#include&nbsp;&lt;WS2tcpip.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Ws2_32.lib&quot;)<br /><br />#define&nbsp;SERVER_PORT&nbsp;&quot;27015&quot;<br />#define&nbsp;RECV_LEN&nbsp;1024<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;initialise&nbsp;Winsock<br />	printf(&quot;[*]&nbsp;initialising&nbsp;winsock&nbsp;\n&quot;);<br />	WSADATA&nbsp;wsaData;<br />	if&nbsp;(WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;wsaData)&nbsp;!=&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;initialise&nbsp;winsock&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;resolve&nbsp;addres&nbsp;&amp;&nbsp;port&nbsp;to&nbsp;be&nbsp;used&nbsp;by&nbsp;server<br />	printf(&quot;[*]&nbsp;querying&nbsp;server&nbsp;for&nbsp;info&nbsp;\n&quot;);<br />	struct&nbsp;addrinfo&nbsp;hints;					//&nbsp;stores&nbsp;info&nbsp;about&nbsp;type&nbsp;of&nbsp;socket&nbsp;caller&nbsp;supports<br />	struct&nbsp;addrinfo*&nbsp;serverInfo;			//&nbsp;contains&nbsp;info&nbsp;about&nbsp;remoote&nbsp;host&nbsp;received&nbsp;from&nbsp;GetAddrInfoW<br />	ZeroMemory(&amp;hints,&nbsp;sizeof(hints));<br /><br />	hints.ai_family&nbsp;=&nbsp;AF_INET;				//&nbsp;ipv4<br />	hints.ai_socktype&nbsp;=&nbsp;SOCK_STREAM;		//&nbsp;TCP<br />	hints.ai_protocol&nbsp;=&nbsp;IPPROTO_TCP;		//&nbsp;TCP&nbsp;protocol<br />	hints.ai_flags&nbsp;=&nbsp;AI_PASSIVE;			//&nbsp;denotes&nbsp;that&nbsp;the&nbsp;socket&nbsp;will&nbsp;call&nbsp;bind()<br /><br />	if&nbsp;(GetAddrInfoA(NULL,&nbsp;SERVER_PORT,&nbsp;&amp;hints,&nbsp;&amp;serverInfo)&nbsp;!=&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;retrieve&nbsp;remote&nbsp;server&nbsp;info:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;create&nbsp;socket<br />	printf(&quot;[*]&nbsp;creating&nbsp;socket&nbsp;\n&quot;);<br />	SOCKET&nbsp;muhSocket&nbsp;=&nbsp;INVALID_SOCKET;<br />	muhSocket&nbsp;=&nbsp;socket(serverInfo-&gt;ai_family,&nbsp;serverInfo-&gt;ai_socktype,&nbsp;serverInfo-&gt;ai_protocol);<br />	if&nbsp;(muhSocket&nbsp;==&nbsp;INVALID_SOCKET)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		freeaddrinfo(serverInfo);<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;bind&nbsp;the&nbsp;socket&nbsp;to&nbsp;address&nbsp;&amp;&nbsp;port<br />	printf(&quot;[*]&nbsp;binding&nbsp;socket&nbsp;\n&quot;);<br />	if&nbsp;(bind(muhSocket,&nbsp;serverInfo-&gt;ai_addr,&nbsp;serverInfo-&gt;ai_addrlen)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		freeaddrinfo(serverInfo);<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	freeaddrinfo(serverInfo);	//&nbsp;serverInfo&nbsp;struct&nbsp;no&nbsp;longer&nbsp;needed,&nbsp;so&nbsp;free&nbsp;it<br /><br />	//&nbsp;listen&nbsp;on&nbsp;the&nbsp;bound&nbsp;socket<br />	//&nbsp;SOMAXCONN&nbsp;is&nbsp;a&nbsp;Windows&nbsp;const&nbsp;that&nbsp;defines&nbsp;a&nbsp;reasonable&nbsp;max&nbsp;number&nbsp;of&nbsp;pending&nbsp;connections<br />	printf(&quot;[*]&nbsp;listening&nbsp;on&nbsp;socket&nbsp;\n&quot;);<br />	if&nbsp;(listen(muhSocket,&nbsp;SOMAXCONN)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;accept&nbsp;client&nbsp;connections<br />	printf(&quot;[*]&nbsp;waiting&nbsp;for&nbsp;connection...&nbsp;\n&quot;);<br />	SOCKET&nbsp;clientSocket&nbsp;=&nbsp;INVALID_SOCKET;			//&nbsp;temp&nbsp;socket&nbsp;for&nbsp;client&nbsp;connections<br />	clientSocket&nbsp;=&nbsp;accept(muhSocket,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(clientSocket&nbsp;==&nbsp;INVALID_SOCKET)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;accept&nbsp;client&nbsp;connection&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;client&nbsp;connected&nbsp;\n&quot;);<br /><br />	//&nbsp;receive&nbsp;data&nbsp;until&nbsp;peer&nbsp;closes&nbsp;connection<br />	char&nbsp;recv_buf[RECV_LEN];		//&nbsp;store&nbsp;received&nbsp;data<br />	int&nbsp;recv_len;					//&nbsp;store&nbsp;number&nbsp;of&nbsp;bytes&nbsp;received<br />	int&nbsp;send_len;					//&nbsp;store&nbsp;number&nbsp;of&nbsp;bytes&nbsp;sent<br />	do<br />	{<br />		recv_len&nbsp;=&nbsp;recv(clientSocket,&nbsp;recv_buf,&nbsp;RECV_LEN,&nbsp;0);<br />		if&nbsp;(recv_len&nbsp;&gt;&nbsp;0)<br />		{<br />			printf(&quot;bytes&nbsp;received:&nbsp;%d&nbsp;\n&quot;,&nbsp;recv_len);<br />			printf(&quot;data&nbsp;received:&nbsp;\n%.*s&nbsp;\n&quot;,&nbsp;recv_len,&nbsp;recv_buf);<br /><br />			//&nbsp;echo&nbsp;buffer&nbsp;back&nbsp;to&nbsp;client<br />			send_len&nbsp;=&nbsp;send(clientSocket,&nbsp;recv_buf,&nbsp;recv_len,&nbsp;0);<br />			if&nbsp;(send_len&nbsp;==&nbsp;SOCKET_ERROR)<br />			{<br />				fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;accept&nbsp;client&nbsp;connection&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />				closesocket(clientSocket);<br />				closesocket(muhSocket);<br />				WSACleanup();<br />				return&nbsp;1;<br />			}<br />			printf(&quot;byte&nbsp;sent:&nbsp;%d&nbsp;\n&quot;,&nbsp;send_len);<br />		}<br />		else&nbsp;if&nbsp;(recv_len&nbsp;==&nbsp;0)<br />		{<br />			printf(&quot;[!]&nbsp;no&nbsp;more&nbsp;data&nbsp;sent&nbsp;by&nbsp;client.&nbsp;closing...&nbsp;\n&quot;);<br />		}<br />		else<br />		{<br />			fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;receive&nbsp;data:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />			closesocket(clientSocket);<br />			closesocket(muhSocket);<br />			WSACleanup();<br />			return&nbsp;1;<br />		}<br />	}&nbsp;while&nbsp;(recv_len&nbsp;&gt;&nbsp;0);<br /><br /><br />	//&nbsp;clean&nbsp;up&nbsp;&amp;&nbsp;exit<br />	closesocket(clientSocket);<br />	closesocket(muhSocket);<br />	WSACleanup();<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /></div>
</body>
</html>
