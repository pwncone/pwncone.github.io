<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PE File Format</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># PE File Format</h1></strong><br />If you understand the PE file format, you understand a lot about how windows binaries work.<br /><br /><strong>Resources</strong><br />• <a href="http://www.skyfree.org/linux/references/coff.pdf">http://www.skyfree.org/linux/references/coff.pdf</a> - PE Specification - BEST PLACE TO LOOK<br />• <a href="https://www.youtube.com/watch?v=l6GjU8fm8sM">https://www.youtube.com/watch?v=l6GjU8fm8sM</a> - MalwareAnalysisForHedgehogs<br />• <a href="https://resources.infosecinstitute.com/2-malware-researchers-handbook-demystifying-pe-file/">https://resources.infosecinstitute.com/2-malware-researchers-handbook-demystifying-pe-file/</a> - Basic<br />• <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files#File_Format">https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files#File_Format</a> - Indepth but good<br />• Matt Pietrek - updated version of 1994 article<br />   ◇ Part 1 - <a href="http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1">http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1</a><br />   ◇ Part 2 - <a href="http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2">http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a> - Microsoft Official<br />• <a href="https://blog.kowalczyk.info/articles/pefileformat.html">https://blog.kowalczyk.info/articles/pefileformat.html</a><br />• <a href="https://www.ired.team/miscellaneous-reversing-forensics/pe-file-header-parser-in-c++#code">https://www.ired.team/miscellaneous-reversing-forensics/pe-file-header-parser-in-c++#code</a><br />• <a href="https://raw.githubusercontent.com/thecyberhex/books/master/Reverse%20Engineering%20for%20Beginners.pdf">https://raw.githubusercontent.com/thecyberhex/books/master/Reverse%20Engineering%20for%20Beginners.pdf</a> - Chatper 68 - Windows NT<br />• ARTeam&#39;s PE File Format Compendium<br /><br />• Challenge to create smallest PE file which downloads a file and executes it.<br />   ◇ Has interesting findings about PE file format<br />   ◇ <a href="https://webserver2.tecgraf.puc-rio.br/~ismael/Cursos/YC++/apostilas/win32_xcoff_pe/tyne-example/Tiny%20PE.htm">https://webserver2.tecgraf.puc-rio.br/~ismael/Cursos/YC++/apostilas/win32_xcoff_pe/tyne-example/Tiny%20PE.htm</a><br /><br />Just putting these here. They might help me out.<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagervatosection">https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagervatosection</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagedirectoryentrytodataex">https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagedirectoryentrytodataex</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagervatova">https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagervatova</a><br /><br /><strong><h2>## Overview</h2></strong><br />Sometimes it&#39;s easier to understand the PE File Format by just looking at the C structs. <br />So:<br /><br /><strong>DOS Header</strong><br /><code>IMAGE_DOS_HEADER</code> <br /><a href="https://www.nirsoft.net/kernel_struct/vista/IMAGE_DOS_HEADER.html">https://www.nirsoft.net/kernel_struct/vista/IMAGE_DOS_HEADER.html</a><br /><br /><strong>PE Header</strong><br /><code>IMAGE_NT_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32</a><br /><br /><strong>COFF Header</strong><br /><code>IMAGE_FILE_HEADER</code> <br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header</a><br /><br /><strong>PE Optional Header</strong><br /><code>IMAGE_OPTIONAL_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32</a><br /><br /><strong>Data Directories</strong><br />Imports<br /><code>IMAGE_IMPORT_DESCRIPTOR</code><br /><a href="http://pinvoke.net/default.aspx/Structures/IMAGE_IMPORT_DESCRIPTOR.html">http://pinvoke.net/default.aspx/Structures/IMAGE_IMPORT_DESCRIPTOR.html</a><br /><br />Exports<br /><code>IMAGE_EXPORT_DIRECTORY</code><br /><a href="http://pinvoke.net/default.aspx/Structures.IMAGE_EXPORT_DIRECTORY">http://pinvoke.net/default.aspx/Structures.IMAGE_EXPORT_DIRECTORY</a><br /><br /><strong>Sections</strong><br /><code>IMAGE_SECTION_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header</a><br /><br /><strong><h2>## Intro</h2></strong><br />PE stands for Portable Executable.<br />The PE file format contains all the information Windows needs to load the executable into memory and execute it.<br />They&#39;re called Portable Executables because they were designed by Microsoft to run on all Windows flavours and support all CPUs.<br /><br />A 32-bit PE is <code>PE32</code><br />A 64-bit PE is <code>PE32+</code><br /><br /><code>.exe</code> and <code>.dll</code> files both use the exact same PE format.<br /><br />Here&#39;s a small diagram:<br /><a href=""><img src="images/1522-1.png" alt="images/1522-1.png" /></a><br /><br /><strong><h2>## Overview</h2></strong><br />There are multiple sections to a PE file.<br />I&#39;ll only cover the interesting bits of each section.<br />I find it easier to understand the PE file format from a code point of view, so that&#39;s what I&#39;ll do.<br /><br />NOTE: Read the file into a buffer first. All the code below is reading raw addresses not virtual addresses.<br /><br /><strong><h3>### MS-DOS Header</h3></strong><br />The MS-DOS Header is at the start of every PE file.<br />It identifies the file as a DOS file.<br /><br /><code>IMAGE_DOS_HEADER</code><br /><a href="https://www.nirsoft.net/kernel_struct/vista/IMAGE_DOS_HEADER.html">https://www.nirsoft.net/kernel_struct/vista/IMAGE_DOS_HEADER.html</a><br /><br /><div class="codebox"><div class="codebox">PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />dos_header&nbsp;=&nbsp;file_buffer;<br /><br />printf(&quot;DOS&nbsp;header&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dos_header);<br />printf(&quot;\t&nbsp;e_magic:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;dos_header-&gt;e_magic);<br />printf(&quot;\t&nbsp;e_lfanew:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;dos_header-&gt;e_lfanew);</div></div><br /><br />Some values of interest are:<br />• <code>e_magic</code><br />   ◇ identifies the file as a DOS file<br />   ◇ should be <code>0x5a4d</code> - ASCII for <code>MZ</code> - Mark Zbikowski - the original architect of MS-DOS<br />   ◇ <code>IMAGE_DOS_SIGNATURE</code> stores this constant<br />• <code>e_lfanew</code> <br />   ◇ contains the offset to the PE header-  the <code>IMAGE_NT_HEADERS</code> struct<br /><br /><strong><h3>### DOS Stub</h3></strong><br />This follows just after the MS-DOS Header.<br />This is a mini DOS program - a series of machine instructions - written by Microsoft to ensure backwards compatibility.<br />If a 32bit Windows binary is run in a 16-bit DOS environment, this program will display the error message: &quot;This program cannot be run in DOS mode.&quot;, and then terminate. <br /><br /><strong><h3>### PE Header</h3></strong><br />The PE Header identifies the file as a PE file, and contains offsets to the COFF Header and PE Optional Header.<br /><br /><code>IMAGE_NT_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32</a><br /><br /><div class="codebox"><div class="codebox">PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br /><br />dos_header&nbsp;=&nbsp;file_buffer;<br />pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br /><br />printf(&quot;PE&nbsp;header&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pe_header);<br />printf(&quot;\t&nbsp;signature:&nbsp;%x&nbsp;\n&quot;,&nbsp;pe_header-&gt;Signature);<br />printf(&quot;\t&nbsp;offset&nbsp;to&nbsp;COFF&nbsp;header:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pe_header-&gt;FileHeader);<br />printf(&quot;\t&nbsp;offset&nbsp;to&nbsp;PE&nbsp;optional&nbsp;header:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pe_header-&gt;OptionalHeader);</div></div><br /><br />It can also be retrieved with <code>ImageNtHeader</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagentheader">https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagentheader</a><br /><br />Some values of interest are:<br />• <code>Signature</code><br />   ◇ identifies the file as a PE file<br />   ◇ should be <code>&quot;PE\0\0&quot;</code> - <code>0x4550</code><br />   ◇ <code>IMAGE_NT_SIGNATURE</code> stores this constant<br />• <code>FileHeader</code><br />   ◇ offset to the COFF header<br />• <code>OptionalHeader</code><br />   ◇ offset to the PE Optional Header<br /><br /><strong><h3>### COFF Header</h3></strong><br />The COFF header contains info about the PE file: the computer architecture, the number of sections, time/date it was compiled, etc.<br /><br /><code>IMAGE_FILE_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header</a><br /><br /><div class="codebox"><div class="codebox">PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br /><br />dos_header&nbsp;=&nbsp;file_buffer;<br />pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />coff_header&nbsp;=&nbsp;&amp;pe_header-&gt;FileHeader;<br /><br />printf(&quot;COFF&nbsp;header&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;&amp;pe_header-&gt;FileHeader);<br />printf(&quot;\t&nbsp;computer&nbsp;arch&nbsp;0x%x&nbsp;\n&quot;,&nbsp;pe_header-&gt;FileHeader.Machine);<br />printf(&quot;\t&nbsp;no.&nbsp;of&nbsp;sections:&nbsp;%d&nbsp;\n&quot;,&nbsp;pe_header-&gt;FileHeader.NumberOfSections);<br />printf(&quot;\t&nbsp;time&nbsp;created:&nbsp;%x&nbsp;\n&quot;,&nbsp;pe_header-&gt;FileHeader.TimeDateStamp);</div></div><br /><br />Some values of interest are:<br />• <code>Machine</code><br />   ◇ identifies the architecture of the computer<br />   ◇ <code>0x014c</code> = x86 <code>0x8664</code> = x64<br /><br /><strong><h3>### PE Optional Header</h3></strong><br />The PE Optiona Header a lot info related to loading the PE into memory: base address, entry point, etc.<br /><br /><code>IMAGE_OPTIONAL_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32</a><br /><br /><div class="codebox"><div class="codebox">PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br /><br />dos_header&nbsp;=&nbsp;file_buffer;<br />pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />coff_header&nbsp;=&nbsp;&amp;pe_header-&gt;FileHeader;<br />pe_optional_header&nbsp;=&nbsp;&amp;pe_header-&gt;OptionalHeader;<br /><br />printf(&quot;PE&nbsp;optional&nbsp;header&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;&amp;pe_header-&gt;OptionalHeader);<br />printf(&quot;\t&nbsp;magic:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;pe_header-&gt;OptionalHeader.Magic);<br />printf(&quot;\t&nbsp;entry&nbsp;point:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint);<br />printf(&quot;\t&nbsp;base&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pe_header-&gt;OptionalHeader.ImageBase);<br />printf(&quot;\t&nbsp;subsystem:&nbsp;%d&nbsp;\n&quot;,&nbsp;pe_header-&gt;OptionalHeader.Subsystem);</div></div><br /><br />Some values of interest are:<br />• <code>Magic</code><br />   ◇ whether the file is 32bit or 64bit<br />   ◇ <code>0x10b</code> = PE32 <code>0x20b</code> = PE64<br />• <code>AddressOfEntryPoint</code><br />   ◇ offset to the entry point function<br />• <code>ImageBase</code><br />   ◇ the preferred base address of the PE when it&#39;s loaded into memory<br />   ◇ <code>0x00400000</code> is default for 32bit PEs<br />   ◇ <code>0x0000000140000000</code> is default for 64bit PEs<br />• <code>Subsystem</code><br />   ◇ whether the PE is a GUI applicatoin, a console application, a boot application, etc.<br />   ◇ 2 = GUI<br />   ◇ 3 = Console<br /><br /><strong><h3>### Data Directories</h3></strong><br />All of the possible data directories are listed here (towards the bottom):<br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32</a><br />Some interesting ones:<br /><code>IMAGE_DIRECTORY_ENTRY_BASERELOC</code><br /><code>IMAGE_DIRECTORY_ENTRY_EXPORT</code><br /><code>IMAGE_DIRECTORY_ENTRY_IMPORT</code><br /><br /><strong>#### Imports</strong><br /><code>IMAGE_IMPORT_DESCRIPTOR</code><br /><a href="http://pinvoke.net/default.aspx/Structures/IMAGE_IMPORT_DESCRIPTOR.html">http://pinvoke.net/default.aspx/Structures/IMAGE_IMPORT_DESCRIPTOR.html</a><br /><br />• <code>Name</code><br />   ◇ contains an offset to the name of imported DLL<br />• <code>OriginalFirstThunk</code><br />   ◇ points to the Import Lookup Table<br />• <code>FirstThunk</code><br />   ◇ points to the Import Address Table - gets filled with function addresses when PE is loaded<br /><br /><strong><h3>### Section Headers</h3></strong><br />Immediately following the PE Optional Header are the section headers.<br /><br /><code>IMAGE_SECTION_HEADER</code><br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header">https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header</a><br /><br />An <code>IMAGE_SECTION_HEADER</code> points to the section in the PE file and describes its size.<br />Each section in the PE will have a corresponding <code>IMAGE_SECTION_HEADER</code> struct.<br />e.g:<br />• the <code>.text</code> section will have an <code>IMAGE_SECTION_HEADER</code> struct<br />• the <code>.data</code> section will have an <code>IMAGE_SECTION_HEADER</code> struct<br />• etc.<br /><br />You can grab the first section with <code>IMAGE_FIRST_SECTION</code><br />You can grab the last section with <code>(IMAGE_FIRST_SECTION(pe_header) + pe_header-&gt;FileHeader.NumberOfSections) - 1;</code><br /><br />You loop through the sections by incrementing the <code>IMAGE_SECTION_HEADER</code> by 1 each time.<br /><br /><div class="codebox"><div class="codebox">PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br />PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />dos_header&nbsp;=&nbsp;file_buffer;<br />pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />coff_header&nbsp;=&nbsp;&amp;pe_header-&gt;FileHeader;<br />pe_optional_header&nbsp;=&nbsp;&amp;pe_header-&gt;OptionalHeader;<br />section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />printf(&quot;section&nbsp;headers&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header);<br />for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;\t&nbsp;%s&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;section_header);<br />	printf(&quot;\t\t&nbsp;size&nbsp;when&nbsp;memory&nbsp;mapped:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;section_header-&gt;Misc.VirtualSize);<br />	printf(&quot;\t\t&nbsp;address&nbsp;when&nbsp;memory&nbsp;mapped:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;section_header-&gt;VirtualAddress);<br />	printf(&quot;\t\t&nbsp;size&nbsp;on&nbsp;disk:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;section_header-&gt;SizeOfRawData);<br />	printf(&quot;\t\t&nbsp;address&nbsp;on&nbsp;disk:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;section_header-&gt;PointerToRawData);<br />	printf(&quot;\t\t&nbsp;no.&nbsp;of&nbsp;relocations:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;section_header-&gt;NumberOfRelocations);<br />	printf(&quot;\t\t&nbsp;pointer&nbsp;to&nbsp;relocations:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;section_header-&gt;PointerToRelocations);<br /><br />	section_header&nbsp;+=&nbsp;1;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Some values of interest are:<br />• <code>Misc.PhysicalAddress</code> - apparently this is the file address? (don&#39;t know what that means)<br />                                  - it always seems to be the same value as the size of the section in memory (???)<br />• <code>Misc.VirtualSize</code> - size of section when mapped into memory<br />• <code>VirtualAddress</code> - the offset to the section when loaded into memory, relative to the image base<br />• <code>SizeOfRawData</code> - size of section on disk<br />• <code>PointerToRawData</code> - pointer to start of section on disk<br />• <code>Characteristics</code> - describes whether section is read, read/write, read/write/executable, etc.<br /><br /><strong><h3>### Sections</h3></strong><br />Last are the actual sections of the PE file; all of its executable code and data basically.<br /><br /><strong><code>.text</code></strong> - contains the executable machine code instructions of the program<br /><strong><code>.data</code></strong> - contains global variables and static local variables that are initialised at compile time<br /><strong><code>.bss</code></strong><strong> </strong>- contains global/static variables that are ARE NOT initialised at compile time <br /><strong><code>.textbss</code></strong> - enables incremental linking<br /><strong><code>.rsrc</code></strong> - stores binary objects embedded into the executable (fonts, icons, version info, etc.)<br /><strong><code>.idata</code></strong> - stores IAT - Import Address Table - and info of how to import functions from other modules<br /><strong><code>.edata</code></strong> - contains info about exported functions<br /><strong><code>.reloc</code></strong> - contains a table of relocation records if a binary can&#39;t be loaded at its preferred base address.<br /><strong><code>.rdata</code></strong> - a mixed bag of stuff. If debug enabled, stores debug info<br /><br /></div>
</body>
</html>
