<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>2. Kernel</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Linux - System Architecture - Kernel</h1></strong><br />The kernel runs in ring 0.<br />i.e. It has full access to hardware<br /><br />One of the kernel&#39;s tasks is to split memory into many subdivisions.<br />Each process gets its own share of memory, and the kernel must ensure that each process keeps to its share.<br /><br /><strong><h2>## Kernel Location</h2></strong><br />• When you install a kernel, files get added to the /boot directory<br />   ◇ <code>vmlinuz</code> - this is the actual linux kernel<br />   ◇ <code>initrd</code> - the temporary file system used before loading the kernel<br />   ◇ <code>System.map</code> - symbolic lookup table<br />   ◇ <code>config</code> - kernel configuration settings (you can set which modules can be loaded)<br /><br /><strong><h2>## Kernel Modules</h2></strong><br />• Kernel modules are pieces of code that can be loaded and unloaded into the kernel on demand<br />   ◇ e.g. a new keyboard driver<br />• They allow us to extend the functionality of the kernel <br />   ◇ without actually modifying the core kernel code<br />   ◇ (that would cause nightmares)<br />• You can (usually) add modules without having to reboot the system<br /><br /><code>lsmod</code> - list the currently loaded modules<br /><code>sudo modprobe bluetooth</code> - load a module<br />   ◇ modprobe loads modules from <code>/lib/modules/&lt;kernel version&gt;/kernel/drivers</code><br />   ◇ modprobe will also load any dependencies the kernel module has<br /><code>sudo modprobe -r bluetooth</code> - remove a module<br /><br />Modify <code>/etc/modprobe.d</code> to load modules on boot<br /><br /><strong><h2>## What the kernel has to manage</h2></strong><br />The Kernel has 4 system areas to manage:<br />• <strong>Processes</strong> <br />   ◇ The kernel is responsible for determining which processes are allowed to use the CPU<br />• <strong>Memory</strong><br />   ◇ The kernel keeps of track of all memory <br />      ▪ what is currently allocated to a process<br />      ▪ what&#39;s shared between processes<br />      ▪ what&#39;s free<br />      ▪ etc.<br />• <strong>Devices</strong><br />   ◇ The kernel acts as an interface between hardware (disk, network cards) and processes<br />   ◇ The kernel operates on hardware<br />• <strong>System calls</strong> <br />   ◇ The kernel responds to system calls from user space processes to carry out operations<br /><br /><strong><h2>## Processes Management</h2></strong><br />• The kernel starts, pauses, resumes and terminates processes.<br />• On modern operating systems, processes appear to run “simultaneously”, but that actually isn&#39;t the case.<br />   ◇ The kernel is responsible for context switching<br /><br /><strong><h3>### </h3></strong><strong><h3>Context Switching</h3></strong><br />• Consider a system with a 1 core CPU<br />   ◇ Only 1 process can use the CPU at any given time.<br />• Each process uses the CPU for a small fraction of a second<br />   ◇ then pauses; <br />   ◇ then another process uses the CPU, <br />   ◇ then pauses <br />   ◇ etc. <br />• The act of one process giving up control of the CPU to another process is called a <em>context switch</em><br />• The kernel is responsible for context switching<br /><br /><strong><h3>### Time Slice</h3></strong><br />• The length of time that a process uses the CPU is called a <em>time slice</em>. <br />• Each given piece of time is enough time for the process to run some significant computation <br />   ◇ processes will often finish their current task during a single slice<br />• Because the slices are so small, humans can&#39;t perceive them <br />   ◇ and so the system appears to be running multiple processes at once<br />       <br /><strong><h3>### The Context Switching Process</h3></strong><br />1. The CPU (the actual hardwrae) interrupts the current process, switches into kernel mode, and hands control back to the kernel<br />2. The kernel records the current state of the CPU and memory (needed to resume the process that was just interrupted)<br />3. The kernel kernel performs any tasks that might have come up during the time slice (e.g. collect data from input)<br />4. The kernel analyses the list of processes that are ready to run and chooses one<br />5. The kernel prepares memory and CPU for the new process<br />6. The kernel issues a time slice to the CPU for the new process<br />7. The kernel swtiches the CPU into user mode and hands control of the CPU to the process<br /><br /><strong><h3>### </h3></strong><strong><span style="color:#000000;">Multi-CPU systems</span></strong><br />• Things become more complicated in multi-CPU systems <br />• In multi-CPU systems the kernel doesn&#39;t need to relinquish control of the CPU its currently running on in order to allow a process to run. <br />• To maximise usage of all available CPUs, the kernel relinquishes control anyway <br />   ◇ (and uses little tricks to grab a little more CPU time itself)<br /><br /><strong><h3>### </h3></strong><strong>How Processes Start</strong><br /><code>fork()</code> - when a process calls fork(), the kernel creates creates a nearly identical copy of the process<br /><code>exec()</code> - when a process calls exec(&lt;program&gt;), the kernel starts &lt;program&gt;, replacing the current process<br /><br />All processes on Linux (except <code>init</code>) start as a result of fork(), and then call exec(&lt;program&gt;) to start the program<br /><br /><em>Example: You run </em><em><code>ls</code></em><em> in the terminal</em><br />1. the shell calls fork() to create a copy of the shell<br />2. the new copy of the shell calls exec(ls) to run ls<br /><br /><a href=""><img src="images/942-1.png" alt="images/942-1.png" /></a><br /><br /><strong><h2>## Memory Management</h2></strong><br />The kernel has to manage memory during a context switch, which is a complex job because:<br />    • the kernel must have its own private area in memory to run that userland processes can&#39;t access<br />    • each user process needs its own section of memory<br />    • user processes can&#39;t access the memory of other processes<br />    • but some user processes need to share memory<br />    • some memory is read only, write only, execute only, r/w only, r/e only etc.<br />    • the system might have to use more memory than physically available by digging into swap sp ace on disk<br />    <br /><strong><h3>### Virtual Memory/VRAM</h3></strong><br />• Modern CPUs include a <em>memory management unit</em> (MMU) that enables virtual memory/VRAM. <br />• The kernel initialises and maintains a memory address map/table to translate the virtual addresses to physical addresses and vice-versa<br /><br />• When using virtual memory<br />   ◇ the kernel sets up a virtual memory block for a process to use<br />   ◇ (instead of accessing a phyiscal address in RAM)<br />• When the process accesses some of its memory<br />   ◇ the CPU&#39;s MMU interecepts<br />   ◇ and uses a memory address map to translate the virtual memory address into a physical memory address in RAM.<br /><br />The kernel initialises and maintains this memory address map - also called a <em>page table</em>.<br /><br /><strong><h2>## Device Management</h2></strong><br />• Devices are only accessible in kernel mode because improper access could crash the machine<br />• Device drivers have traditionally been part of the kernel because drivers for devices are rarely ever the same<br />   ◇ (even if they do the same thing)<br />   ◇ For example, 2 different network cards<br />      ▪ they both provide network functionality, but internally they work differently<br />   ◇ In order to present a uniform interface for user processes and software developers<br />      ▪ device drivers are part of the kernel<br /><br /><strong><h2>## System Call Management</h2></strong><br />• syscalls perform specific tasks that user space processes can&#39;t do alone <br />   ◇ opening/reading/writing files<br />   ◇ printing files<br />      ▪  all those operations require interfacing with hardware<br /><br /></div>
</body>
</html>
