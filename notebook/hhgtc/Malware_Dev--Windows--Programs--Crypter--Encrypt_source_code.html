<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Encrypt source code</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Encrypt source code</h1></strong><br />This technique is outlined in Bill Blunden&#39;s book <code>The Rootkit Arsenal</code> in Chapter 10.<br />All credit goes there.<br /><br />This method requires having access to the source code of the binary you want to encrypt.<br /><br />Within your source code file you define 2 new PE sections:<br />• <code>.code</code> - this section will contain both the <code>.text</code> and the .<code>data</code> sections of the compiled binary<br />• <code>.stub</code> - this section is where your decryption code will go (which decrypts <code>.code</code>)<br /><br />Upon compilation, you define the entry point of your program as the decryption stub - <code>.stub</code>.<br /><br />Using a separate file, you then encrypt the <code>.code</code> section of your compiled binary.<br />Your binary&#39;s machine instructions (<code>.text</code>) and its variables/data (<code>.data</code>) are now encrypted and can&#39;t be read.<br /><br />When the encrypted binary then executes, your <code>.stub</code> section wil run and decrypt the <code>.code</code> section and pass execution to it.<br /><br />A diagram and the commented source code will help greatly in explaining this technique.<br /><a href=""><img src="images/1872-1.png" alt="images/1872-1.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br /><strong><h3>### hello_world</h3></strong><br />Here is my source code that will be crypted.<br />It&#39;s a simple &quot;Hello, world!&quot; program.<br /><br />The <code>.code</code> section contains the &quot;Hello, world!&quot; program.<br />The <code>.stub</code> section contains code that will find the <code>.code</code> section, decrypt it, and execute it.<br /><div class="codebox"><div class="codebox">/*<br />A&nbsp;simple&nbsp;&quot;Hello,&nbsp;world!&quot;&nbsp;program.<br /><br />##&nbsp;Compile<br />Linker&nbsp;options&nbsp;for&nbsp;this&nbsp;code&nbsp;to&nbsp;work:<br />-&nbsp;/OPT:NOREF&nbsp;-&nbsp;Keep&nbsp;unreferenced&nbsp;data&nbsp;(Project&nbsp;&gt;&nbsp;Properties&nbsp;&gt;&nbsp;Linker&nbsp;&gt;&nbsp;Optimization&nbsp;&gt;&nbsp;References)<br />-&nbsp;/LTCG&nbsp;-&nbsp;Use&nbsp;link&nbsp;time&nbsp;code&nbsp;generation&nbsp;(Project&nbsp;&gt;&nbsp;Properties&nbsp;&gt;&nbsp;Linker&nbsp;&gt;&nbsp;Optimization&nbsp;&gt;&nbsp;Link&nbsp;Time&nbsp;Code&nbsp;Generation)<br />-&nbsp;Get&nbsp;rid&nbsp;of&nbsp;.reloc&nbsp;section<br />	-&nbsp;/DYNAMICBASE:NO&nbsp;(Project&nbsp;&gt;&nbsp;Properties&nbsp;&gt;&nbsp;Linker&nbsp;&gt;&nbsp;Advanced&nbsp;&gt;&nbsp;Randomized&nbsp;Base&nbsp;Address)<br />	-&nbsp;/FIXED&nbsp;(Project&nbsp;&gt;&nbsp;Properties&nbsp;&gt;&nbsp;Linker&nbsp;&gt;&nbsp;Advanced&nbsp;&gt;&nbsp;Fixed&nbsp;Base&nbsp;Address)<br />-&nbsp;/NXCOMPAT:NO&nbsp;-&nbsp;Disable&nbsp;DEP&nbsp;to&nbsp;modify&nbsp;executable&nbsp;memory&nbsp;(Project&nbsp;&gt;&nbsp;Properties&nbsp;&gt;&nbsp;Linker&nbsp;&gt;&nbsp;Advanced&nbsp;&gt;&nbsp;Data&nbsp;Execution&nbsp;Prevention&nbsp;(DEP))<br />-&nbsp;/INCREMENTAL:NO&nbsp;-&nbsp;Disable&nbsp;incremental&nbsp;linking&nbsp;(get&nbsp;compilation&nbsp;errors&nbsp;of&nbsp;so)&nbsp;(Project&nbsp;&gt;&nbsp;Properties&nbsp;&gt;&nbsp;Linker&nbsp;&gt;&nbsp;General&nbsp;&gt;&nbsp;Enable&nbsp;Incremental&nbsp;Linking)<br /><br />##&nbsp;Problems<br />-&nbsp;because&nbsp;of&nbsp;the&nbsp;compiler&nbsp;options,&nbsp;I&nbsp;haven&#39;t&nbsp;figured&nbsp;out&nbsp;a&nbsp;way&nbsp;to&nbsp;use&nbsp;code&nbsp;in&nbsp;other&nbsp;libraries&nbsp;yet&nbsp;(libraries&nbsp;that&nbsp;need&nbsp;linking,&nbsp;e.g.&nbsp;printf()&nbsp;in&nbsp;stdlib,&nbsp;etc.)<br />&nbsp;*/<br /><br />#include&nbsp;&lt;Windows.h&gt;<br /><br />/*&nbsp;-------------------------------&nbsp;START&nbsp;OF&nbsp;.code&nbsp;SECTION&nbsp;-------------------------------&nbsp;*/<br />/*<br />All&nbsp;code&nbsp;here&nbsp;will&nbsp;be&nbsp;in&nbsp;the&nbsp;&quot;.code&quot;&nbsp;section&nbsp;of&nbsp;the&nbsp;PE&nbsp;file.<br />This&nbsp;&quot;.code&quot;&nbsp;section&nbsp;is&nbsp;your&nbsp;normal&nbsp;program&nbsp;code,&nbsp;and&nbsp;what&nbsp;the&nbsp;source&nbsp;code&nbsp;crypter&nbsp;will&nbsp;encrypt.<br />*/<br />#pragma&nbsp;code_seg(&quot;.code&quot;)								//&nbsp;create&nbsp;.code&nbsp;section&nbsp;(code&nbsp;from&nbsp;here&nbsp;&amp;&nbsp;below&nbsp;is&nbsp;in&nbsp;the&nbsp;.code&nbsp;section)<br />#pragma&nbsp;section(&quot;.code&quot;,&nbsp;read,&nbsp;write,&nbsp;execute)			//&nbsp;set&nbsp;.code&nbsp;section&nbsp;flags&nbsp;as&nbsp;R/W/X<br />#pragma&nbsp;comment(linker,&nbsp;&quot;/SECTION:.code,RWE&quot;)<br />#pragma&nbsp;comment(linker,&nbsp;&quot;/MERGE:.text=.code&quot;)			//&nbsp;merge&nbsp;.text&nbsp;section&nbsp;into&nbsp;.code<br />#pragma&nbsp;comment(linker,&nbsp;&quot;/MERGE:.data=.code&quot;)			//&nbsp;merge&nbsp;.data&nbsp;section&nbsp;into&nbsp;.code<br /><br />int&nbsp;main(void)<br />{<br />	MessageBoxA(NULL,&nbsp;&quot;Hello,&nbsp;world!&quot;,&nbsp;&quot;Title&nbsp;:)&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br />}<br />/*&nbsp;-------------------------------&nbsp;END&nbsp;OF&nbsp;.code&nbsp;SECTION&nbsp;-------------------------------&nbsp;*/<br /><br />/*&nbsp;-------------------------------&nbsp;START&nbsp;OF&nbsp;.stub&nbsp;SECTION&nbsp;-------------------------------&nbsp;*/<br />/*<br />All&nbsp;code&nbsp;here&nbsp;will&nbsp;be&nbsp;in&nbsp;the&nbsp;&quot;.stub&quot;&nbsp;section&nbsp;of&nbsp;the&nbsp;PE&nbsp;file.<br />This&nbsp;&quot;.stub&quot;&nbsp;section&nbsp;decrypts&nbsp;the&nbsp;&quot;.code&quot;&nbsp;section&nbsp;and&nbsp;executes&nbsp;it.<br />*/<br />#pragma&nbsp;code_seg(&quot;.stub&quot;)								//&nbsp;create&nbsp;.stub&nbsp;section&nbsp;(code&nbsp;from&nbsp;here&nbsp;&amp;&nbsp;below&nbsp;is&nbsp;in&nbsp;the&nbsp;.stub&nbsp;section)<br />#pragma&nbsp;section(&quot;.stub&quot;,&nbsp;read,&nbsp;execute)					//&nbsp;set&nbsp;.stub&nbsp;section&nbsp;flags&nbsp;as&nbsp;R/X<br />#pragma&nbsp;comment(linker,&nbsp;&quot;/ENTRY:\&quot;stub_main\&quot;&quot;)			//&nbsp;set&nbsp;entry&nbsp;point&nbsp;of&nbsp;.exe&nbsp;to&nbsp;stub_main()&nbsp;function<br /><br />/*<br />Find&nbsp;&quot;.code&quot;&nbsp;section&nbsp;and&nbsp;return&nbsp;its&nbsp;VirtualAddress.<br />*/<br />LPVOID&nbsp;FindCodeSection(LPVOID&nbsp;image_base,&nbsp;DWORD*&nbsp;section_size)<br />{<br />	LPVOID&nbsp;code_addr&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)image_base;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)image_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections&nbsp;until&nbsp;we&nbsp;find&nbsp;&quot;.code&quot;&nbsp;-&gt;&nbsp;save&nbsp;its&nbsp;address&nbsp;&amp;&nbsp;size&nbsp;and&nbsp;exit<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		if&nbsp;(strcmp(section_header-&gt;Name,&nbsp;&quot;.code&quot;)&nbsp;==&nbsp;0)<br />		{<br />			code_addr&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)image_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br />			*section_size&nbsp;=&nbsp;section_header-&gt;Misc.VirtualSize;<br />			break;<br />		}<br />		<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;code_addr;<br />}<br /><br />void&nbsp;xor_bytes(unsigned&nbsp;char*&nbsp;bytes,&nbsp;DWORD&nbsp;size)<br />{<br />	unsigned&nbsp;char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;h&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;y&#39;&nbsp;};<br />	size_t&nbsp;key_length&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)<br />	{<br />		if&nbsp;((bytes[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(bytes[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_length]))<br />			continue;<br />		else<br />			bytes[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_length];<br />	}<br /><br />	return;<br />}<br /><br />int&nbsp;stub_main(void)<br />{<br />	LPVOID&nbsp;image_base&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;code_section_addr&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;code_section_size&nbsp;=&nbsp;0;<br /><br />	image_base&nbsp;=&nbsp;(LPVOID)GetModuleHandleA(NULL);<br /><br />	code_section_addr&nbsp;=&nbsp;FindCodeSection(image_base,&nbsp;&amp;code_section_size);<br />	if&nbsp;(code_section_addr&nbsp;==&nbsp;NULL)<br />		return&nbsp;1;		//&nbsp;unable&nbsp;to&nbsp;find&nbsp;.code&nbsp;section&nbsp;in&nbsp;file,&nbsp;so&nbsp;just&nbsp;exit&nbsp;out<br /><br />	//&nbsp;xor&nbsp;decrypt&nbsp;.code&nbsp;section<br />	xor_bytes(code_section_addr,&nbsp;code_section_size);<br /><br />	//&nbsp;execute&nbsp;.code&#39;s&nbsp;main()<br />	main();<br /><br />	return&nbsp;0;<br />}<br />/*&nbsp;-------------------------------&nbsp;END&nbsp;OF&nbsp;.stub&nbsp;SECTION&nbsp;-------------------------------&nbsp;*/</div></div><br /><br /><strong><h3>### encryptor</h3></strong><br />And here is my encryption program.<br />This encrypts the <code>.code</code> section of the file above.<br /><div class="codebox"><div class="codebox">/*<br />Finds&nbsp;a&nbsp;.code&nbsp;section&nbsp;in&nbsp;a&nbsp;PE&nbsp;file&nbsp;and&nbsp;encrypts&nbsp;it.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />/*<br />Make&nbsp;sure&nbsp;to&nbsp;call&nbsp;free(file_buffer)&nbsp;after&nbsp;you&#39;re&nbsp;done.<br />*/<br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Find&nbsp;&quot;.code&quot;&nbsp;section&nbsp;and&nbsp;return&nbsp;its&nbsp;raw&nbsp;address.<br />*/<br />LPVOID&nbsp;FindCodeSection(LPVOID&nbsp;image_base,&nbsp;DWORD*&nbsp;raw_size)<br />{<br />	LPVOID&nbsp;code_raw_addr&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)image_base;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)image_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections&nbsp;until&nbsp;we&nbsp;find&nbsp;&quot;.code&quot;&nbsp;-&gt;&nbsp;save&nbsp;its&nbsp;address&nbsp;&amp;&nbsp;size&nbsp;and&nbsp;exit<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		if&nbsp;(strcmp(section_header-&gt;Name,&nbsp;&quot;.code&quot;)&nbsp;==&nbsp;0)<br />		{<br />			code_raw_addr&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)image_base&nbsp;+&nbsp;section_header-&gt;PointerToRawData);<br />			*raw_size&nbsp;=&nbsp;section_header-&gt;SizeOfRawData;<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;code_raw_addr;<br />}<br /><br />void&nbsp;xor_bytes(unsigned&nbsp;char*&nbsp;bytes,&nbsp;DWORD&nbsp;size)<br />{<br />	unsigned&nbsp;char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;h&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;y&#39;&nbsp;};<br />	size_t&nbsp;key_length&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)<br />	{<br />		if&nbsp;((bytes[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(bytes[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_length]))<br />			continue;<br />		else<br />			bytes[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_length];<br />	}<br /><br />	return;<br />}<br /><br />BOOL&nbsp;WriteOutBufferToNewFile(LPVOID&nbsp;buffer,&nbsp;DWORD&nbsp;n_bytes_to_write,&nbsp;char*&nbsp;filename)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br /><br />	//&nbsp;create&nbsp;new&nbsp;file&nbsp;to&nbsp;write&nbsp;buffer&nbsp;out&nbsp;to<br />	h_file&nbsp;=&nbsp;CreateFileA(filename,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;new&nbsp;file&nbsp;to&nbsp;write&nbsp;to:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;write&nbsp;buffer&nbsp;data&nbsp;out&nbsp;to&nbsp;new&nbsp;file<br />	b_ret&nbsp;=&nbsp;WriteFile(h_file,&nbsp;buffer,&nbsp;n_bytes_to_write,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[error]&nbsp;failed&nbsp;to&nbsp;write&nbsp;data&nbsp;into&nbsp;new&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;source_crypter&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;encrypts&nbsp;the&nbsp;.code&nbsp;section&nbsp;of&nbsp;a&nbsp;PE&nbsp;file&nbsp;\n\n&quot;);<br /><br />	if&nbsp;(argc&nbsp;&lt;&nbsp;2)<br />	{<br />		printf(&quot;incorrect&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;crypter.exe&nbsp;[path/to/target/pe.exe]&nbsp;\n&quot;);<br />	}<br /><br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	char*&nbsp;target_file&nbsp;=&nbsp;argv[1];<br />	char*&nbsp;out_filename&nbsp;=&nbsp;&quot;crypted.exe&quot;;<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;code_section_raw_addr&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;code_section_raw_size&nbsp;=&nbsp;0;<br /><br />	printf(&quot;[+]&nbsp;target&nbsp;file:&nbsp;%s&nbsp;\n\n&quot;,&nbsp;target_file);<br /><br />	//&nbsp;map&nbsp;PE&nbsp;into&nbsp;memory,&nbsp;find&nbsp;its&nbsp;.code&nbsp;section,&nbsp;and&nbsp;encrypt<br />	file_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(target_file,&nbsp;&amp;file_size);<br />	if&nbsp;(file_buffer&nbsp;==&nbsp;NULL)<br />		goto&nbsp;cleanup;<br /><br />	printf(&quot;[+]&nbsp;read&nbsp;PE&nbsp;into&nbsp;memory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;file_buffer);<br /><br />	//&nbsp;find&nbsp;its&nbsp;.code&nbsp;section<br />	code_section_raw_addr&nbsp;=&nbsp;FindCodeSection(file_buffer,&nbsp;&amp;code_section_raw_size);<br />	if&nbsp;(code_section_raw_addr&nbsp;==&nbsp;NULL)<br />		goto&nbsp;cleanup;<br /><br />	printf(&quot;[*]&nbsp;raw&nbsp;.code&nbsp;section&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;code_section_raw_addr);<br />	printf(&quot;[*]&nbsp;raw&nbsp;.code&nbsp;size:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;code_section_raw_size);<br /><br />	//&nbsp;encrypt<br />	printf(&quot;[*]&nbsp;encrypting&nbsp;.code&nbsp;section...&nbsp;\n&quot;);<br />	xor_bytes(code_section_raw_addr,&nbsp;code_section_raw_size);<br /><br />	//&nbsp;write&nbsp;out&nbsp;modified&nbsp;PE&nbsp;into&nbsp;new&nbsp;file<br />	printf(&quot;[*]&nbsp;writing&nbsp;out&nbsp;crypted&nbsp;file...&nbsp;\n&quot;);<br />	b_ret&nbsp;=&nbsp;WriteOutBufferToNewFile(file_buffer,&nbsp;file_size,&nbsp;out_filename);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	printf(&quot;\n[+]&nbsp;done!&nbsp;created&nbsp;crypted&nbsp;file:&nbsp;\&quot;%s\&quot;&nbsp;\n&quot;,&nbsp;out_filename);<br /><br />cleanup:<br />	free(file_buffer);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Demo</h2></strong><br />Here&#39;s the original file.<br />We can see that the .code section isn&#39;t encrypted.<br /><a href=""><img src="images/1872-2.png" alt="images/1872-2.png" /></a><br /><br />First I run the encryptor.<br /><a href=""><img src="images/1872-3.png" alt="images/1872-3.png" /></a><br /><br />This creates a file called <code>crypted.exe</code>, which has encrypted the <code>.code</code> section of my source file.<br /><a href=""><img src="images/1872-4.png" alt="images/1872-4.png" /></a><br /><br />Now we run the encrypted file - <code>crypted.exe</code>.<br />We can see that we start in <code>stub_main()</code>, which is our decryption stub.<br /><a href=""><img src="images/1872-5.png" alt="images/1872-5.png" /></a><br /><br /><code>stub_main()</code> then decrypts the <code>.code</code> section and jumps to executing it.<br /><a href=""><img src="images/1872-6.png" alt="images/1872-6.png" /></a><br /><br /></div>
</body>
</html>
