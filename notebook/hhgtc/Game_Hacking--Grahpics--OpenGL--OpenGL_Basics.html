<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>OpenGL Basics</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># OpenGL - Learning the engine</h1></strong><br /><br /><strong><h2>## About</h2></strong><br /><a href="https://learnopengl.com/Getting-started/OpenGL">https://learnopengl.com/Getting-started/OpenGL</a><br /><br />OpenGL is a graphics specification (not an API) maintained by Kronos Group.<br />The specification defines what the result/output should be of each function.<br />The 3.3 specification can be found here: <br /><a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec33.core.pdf">https://www.khronos.org/registry/OpenGL/specs/gl/glspec33.core.pdf</a><br /><br />Developers then implement the specification into OpenGL libraries.<br />OpenGL library developers are often graphics card manufacturers.<br />e.g. Apple&#39;s OpenGL library, Linux has multiple (hobbyist and manufacturer&#39;s libraries)<br /><br />Modern OpenGL is considered as version 3.3 and higher.<br />Old OpenGL was immediate mode - this abstracted away complex stuff and was easy to use. <br />Modern OpenGL is &quot;core-profile&quot; mode - an OpenGL specification that removes old functionality and gives more flexibility. It&#39;s harder.<br /><br /><strong><h3>### State / Context</h3></strong><br />OpenGL by itself is a large state (also known as context).<br />The context holds a bunch of variables that define how OpenGL operates.<br />You change OpenGL&#39;s state by modifying the variables, updating the buffers, and then re-render the context.<br /><br />There are OpenGL functions that change state,<br />and ones that use the state.<br /><br /><strong><h3>### Objects</h3></strong><br />OpenGL libraries are written in C.<br />C language constructs don&#39;t translate well to high-level languges.<br />As a result, OpenGL has created objects (basically structs full of options).<br />An object is a collection of options that represent a subset of OpenGL&#39;s state.<br />e.g.<br /><div class="codebox"><div class="codebox">struct&nbsp;object_name&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;option1;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;option2;<br />&nbsp;&nbsp;&nbsp;&nbsp;char[]&nbsp;name;<br />};<br /><br />//&nbsp;Create&nbsp;object<br />unsigned&nbsp;int&nbsp;objectId&nbsp;=&nbsp;0;<br />glGenObject(1,&nbsp;&amp;objectId);<br />//&nbsp;Bind/assign&nbsp;object&nbsp;to&nbsp;context<br />glBindObject(GL_WINDOW_TARGET,&nbsp;objectId);<br />//&nbsp;Set&nbsp;options&nbsp;of&nbsp;object&nbsp;currently&nbsp;bound&nbsp;to&nbsp;GL_WINDOW_TARGET<br />glSetObjectOption(GL_WINDOW_TARGET,&nbsp;GL_OPTION_WINDOW_WIDTH,&nbsp;&nbsp;800);<br />glSetObjectOption(GL_WINDOW_TARGET,&nbsp;GL_OPTION_WINDOW_HEIGHT,&nbsp;600);<br />//&nbsp;Set&nbsp;context&nbsp;target&nbsp;back&nbsp;to&nbsp;default<br />glBindObject(GL_WINDOW_TARGET,&nbsp;0);</div></div><br /><br /><strong><h2>## Set up</h2></strong><br /><strong><h3>### Window &amp; Context Libraries</h3></strong><br />To draw OpenGL graphics you need an OpenGL context and a window to draw them in.<br />Getting a window and a context is OS-specific.<br />There are libraries which will do this for you:<br />• GLUT<br />• SDL<br />• SFML<br />• GLFW (used here)<br />   ◇ Get the Windows pre-compiled libraries here - <a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a><br /><br /><strong><h3>### GLAD - Grab OpenGL functions @ runtime</h3></strong><br />There are multiple different implementations of OpenGL.<br />The different implementations are all different libraries.<br />As a reuslt, the location of the OpenGL functions within these libraries will differ depening on the library.<br />Therefore, you&#39;d have to find the location of the OpenGL functions you want in the library at runtime.<br />This is a pain.<br /><br />Instead, there&#39;s libraries which will grab find functions at runtime for you.<br />e.g. GLAD<br /><br />1. Go to GLAD - <a href="https://glad.dav1d.de/">https://glad.dav1d.de/</a><br />2. Pick <em>Version 3.3</em>, Profile &gt; <em>Core</em> and tick <em>Generate a loader</em><br />3. Press Generate<br />4. Copy the includes to your code directory<br />5. Include the library files with #include <code>&lt;glad/glad.h&gt;</code><br /><br /><strong><h3>### Visual Studio Compiler settings</h3></strong><br />You gotta include all the libraries and headers.<br />Make sure to set your compile arhcitecture to whatever GLFW library you downloaded (x86 or x64)<br /><a href=""><img src="images/1252-1.png" alt="images/1252-1.png" /></a><br /><br />My GLFW and GLAD headers/libraries are stored in <code>C:\dev</code><br /><a href=""><img src="images/1252-2.png" alt="images/1252-2.png" /></a><br /><br />Add the headers/includes<br /><code>C/++ &gt; Additional Inlcude Directories</code><br />Add both GLFW and GLAD<br /><a href=""><img src="images/1252-3.png" alt="images/1252-3.png" /></a><br /><br />Add additional depencies (the libraries)<br /><code>Linker &gt; Input &gt; Additional Dependencies</code><br /><a href=""><img src="images/1252-4.png" alt="images/1252-4.png" /></a><br /><br />Copy <code>glad.c</code> into your code directory<br /><a href=""><img src="images/1252-5.png" alt="images/1252-5.png" /></a><br /><br /><a href=""><img src="images/1252-6.png" alt="images/1252-6.png" /></a><br /><br />Make sure you include GLAD before GLFW (because there&#39;s defines in GLAD that clash)<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;glad/glad.h&gt;<br />#include&nbsp;&lt;GLFW/glfw3.h&gt;<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	glfwInit();<br />	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,&nbsp;3);<br />	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,&nbsp;3);<br />	glfwWindowHint(GLFW_OPENGL_PROFILE,&nbsp;GLFW_OPENGL_CORE_PROFILE);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Test compile. Everything should work.<br /><br /><strong><h2>## Create a Window</h2></strong><br /><a href="https://learnopengl.com/Getting-started/Hello-Window">https://learnopengl.com/Getting-started/Hello-Window</a><br /><br />Here you can learn mostly about rendering:<br />• <code>glClearColor</code> changes the colour in the new state.<br />• <code>glClear</code> clears the existing state and replaces it with the new state.<br />• <code>SwapBuffers</code> swaps to the newly rendered frame (state) and shows the output to the screen.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;glad/glad.h&gt;<br />#include&nbsp;&lt;GLFW/glfw3.h&gt;<br /><br />//&nbsp;Handle&nbsp;resizing&nbsp;of&nbsp;the&nbsp;window.<br />void&nbsp;FramebufferSizeCallback(GLFWwindow*&nbsp;window,&nbsp;int&nbsp;width,&nbsp;int&nbsp;height)<br />{<br />	//&nbsp;Tell&nbsp;OpenGL&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;rendering&nbsp;window<br />	glViewport(0,&nbsp;0,&nbsp;width,&nbsp;height);<br />	return;<br />}<br /><br />//&nbsp;Process&nbsp;keyboard&nbsp;inputs<br />void&nbsp;ProcessInput(GLFWwindow*&nbsp;window)<br />{<br />	if&nbsp;(glfwGetKey(window,&nbsp;GLFW_KEY_ESCAPE)&nbsp;==&nbsp;GLFW_PRESS)<br />		glfwSetWindowShouldClose(window,&nbsp;TRUE);<br /><br />	return;<br />}<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;Initialise&nbsp;context<br />	glfwInit();<br />	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,&nbsp;3);<br />	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,&nbsp;3);<br />	glfwWindowHint(GLFW_OPENGL_PROFILE,&nbsp;GLFW_OPENGL_CORE_PROFILE);	//&nbsp;Use&nbsp;the&nbsp;core&nbsp;profile<br /><br />	//&nbsp;Create&nbsp;window&nbsp;object&nbsp;(holds&nbsp;all&nbsp;windowing&nbsp;data)<br />	GLFWwindow*&nbsp;window&nbsp;=&nbsp;glfwCreateWindow(800,&nbsp;600,&nbsp;&quot;Learn&nbsp;OpenGL&quot;,&nbsp;NULL,&nbsp;NULL);<br />	//&nbsp;Make&nbsp;our&nbsp;window&nbsp;context&nbsp;the&nbsp;main&nbsp;context&nbsp;on&nbsp;the&nbsp;thread<br />	glfwMakeContextCurrent(window);<br />	//&nbsp;Register&nbsp;callback&nbsp;to&nbsp;handle&nbsp;a&nbsp;user&nbsp;resizing&nbsp;the&nbsp;window<br />	glfwSetFramebufferSizeCallback(window,&nbsp;FramebufferSizeCallback);<br />	<br />	//&nbsp;Load&nbsp;all&nbsp;OpenGL&nbsp;function&nbsp;pointers&nbsp;from&nbsp;GLAD<br />	gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);<br /><br />	/*<br />	Create&nbsp;a&nbsp;render&nbsp;loop&nbsp;so&nbsp;that&nbsp;we&nbsp;keep&nbsp;drawing&nbsp;images.<br />	(not&nbsp;render&nbsp;1&nbsp;image&nbsp;and&nbsp;then&nbsp;exit).<br />	An&nbsp;iteration&nbsp;of&nbsp;a&nbsp;render&nbsp;loop&nbsp;is&nbsp;called&nbsp;a&nbsp;frame.<br />	glfwWindowShouldClose&nbsp;checks&nbsp;if&nbsp;GLFW&nbsp;has&nbsp;been&nbsp;instructed&nbsp;to&nbsp;close.<br />	*/<br />	while&nbsp;(!glfwWindowShouldClose(window))<br />	{<br />		//&nbsp;Handle&nbsp;user&nbsp;inputs<br />		ProcessInput(window);<br />		<br />		//&nbsp;RENDERING&nbsp;COMMANDS&nbsp;GO&nbsp;HERE<br />		//&nbsp;Clear&nbsp;screen&nbsp;so&nbsp;we&nbsp;don&#39;t&nbsp;see&nbsp;renders&nbsp;from&nbsp;the&nbsp;previous&nbsp;frame<br />		glClearColor(0.2f,&nbsp;0.3f,&nbsp;0.3f,&nbsp;1.0f);	//&nbsp;(state-setting)&nbsp;Sets&nbsp;the&nbsp;state&nbsp;to&nbsp;new&nbsp;colour<br />		glClear(GL_COLOR_BUFFER_BIT);				//&nbsp;(state-using)&nbsp;Uses&nbsp;the&nbsp;state&nbsp;to&nbsp;retrieve&nbsp;the&nbsp;new&nbsp;colour&nbsp;and&nbsp;clear&nbsp;the&nbsp;colour&nbsp;buffer&nbsp;bits&nbsp;from&nbsp;the&nbsp;previous&nbsp;frame<br />		<br />		//&nbsp;End&nbsp;of&nbsp;render&nbsp;loop<br />		glfwPollEvents();				//&nbsp;Check&nbsp;for&nbsp;events&nbsp;(keyboard&nbsp;press,&nbsp;mouse&nbsp;click,&nbsp;etc.)&nbsp;and&nbsp;call&nbsp;them<br />		glfwSwapBuffers(window);	//&nbsp;Swap&nbsp;to&nbsp;new&nbsp;frame&nbsp;and&nbsp;show&nbsp;output&nbsp;to&nbsp;screen<br />	}<br /><br />	//&nbsp;Clean&nbsp;up&nbsp;GLFW&#39;s&nbsp;resources&nbsp;and&nbsp;exit<br />	glfwTerminate();<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Graphics Pipeline</h2></strong><br />In OpenGL, everything is in 3d space.<br />But your monitor is 2D.<br />OpenGL&#39;s graphics pipeline converts the 3D space into 2D elements to draw on your screen.<br /><br />The pipeline takes as input a set of 3d coordinates.<br />It will then transform that 3d object into a 2d element on your screen.<br /> <br />Shaders are small programs which process the data in the graphics pipeline.<br />They run on the GPU.<br />You can write your own shaders (OpenGL Shading Language) or use the default ones.<br /><br />A vertex is a collection of data per 3d coordinate (e.g. the 3d coordinates and a colour value)<br />Vertex data is represented using vertex attributes.<br /><br />The pipeline can be divided into several steps.<br /><br /><strong>Part 1 - Vertex Shader</strong><br />Transforms 3d coordinates into different (?) 3d coordinates.<br /><br /><strong>Part 2 - Primitive Assembly</strong><br />Takes all the vertices (the vertexes) that form a primitive and assembles them into a shape.<br />e.g. a triangle<br /><br /><strong>Part 3 - Geometry Shader</strong><br />Takes the shape from the primitive assembly stage<br />and generates other shapes by emitting new verticies (which then form new primites)<br />e.g. you make a 2nd triangle<br /><br /><strong>Part 4 - Rastersization Stage</strong><br />Maps the primitives to corresponding pixels on the final screen.<br /><br /><strong>Part 5 - Clipping</strong><br />Discards all fragments that are outside your view, increasing performance.<br /><br /><strong>Part 6 - Fragment Shader</strong><br />Contains data about the 3d scene (lights, shadows, colour of the light, etc.)<br />and uses that to calculate the final colour of a pixel on the screen.<br /><br /><strong>Part 7 - Alpha Test and Blending Stage</strong><br />Checks the depth of the fragment to see it&#39;s behind another object (it discards the pixel if it is)<br />Then checks the opacity of the object and blends accordingly<br /><br /><strong>In most cases you only have to wortk with parts 1 and 6 - the vertex and fragment shader.</strong><br />In modern OpenGL, you have to define a vertex and fragment shader of your own (no default ones).<br /><br /><strong><h3>### Vertex Input</h3></strong><br />OpenGL only processes 3D coordinates when they&#39;re in a specific range;<br />between -1.0 and 1.0 on all 3 axes (x, y and z).<br />Coordinates within this range are called normalised device coordinates - and they&#39;ll appear on your screen.<br /><br />Here&#39;s a triangle.<br />There&#39;s 3 coordinates each with depth (z) of 0 (which means it&#39;s drawn 2d)<br /><div class="codebox"><div class="codebox">float&nbsp;vertices[]&nbsp;=&nbsp;{<br />	-0.5f,&nbsp;-0.5f,&nbsp;0.0f,<br />	&nbsp;0.5f,&nbsp;-0.5f,&nbsp;0.0f,<br />	&nbsp;0.0f,&nbsp;&nbsp;0.5f,&nbsp;0.0f<br />};</div></div><br /><br />Here&#39;s how it plots.<br /><a href=""><img src="images/1252-7.png" alt="images/1252-7.png" /></a><br /><br /><strong><h3>### Vertbox Buffer Objects</h3></strong><br />Vertex Buffer Objects (VBO) store large numbers of vertices in the GPU&#39;s memory.<br />Using VBOs, you can send big batches of data to the GPU all at once instead of sending vertexes 1 by 1.<br />With the vertex in GPU memory, the GPU can access the vertex super speedily.<br /><br />You can generate a vertex buffer with <code>glGenBuffers</code><br />There are lot of types of buffer objects. You can bind a buffer to a buffer object with <code>glBindBuffer</code><br />Lastly, you copy the vertex data into the buffer&#39;s memory with <code>glBufferData</code><br /><br /><strong><h3>### Vertex Shader</h3></strong><br />In modern OpenGL you have to write your own vertex shader.<br />Shaders are written in GLSL - OpenGL Shading Language (it&#39;s similar to C)<br />When writing your own, you&#39;ll have to translate the input data to normalised device coordinates<br />to check if the object is within OpenGL&#39;s visible region.<br /><br />Example barebones vertex shader<br /><div class="codebox"><div class="codebox">//&nbsp;Fragment&nbsp;shader&nbsp;in&nbsp;GLSL&nbsp;language:<br />#version&nbsp;330&nbsp;core<br />layout&nbsp;(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;aPos;<br /><br />void&nbsp;main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;vec4(aPos.x,&nbsp;aPos.y,&nbsp;aPos.z,&nbsp;1.0);<br />}<br /><br />//&nbsp;Fragment&nbsp;shader&nbsp;in&nbsp;C&nbsp;source:<br />const&nbsp;char*&nbsp;vertex_shader_src&nbsp;=&nbsp;&quot;#version&nbsp;330&nbsp;core\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;layout&nbsp;(location&nbsp;=&nbsp;0)&nbsp;in&nbsp;vec3&nbsp;aPos;\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;void&nbsp;main()\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;{\n&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;gl_Position&nbsp;=&nbsp;vec4(aPos.x,&nbsp;aPos.y,&nbsp;aPos.z,&nbsp;1.0);\n&quot;<br />	&quot;}\0&quot;;</div></div><br /><br /><strong><h3>### Fragment Shader</h3></strong><br />The fragment shader calculates the colour output of your pixels.<br />It has only 1 output variable, a vector of 4 values that defines the final colour output.<br /><br />This basic fragment shader outputs and orange colour.<br /><div class="codebox"><div class="codebox">//&nbsp;Fragment&nbsp;shader&nbsp;in&nbsp;GLSL&nbsp;language:<br />#version&nbsp;330&nbsp;core<br />out&nbsp;vec4&nbsp;FragColor;<br /><br />void&nbsp;main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(1.0f,&nbsp;0.5f,&nbsp;0.2f,&nbsp;1.0f);<br />}<br /><br />//&nbsp;Fragment&nbsp;shader&nbsp;in&nbsp;C&nbsp;source:<br />const&nbsp;char*&nbsp;fragment_shader_src&nbsp;=&nbsp;&quot;#version&nbsp;330&nbsp;core\n&quot;<br />	&quot;out&nbsp;vec4&nbsp;FragColor;\n&quot;<br />	&quot;void&nbsp;main()\n&quot;<br />	&quot;{\n&quot;<br />	&quot;&nbsp;&nbsp;&nbsp;FragColor&nbsp;=&nbsp;vec4(1.0f,&nbsp;0.5f,&nbsp;0.2f,&nbsp;1.0f);\n&quot;<br />	&quot;}\n\0&quot;;</div></div><br /><br /><strong><h3>### Compile, Attach, and Link Shaders to Shader Program</h3></strong><br />Compile the shader<br /><div class="codebox"><div class="codebox">unsigned&nbsp;int&nbsp;vertex_shader&nbsp;=&nbsp;glCreateShader(GL_VERTEX_SHADER);<br />glShaderSource(vertex_shader,&nbsp;1,&nbsp;&amp;vertex_shader_src,&nbsp;NULL);<br />glCompileShader(vertex_shader);</div></div><br /><br />Attach and Link Shaders to Shader Program<br /><div class="codebox"><div class="codebox">unsigned&nbsp;int&nbsp;shader_program&nbsp;=&nbsp;glCreateProgram();		//&nbsp;Create&nbsp;a&nbsp;program&nbsp;object<br />glAttachShader(shader_program,&nbsp;vertex_shader);			//&nbsp;Attach&nbsp;shader&nbsp;to&nbsp;program<br />glAttachShader(shader_program,&nbsp;fragment_shader);<br />glLinkProgram(shader_program);</div></div><br /><br />Active the shader program and then delete the shader objects (don&#39;t need them anymore)<br /><div class="codebox"><div class="codebox">glUseProgram(shader_program);</div></div><br /><br /><strong><h3>### Drawing Objects</h3></strong><br />Drawing objects will look something like this:<br /><div class="codebox"><div class="codebox">//&nbsp;0.&nbsp;Copy&nbsp;our&nbsp;vertices&nbsp;array&nbsp;in&nbsp;a&nbsp;buffer&nbsp;for&nbsp;OpenGL&nbsp;to&nbsp;use<br />glBindBuffer(GL_ARRAY_BUFFER,&nbsp;VBO);<br />glBufferData(GL_ARRAY_BUFFER,&nbsp;sizeof(vertices),&nbsp;vertices,&nbsp;GL_STATIC_DRAW);<br />//&nbsp;1.&nbsp;Then&nbsp;set&nbsp;the&nbsp;vertex&nbsp;attributes&nbsp;pointers<br />glVertexAttribPointer(0,&nbsp;3,&nbsp;GL_FLOAT,&nbsp;GL_FALSE,&nbsp;3&nbsp;*&nbsp;sizeof(float),&nbsp;(void*)0);<br />glEnableVertexAttribArray(0);&nbsp;&nbsp;<br />//&nbsp;2.&nbsp;Use&nbsp;our&nbsp;shader&nbsp;program&nbsp;when&nbsp;we&nbsp;want&nbsp;to&nbsp;render&nbsp;an&nbsp;object<br />glUseProgram(shaderProgram);<br />//&nbsp;3.&nbsp;Now&nbsp;draw&nbsp;the&nbsp;object&nbsp;<br />someOpenGLFunctionThatDrawsOurTriangle();&nbsp;</div></div><br /><br />You couldn&#39;t do this for 100s of objects.<br />Instead, you store all the state configurations in an object and bind the object to restore its state.<br />You do this with Vertex Array Objects (VAOs).<br /><br /><strong><h3>### Vertex Array Object</h3></strong><h3> </h3><br />A Vertex Array Object (a VAO) stores vertex attributes.<br />When you want to draw an object with those attributse, you simply bind the corresponding VAO.<br /><br />Vertex Array Objects store the followign:<br />• Calls to <code>glEnableVertexAttribArray</code><br />• Attribute configurations from <code>glVertexAttribPointer</code><br />• Vertex Buffer Objects from <code>glVertexAttribPointer</code><br /><br />Generate a VAO<br /><code>unsigned int VAO = glGenVertexArrays(1, &amp;VAO);</code><br />To use a VAO you bind it<br /><code>glBindVertexArray(VAO);</code><br /><br />Example source code might be:<br /><div class="codebox"><div class="codebox">//&nbsp;1.&nbsp;Bind&nbsp;Vertex&nbsp;Array&nbsp;Object<br />glBindVertexArray(VAO);<br />//&nbsp;2.&nbsp;Copy&nbsp;our&nbsp;vertices&nbsp;array&nbsp;in&nbsp;a&nbsp;buffer&nbsp;for&nbsp;OpenGL&nbsp;to&nbsp;use<br />glBindBuffer(GL_ARRAY_BUFFER,&nbsp;VBO);<br />glBufferData(GL_ARRAY_BUFFER,&nbsp;sizeof(vertices),&nbsp;vertices,&nbsp;GL_STATIC_DRAW);<br />//&nbsp;3.&nbsp;Set&nbsp;our&nbsp;vertex&nbsp;attributes&nbsp;pointers<br />glVertexAttribPointer(0,&nbsp;3,&nbsp;GL_FLOAT,&nbsp;GL_FALSE,&nbsp;3&nbsp;*&nbsp;sizeof(float),&nbsp;(void*)0);<br />glEnableVertexAttribArray(0);&nbsp;&nbsp;<br /><br />//&nbsp;WITHIN&nbsp;RENDER&nbsp;LOOP<br />//&nbsp;4.&nbsp;Draw&nbsp;the&nbsp;object<br />glUseProgram(shaderProgram);<br />glBindVertexArray(VAO);<br />someOpenGLFunctionThatDrawsOurTriangle();&nbsp;&nbsp;</div></div><br /><br />In short, <br />a VAO stores your vertex attribute configration and which Vertex Buffer Object to use.<br /><br /><strong><h3>### Element Buffer Objects</h3></strong><br />OpenGL draws stuff in triangles.<br />If you wanted to draw a rectangle, you&#39;d draw 2 triangles.<br /><br />Here we&#39;ve specified 6 vectors, but you only need 4 to draw a rectangle.<br />With 1000s of objects on the screen, this will decrease performance.<br /><div class="codebox"><div class="codebox">float&nbsp;vertices[]&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;first&nbsp;triangle<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5f,&nbsp;&nbsp;0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;top&nbsp;right<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5f,&nbsp;-0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;bottom&nbsp;right<br />&nbsp;&nbsp;&nbsp;&nbsp;-0.5f,&nbsp;&nbsp;0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;top&nbsp;left&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;second&nbsp;triangle<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5f,&nbsp;-0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;bottom&nbsp;right<br />&nbsp;&nbsp;&nbsp;&nbsp;-0.5f,&nbsp;-0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;bottom&nbsp;left<br />&nbsp;&nbsp;&nbsp;&nbsp;-0.5f,&nbsp;&nbsp;0.5f,&nbsp;0.0f&nbsp;&nbsp;&nbsp;//&nbsp;top&nbsp;left<br />};&nbsp;</div></div><br /><br />The solution is to use an EBO - Element Buffer Object.<br />It stores indices that determine what vertices to draw (and in what order) - indexed drawing.<br /><div class="codebox"><div class="codebox"><br />float&nbsp;vertices[]&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5f,&nbsp;&nbsp;0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;top&nbsp;right<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5f,&nbsp;-0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;bottom&nbsp;right<br />&nbsp;&nbsp;&nbsp;&nbsp;-0.5f,&nbsp;-0.5f,&nbsp;0.0f,&nbsp;&nbsp;//&nbsp;bottom&nbsp;left<br />&nbsp;&nbsp;&nbsp;&nbsp;-0.5f,&nbsp;&nbsp;0.5f,&nbsp;0.0f&nbsp;&nbsp;&nbsp;//&nbsp;top&nbsp;left&nbsp;<br />};<br />unsigned&nbsp;int&nbsp;indices[]&nbsp;=&nbsp;{&nbsp;&nbsp;//&nbsp;note&nbsp;that&nbsp;we&nbsp;start&nbsp;from&nbsp;0!<br />&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;&nbsp;&nbsp;//&nbsp;first&nbsp;triangle<br />&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;2,&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;second&nbsp;triangle<br />};&nbsp;&nbsp;</div></div><br /><br /><a href=""><img src="images/1252-8.png" alt="images/1252-8.png" /></a><br /><br /><strong><h2>## Vectors and Matrices</h2></strong><br /><a href="https://learnopengl.com/Getting-started/Transformations">https://learnopengl.com/Getting-started/Transformations</a><br />Nothing to take note of here, just take the concepts above into your brain.<br /><br /><strong><h2>## Coordinate Systems</h2></strong><br /><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">https://learnopengl.com/Getting-started/Coordinate-Systems</a><br /><br />You use transformation matrices to transform coordinates from one space to the next.<br />The order is:<br />Local coordinates &gt; World coordinates &gt; View coordinates &gt; Clip coordinates &gt; Screen coordinates<br /><br /><strong>Local coordiantes</strong> - where your objects begins.<br /><strong>World space coordinates</strong> - where your object sits in the larger world (relative to world origin).<br /><strong>View-space coordiantes</strong> - where the object is within the camera&#39;s view.<br /><strong>Clip coordiantes</strong> - determines what part of the object shows on the screen (e.g. top cut off)<br /><strong>Screen coordiantes</strong> - translates the 3d coordinates into where the object will sit on your 2d screen<br /><br /><a href=""><img src="images/1252-9.png" alt="images/1252-9.png" /></a><br /><br /></div>
</body>
</html>
