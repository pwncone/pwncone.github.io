<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Imports</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># PE Imports</h1></strong><br />Function imports are stored in the <code>.idata</code> section of PE file.<br />• Chapter 6.4.1 - <a href="http://www.skyfree.org/linux/references/coff.pdf">http://www.skyfree.org/linux/references/coff.pdf</a><br /><br />Import information is stored in the <code>Import Directory Table</code>.<br />The <code>Import Directory Table</code> contains a series of <code>Import Directory Entries</code>, one for each DLL to be imported into the process. In the Windows API, this struct is called <code>IMAGE_IMPORT_DESCRIPTOR</code>.<br /><a href=""><img src="images/1525-1.png" alt="images/1525-1.png" /></a><br /><br />Two important values are included in this struct:<br />• <code>OriginalFirstThunk</code> - points to the Import Lookup Table<br />• <code>FirstThunk</code> - points to the Import Address Table<br /><br />The <code>Import Lookup Table</code><br />stores a list of the functions to import from that DLL (as well as how to import them - by name or by ordinal).<br /><br />The <code>Import Address Table</code><br />gets filled at runtime when the PE loads. It stores the addresses of the imported functions.<br /><br />e.g:<br />• The Import Lookup Table stores <code>MessageBoxA</code> (the function to import)<br />• The Import Address Table gets filled at runtime and stores <code>0x00007FF9CF49AA70</code> (the address of MessaegBoxA)<br /><br /><a href=""><img src="images/1525-2.png" alt="images/1525-2.png" /></a><br /><br />Here&#39;s a more detailed diagram from Reverse Engineering for Beginners by Dennis Yurichev.<br /><a href=""><img src="images/1525-3.png" alt="images/1525-3.png" /></a><br /><br /><strong><h2>## Info on the Import Structs</h2></strong><br />These can help you understand how imports work a little easier.<br />Also here for future reference when you write code as some of these structs are undocumented.<br /><br />You can grab the first entry in the Import Directory Table like this:<br /><code>PIMAGE_IMPORT_DESCRIPTOR import_directory = IMAGE_NT_HEADER-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)</code><br /><br /><strong><h3>### IMAGE_IMPORT_DESCRIPTOR</h3></strong><br />The <code>IMAGE_IMPORT_DESCRIPTOR</code> struct is for each DLL to be imported by the process.<br />It contains the DLL name, a pointer to the Import Lookup Table, and a pointer to the Import Address Table.<br /><br /><div class="codebox"><div class="codebox">typedef&nbsp;struct&nbsp;_IMAGE_IMPORT_DESCRIPTOR&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;Characteristics;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;OriginalFirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;RVA&nbsp;to&nbsp;Import&nbsp;Lookup&nbsp;Table&nbsp;(Characteristics)<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;DUMMYUNIONNAME;<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;TimeDateStamp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;0&nbsp;until&nbsp;bound;&nbsp;then&nbsp;becomes&nbsp;timestamp&nbsp;of&nbsp;DLL<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;ForwarderChain;<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;Name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;address&nbsp;of&nbsp;DLL&nbsp;name&nbsp;relative&nbsp;to&nbsp;image&nbsp;base<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;FirstThunk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;RVA&nbsp;to&nbsp;Import&nbsp;Address&nbsp;Table&nbsp;(Thunk&nbsp;table)<br />}&nbsp;IMAGE_IMPORT_DESCRIPTOR;</div></div><br /><br /><strong><h3>### IMAGE_THUNK_DATA and the Import Lookup Table</h3></strong><br />The Import Lookup Table information is contained in an <code>IMAGE_THUNK_DATA</code> struct.<br />It describes whether a function is imported by ordinal or name.<br /><br />For 32bit PEs this is a 32bit field.<br />For 64bit PEs this is a 64bit field.<br /><br />The last bit in the field is the most significant bit<br />• <code>31</code> for 32bit<br />• <code>63</code> for 64bit<br /><br />• Bit 31 / 63, the most significant bit, describes whether the function is imported by ordinal<br />   ◇ <code>1</code> if import by ordinal<br />   ◇ <code>0</code> if import by name<br />• Bits 30 - 0 / 62 - 0 are either the <br />   ◇ ordinal number <br />   ◇ or the address of a function name table containing the function name, relative to image base<br /><br />Check if function is imported by ordinal:<br /><code>IMAGE_SNAP_BY_ORDINAL(import_lookup_table-&gt;u1.Ordinal);</code><br /><br />If a function is imported by name, you can grab a pointer to a struct containing the name:<br /><code>PIMAGE_IMPORT_BY_NAME import_name = file_buffer + import_lookup_table-&gt;u1.AddressOfData</code><br /><br />Name is located here:<br /><code>import_name-&gt;Name;</code><br /><br /><div class="codebox"><div class="codebox">typedef&nbsp;struct&nbsp;_IMAGE_THUNK_DATA64&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONGLONG&nbsp;ForwarderString;&nbsp;&nbsp;//&nbsp;PBYTE&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONGLONG&nbsp;Function;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PDWORD&nbsp;-&nbsp;store&nbsp;address&nbsp;of&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONGLONG&nbsp;Ordinal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;whether&nbsp;import&nbsp;by&nbsp;ordinal&nbsp;or&nbsp;name<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONGLONG&nbsp;AddressOfData;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;pointer&nbsp;to&nbsp;PIMAGE_IMPORT_BY_NAME<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;u1;<br />}&nbsp;IMAGE_THUNK_DATA64;<br />typedef&nbsp;IMAGE_THUNK_DATA64&nbsp;*&nbsp;PIMAGE_THUNK_DATA64;</div></div><br /><br /><strong><h3>### IMAGE_THUNK_DATA and the Import Address Table</h3></strong><br />The Import Address Table is just like the Import Lookup Table, except that it gets filled at runtime with the address of the imported function.<br /><code>Function</code> stores the address of the function.<br /><br /><strong><h2>## Fixing Imports Manually</h2></strong><br />Fixing imports is about writing the address of the imported function into the Import Address Table.<br /><br />For example,<br />our DLL (<code>dll_hello.dll</code>) imports <code>MessageBoxW</code>.<br />The Import Address Table of our DLL says that <code>MessageBoxW</code> is at offset <code>0x260c</code>.<br /><a href=""><img src="images/1525-4.png" alt="images/1525-4.png" /></a><br /><br />When this DLL gets loaded by the Windows loader,<br />it will write the correct address for <code>MessageBoxW</code> in <code>User32.dll</code> into the Import Address Table - <code>0x75511490</code>.<br /><br />To do this process yourself you can simply load <code>USER32.dll</code> with <code>LoadLIbrary</code>, <br />and use <code>GetProcAddress</code> to find the address of <code>MessageBoxW</code> inside <code>USER32.dll</code>.<br />Afterwards, you would do as the windows loader does and write <code>MessageBoxW</code>&#39;S address - <code>0x75511490</code> - into your DLL&#39;s Import Address Table.<br /><a href=""><img src="images/1525-5.png" alt="images/1525-5.png" /></a><br /><br />Now our DLL will look for <code>MessageBoxW</code> at <code>0x75511490</code> instead of <code>0x260c</code>, and <code>MessageBoxW</code> will successfully run.<br /><br />This works because <code>User32.dll</code>, <code>Kernel32.dll</code>, etc., are loaded at the same address in every process.<br />In the image below, you can see that in both <code>mspaint.exe</code> and <code>notepad.exe</code>, <code>User32.dll</code> is loaded at <code>0x75490000</code>.<br /><a href=""><img src="images/1525-6.png" alt="images/1525-6.png" /></a><br /><br />Therefore, as long as <code>User32.dll</code> is loaded into the process, <code>MessageBoxW</code> will be located at <code>0x75511490</code> every time. </div>
</body>
</html>
