<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ASLR</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Exploit Protections - ASLR</h1></strong><br />• <a href="https://ocw.cs.pub.ro/courses/cns/labs/lab-08">https://ocw.cs.pub.ro/courses/cns/labs/lab-08</a><br />• <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br />• <a href="https://docs.oracle.com/cd/E37670_01/E36387/html/ol_aslr_sec.html">https://docs.oracle.com/cd/E37670_01/E36387/html/ol_aslr_sec.html</a><br /><br />ASLR stands for Address Space Layout Randomisation.<br /><br />ASLR randomises the addresses of the stack, the heap, the shared libraries, the data segment etc. within a process&#39;s address space. Since the addresses of each of these sections are now random, you can&#39;t hard-code addresses into your exploit anymore because the values will be different every time.<br /><br />Program code, the .text section, is only randomised if the program is compiled as a Position Independent Executable - PIE.<br />• Shared libraries, by default, are compiled with PIE.<br />• Whereas program code is usually placed at fixed addresses (unless compiled using PIE option)<br /><br />Randomisation occurs at <strong>load-time</strong>, which means that the segment addresses <strong>do not</strong> change while the process is running.<br /><br /><strong><h2>## ASLR and Shared Libraries</h2></strong><br />With ASLR enabled, a library&#39;s base address is randomised.<br />However, the offset to a function from the base address remains consistent.<br /><br /><em><strong>For example</strong></em><br />1st run<br />• libc&#39;s base address is <code>0x0000454443424100</code><br />• The offset to libc&#39;s system() function from the libc base address is <code>0x99</code> - this will remain consistent every time<br />• The libc system() function, on this run of the binary, lives at <code>0x0000454443424199</code><br /><br />2nd run<br />• libc&#39;s base address has changed because of ASLR - <code>0x0000353433323100</code><br />• But the offset to libc system() is still <code>0x99</code><br />• On this run of the binary, libc system() lives at <code>0x0000353433323199</code><br /><br /><strong><h2>## Checking for ASLR</h2></strong><br />There&#39;s 2 ways to check if ASLR is enabled on the target system<br /><code>sysctl -a --pattern &quot;randomize&quot;</code><br /><code>cat /proc/sys/kernel/randomize_va_space</code><br /><br /><strong><h2>## /proc/sys/kernel/randomize_va_space</h2></strong><br />ASLR is built into the Linux kernel and is controlled by the parameter <code>/proc/sys/kernel/randomize_va_space</code><br /><br /><code>cat /proc/sys/kernel/randomize_va_space</code><br /><br /><strong>0 = Disabled</strong><br />ASLR is non-existent (hurrah!)<br /><br /><strong>1 = Enabled</strong><br />The stack, virtual dynamic shared object (VDSO) page, and libraries are randomised.<br />The base address of the data segment gets located immediately after the end of the executable code segment.<br /><br /><strong>2 = Enabled (default setting)</strong><br />The stack, virtual dynamic shared object (VDSO) page, libraries AND THE DATA SEGMENT are randomised.<br /><br /><strong><h2>## Enabling &amp; Disabling ASLR</h2></strong><br />You can change the setting of ASLR by writing to <code>/proc/sys/kernel/randomize_va_space</code><br /><br />Disable - <code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code><br />Enable  - <code>echo 2 &gt; /proc/sys/kernel/randomize_va_space</code><br /><br />To change the value permanently, add the setting to <code>/etc/sysctl.conf</code>:<br /><code>kernel.randomize_va_space = 0</code><br />and run the <code>sysctl -p</code> command.<br /><br /><strong>gdb-peda</strong><br />ASLR is by default disabled within GDB PEDA. To turn ASLR on in GDB PEDA run:<br /><code>gdb-peda$ aslr on </code><br /><br /><strong>gdb</strong><br />Enable ASLR - <code>(gdb) set disable-randomization off</code><br /><br /><strong><h2>## Bypassing ASLR</h2></strong><br /><strong><h3>### Bruteforce</h3></strong><br />If you can run your payload against the binary multiple times without it crashing/crashing the system, you can run your exploit over and over again using the initial addresses/values you got from reconaissance until the exploit finally works (because the values you were targeting actually resided at the addresses you hard-coded).<br /><br /><a href="https://en.wikipedia.org/wiki/Return-oriented_programming#On_address_space_layout_randomization">https://en.wikipedia.org/wiki/Return-oriented_programming#On_address_space_layout_randomization</a><br /><br /><strong>32-bit</strong><br />On 32-bit systems, only 16 of the 32 address bits are available for randomisation<br />This makes ASLR trivial to bruteforce - can be done in minutes<br /><code>((i=0)); while true; do echo $i; ./binary $(python exploit.py); ((i=i+1)); done</code><br /><br /><strong>64-bit</strong><br />On 64-bit systems, 40 of the 64 address bits are available for randomisation<br />A bruteforce attack for 40-bit randomisation is possible - but it&#39;s loud/long/won&#39;t go unnoticed<br />It&#39;s better to find other ways to bypass ASLR on 64-bit systems, but bruteforce is still an option<br /><br /><strong><h3>### Trying to execute shellcode? Build a huge NOP sled</h3></strong><br />If you create a large enough NOP sled, you increase your chances of jumping right into the NOP sled and riding straight down to your shellcode, even if the stack is randomised<br /><br /><strong><h3>### Reduce entropy/randomness</h3></strong><br />You can use various methods to reduce the amount of addresses that can be randomised<br />e.g. decrease the initial stack size by setting a huge amount of bogus environment variables<br /><br /><strong><h3>### Leak address from the GOT Table</h3></strong><br />This is the most effective way of bypassing ASLR.<br /><br />Knowing that offsets to functions within a library remain consistent, if we can leak the address of a libc function from the GOT table, we can subtract its offset from the address we leak to find libc&#39;s base address.<br /><br /><em><strong>Example</strong></em><br />We leak the address of system() from the GOT - <code>0x0000454443424199</code><br />We&#39;ve read libc on the target system and know that the offset to system() from libc&#39;s base address is <code>0x99</code><br />Therefore, to find libc&#39;s base address:<br />• leaked address - offset = libc&#39;s base address<br />• <code>0x0000454443424199</code> - <code>0x99</code> = <code>0x0000454443424100</code><br />• <code>0x0000454443424100</code> is libc&#39;s base addres<br /><br /><strong>#### How to Use the Leaked Address to make ASLR Completely Redundant</strong><br />Now that we know libc&#39;s base address, using the offsets in the libc library on the target system, we can calculate the location of any libc library function on the system.<br /><br />e.g. You read the libc library on the target system and find the offset to <code>setuid()</code> - <code>0x78</code><br />libc&#39;s base address + setuid() offset = setuid() location<br /><code>0x0000454443424100</code> + <code>0x78</code> = <code>0x0000454443424178</code><br /></div>
</body>
</html>
