<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Encrypt Data</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Encrypting Data</h1></strong><br />The size of the block you&#39;re encrypting must be a multiple of the block size.<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-encrypting-a-file">https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-encrypting-a-file</a><br /><br /><strong><h2>## Encrypting block by block</h2></strong><br />First calculate the block size you&#39;ll read (the amount of data to crypt at a time)<br />Next, open a handle to the infile and outfile, read a block of data from the infile, crypt it, and write it to the outfile.<br />If the amount of data you&#39;ve read is equal to the size of the infile, you&#39;re encrypting the last block.<br /><br />Example below is for AES.<br />If you&#39;re using a stream cipher (like RC4), which encrypt the entire file at once rather than in blocks, you can set the BLOCKSIZE to 1.<br /><br /><div class="codebox"><div class="codebox">#define&nbsp;AES_BLOCKSIZE&nbsp;128<br />HANDLE&nbsp;h_infile&nbsp;=&nbsp;NULL;<br />HANDLE&nbsp;h_outfile&nbsp;=&nbsp;NULL;<br />DWORD&nbsp;infile_size&nbsp;=&nbsp;0;<br />DWORD&nbsp;buf_size&nbsp;=&nbsp;0;<br />void*&nbsp;tmp_buf&nbsp;=&nbsp;NULL;<br /><br />h_infile&nbsp;=&nbsp;CreateFileA(infile,&nbsp;GENERIC_READ,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />infile_size&nbsp;=&nbsp;GetFileSize(h_infile,&nbsp;NULL);<br />h_outfile&nbsp;=&nbsp;CreateFileA(outfile,&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br /><br />/*<br />Determine&nbsp;max&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;encrypt/decrypt&nbsp;at&nbsp;a&nbsp;time<br />It&nbsp;must&nbsp;be&nbsp;a&nbsp;multiple&nbsp;of&nbsp;BLOCKSIZE<br />If&nbsp;encrypting,&nbsp;need&nbsp;extra&nbsp;space&nbsp;in&nbsp;buffer&nbsp;for&nbsp;padding&nbsp;(easy&nbsp;solution&nbsp;is&nbsp;to&nbsp;add&nbsp;another&nbsp;BLOCKSIZE)<br />Calculation&nbsp;from&nbsp;here:<br />https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-encrypting-a-file<br />*/<br />DWORD&nbsp;bytes_to_read&nbsp;=&nbsp;1024&nbsp;-&nbsp;1024&nbsp;%&nbsp;AES_BLOCKSIZE;	//&nbsp;will&nbsp;equal&nbsp;1024&nbsp;if&nbsp;BLOCKSIZE&nbsp;is&nbsp;0&nbsp;or&nbsp;1<br />if&nbsp;(encrypt&nbsp;==&nbsp;TRUE&nbsp;&amp;&amp;&nbsp;AES_BLOCKSIZE&nbsp;&gt;&nbsp;1)<br />	buf_size&nbsp;=&nbsp;bytes_to_read&nbsp;+&nbsp;AES_BLOCKSIZE;<br />else<br />	buf_size&nbsp;=&nbsp;bytes_to_read;<br /><br />//&nbsp;Allocate&nbsp;buffer&nbsp;to&nbsp;store&nbsp;crypted&nbsp;data<br />tmp_buf&nbsp;=&nbsp;malloc(buf_size);<br /><br />//&nbsp;Read&nbsp;infile&nbsp;block&nbsp;by&nbsp;block,&nbsp;encrypt/decrypt,&nbsp;and&nbsp;write&nbsp;data&nbsp;out&nbsp;to&nbsp;outfile<br />DWORD&nbsp;bytes_read&nbsp;=&nbsp;0;<br />DWORD&nbsp;total_read&nbsp;=&nbsp;0;<br /><br />BOOL&nbsp;end_of_file&nbsp;=&nbsp;FALSE;<br />while&nbsp;(end_of_file&nbsp;==&nbsp;FALSE)<br />{<br />	ReadFile(h_infile,&nbsp;tmp_buf,&nbsp;bytes_to_read,&nbsp;&amp;bytes_read,&nbsp;NULL);<br />	<br />	total_read&nbsp;+=&nbsp;bytes_read;<br />	if&nbsp;(total_read&nbsp;==&nbsp;infile_size)<br />		end_of_file&nbsp;=&nbsp;TRUE;<br /><br />	if&nbsp;(encrypt&nbsp;==&nbsp;TRUE)<br />		CryptEncrypt(h_key,&nbsp;0,&nbsp;end_of_file,&nbsp;0,&nbsp;tmp_buf,&nbsp;&amp;bytes_read,&nbsp;buf_size);<br />	else&nbsp;if&nbsp;(decrypt&nbsp;==&nbsp;TRUE)<br />		CryptDecrypt(h_key,&nbsp;0,&nbsp;end_of_file,&nbsp;0,&nbsp;tmp_buf,&nbsp;&amp;bytes_read);<br /><br />	WriteFile(h_outfile,&nbsp;tmp_buf,&nbsp;bytes_read,&nbsp;NULL,&nbsp;NULL);<br />}<br /></div></div><br /><br /><strong><h2>## Encrypting All Data At Once</h2></strong><br />You can also encrypt the file all at once (typically but done for strings)<br />(Not sure if this is recommended, haven&#39;t seen MSDN do it, but there&#39;s no reason why not as far as I know)<br /><br />Call <code>CryptEncrypt</code> once with NULL to get the size of the encrypted data,<br />allocate a buffer large enough to store the encrypted data,<br />and then call <code>CryptEncrypt</code> again to encrypt the data.<br /><br />If problems, try reading these:<br />• <a href="https://stackoverflow.com/questions/40238501/windows-cryptoapi-symmetric-encoding-decoding-block-that-already-aligning">https://stackoverflow.com/questions/40238501/windows-cryptoapi-symmetric-encoding-decoding-block-that-already-aligning</a><br />• <a href="https://stackoverflow.com/questions/9091108/cryptencrypt-aes-256-fails-at-encrypting-last-block">https://stackoverflow.com/questions/9091108/cryptencrypt-aes-256-fails-at-encrypting-last-block</a><br /><br /><div class="codebox"><div class="codebox">void*&nbsp;filebuf&nbsp;=&nbsp;NULL;&nbsp;		//&nbsp;contains&nbsp;the&nbsp;file&nbsp;to&nbsp;encrypt/decrypt<br />DWORD&nbsp;filebuf_size&nbsp;=&nbsp;infile_size;<br />DWORD&nbsp;outfile_size&nbsp;=&nbsp;0;<br />DWORD&nbsp;data_len&nbsp;=&nbsp;0;<br />if&nbsp;(encrypt&nbsp;==&nbsp;TRUE)<br />{<br />	/*<br />	Run&nbsp;CryptEncrypt&nbsp;once&nbsp;to&nbsp;grab&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;encrypted&nbsp;data.<br />	On&nbsp;input,&nbsp;bytes_required&nbsp;provides&nbsp;the&nbsp;plaintext&nbsp;data&nbsp;length<br />	On&nbsp;ouptut,&nbsp;it&nbsp;stores&nbsp;the&nbsp;ciphertext&nbsp;length<br />	*/<br />	outfile_size&nbsp;=&nbsp;infile_size;<br />	CryptEncrypt(h_key,&nbsp;0,&nbsp;TRUE,&nbsp;0,&nbsp;NULL,&nbsp;&amp;outfile_size,&nbsp;0);<br /><br />	//&nbsp;Resize&nbsp;memory&nbsp;buffer&nbsp;to&nbsp;store&nbsp;encrypted&nbsp;data<br />	filebuf&nbsp;=&nbsp;realloc(filebuf,&nbsp;outfile_size);<br />	filebuf_size&nbsp;=&nbsp;outfile_size;<br /><br />	/*<br />	Encrypt&nbsp;data&nbsp;in&nbsp;one&nbsp;whole&nbsp;block<br />	On&nbsp;input,&nbsp;data_len&nbsp;provides&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;data&nbsp;to&nbsp;encrypt.<br />	On&nbsp;output,&nbsp;it&nbsp;stores&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;encrypted&nbsp;data.<br />	*/<br />	data_len&nbsp;=&nbsp;infile_size;<br />	CryptEncrypt(h_key,&nbsp;0,&nbsp;TRUE,&nbsp;0,&nbsp;filebuf,&nbsp;&amp;data_len,&nbsp;filebuf_size);<br />}<br />else&nbsp;if&nbsp;(decrypt&nbsp;==&nbsp;TRUE)<br /><span style="color:#000000;font-weight:400">{</span><br />	CryptDecrypt(h_key,&nbsp;0,&nbsp;TRUE,&nbsp;0,&nbsp;filebuf,&nbsp;&amp;infile_size);<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
