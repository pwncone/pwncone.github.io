<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>IRP and IOCTRL Codes</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># IRP and IOCTRL Codes</h1></strong><br />• <a href="https://ericasselin.com/userlandkernel-communication-deviceiocontrol-method">https://ericasselin.com/userlandkernel-communication-deviceiocontrol-method</a><br />• <a href="https://www.drdobbs.com/windows/sending-ioctls-to-windows-nt-drivers/184416453">https://www.drdobbs.com/windows/sending-ioctls-to-windows-nt-drivers/184416453</a><br />• <a href="https://cylus.org/windows-drivers-part-2-ioctls-c678526f90ae">https://cylus.org/windows-drivers-part-2-ioctls-c678526f90ae</a><br />• <a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl</a><br /><br />This is the default/standard kerneland userland communication method described by MSDN.<br /><br />Communication between kernel drivers and userland applications use a system called <code>IRP</code> - <code>I/O Request Packets</code><br /><br />Kernel drivers define a set of I/O Control Codes.<br />Userland applications can request the kernel driver to do something by sending it one of those control codes.<br /><br />For example:<br />I&#39;ve set some custom I/O control codes in my kernel driver:<br />• <code>0x801</code> means open a file<br />• <code>0x802</code> means add some numbers together<br />• <code>0x803</code> means modify the network adapter for me<br /><br />My userland application opens a handle to my driver with <code>CreateFile</code>,<br />and submits the control code <code>0x802</code> to the kernel driver using the <code>DeviceIoControl</code> function.<br /><br />My kernel driver checks what control code it has been sent,<br />and executes the code/functions corresponding to control code <code>0x802</code> (add some numbers together)<br /><br />My kernel driver then reports back whether it succeeded,<br />provides any extra information,<br />and completes the request - at which point my userland application receives the result.<br /><br />That&#39;s it.<br /><br />I encourage you to read MSDN for a little more info:<br />• IRP - <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/i-o-request-packets">https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/i-o-request-packets</a><br />• Defining I/O control codes - <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes</a><br /><br /><strong><h2>## How-to: Kernel Land</h2></strong><br />First we must declare a name for our driver, <br />otherwise we wouldn&#39;t be able to get a handle to it from userland.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;ntddk.h&gt;<br />#include&nbsp;&lt;wdf.h&gt;<br /><br />UNICODE_STRING&nbsp;DEVICE_NAME&nbsp;=&nbsp;RTL_CONSTANT_STRING(L&quot;\\Device\\Moogle&quot;);<br />UNICODE_STRING&nbsp;DEVICE_SYMBOLIC_LINK&nbsp;=&nbsp;RTL_CONSTANT_STRING(L&quot;\\DosDevices\\MoogleSymbolicLink&quot;);</div></div><br /> <br />You can find your device in WinObj when your driver has been loaded.<br /><a href=""><img src="images/1813-1.png" alt="images/1813-1.png" /></a><br /><br />Next we define a set of I/O Control Codes.<br />Values less than <code>0x800</code> are reserved for Microsoft. Values higher than <code>0x800</code> are for use by vendors.<br />For an explanation of the other parameters, refer here:<br />• <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes</a><br /><div class="codebox"><div class="codebox">//&nbsp;I/O&nbsp;control&nbsp;codes<br />#define&nbsp;IO_CODE_SENDMESSAGE&nbsp;CTL_CODE<span style="color:#000000;font-weight:400">(</span>FILE_DEVICE_UNKNOWN,&nbsp;0x801,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS<span style="color:#000000;font-weight:400">)</span></div></div><br /><br />Next we create functions that run when a handle is opened to our driver, and when a handle is closed.<br />At the moment they does nothing, but it&#39;s good practice to have them.<br /><div class="codebox"><div class="codebox">/*<br />When&nbsp;a&nbsp;handle&nbsp;to&nbsp;the&nbsp;driver&nbsp;is&nbsp;created.<br />*/<br />NTSTATUS&nbsp;MJ_Create(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br />{<br />	UNREFERENCED_PARAMETER(DeviceObject);<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	//PIO_STACK_LOCATION&nbsp;stack_location&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br /><br />	DbgPrint(&quot;[i]&nbsp;handle&nbsp;created&nbsp;to&nbsp;device&nbsp;\n&quot;);<br /><br />	Irp-&gt;IoStatus.Status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	Irp-&gt;IoStatus.Information&nbsp;=&nbsp;0;<br />	IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br /><br />	return&nbsp;nt_status;<br />}<br /><br />/*<br />When&nbsp;a&nbsp;handle&nbsp;to&nbsp;the&nbsp;driver&nbsp;is&nbsp;closed.<br />*/<br />NTSTATUS&nbsp;MJ_Close(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br /><span style="color:#000000;font-weight:400">{</span><br />	UNREFERENCED_PARAMETER(DeviceObject);<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	//PIO_STACK_LOCATION&nbsp;stack_location&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br /><br />	DbgPrint(&quot;[i]&nbsp;handle&nbsp;to&nbsp;device&nbsp;closed&nbsp;\n&quot;);<br /><br />	Irp-&gt;IoStatus.Status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	Irp-&gt;IoStatus.Information&nbsp;=&nbsp;0;<br />	IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br /><br />	return&nbsp;nt_status;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />After that we create our function to handle I/O Control Codes.<br />It&#39;s simply an <code>if</code> statement that handles our Control Code and executes code.<br /><div class="codebox"><div class="codebox">NTSTATUS&nbsp;IoControl(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br /><span style="color:#000000;font-weight:400">{</span><br />	UNREFERENCED_PARAMETER(DeviceObject);<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	PIO_STACK_LOCATION&nbsp;stack_location&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br />	char*&nbsp;message_from_kernel&nbsp;=&nbsp;&quot;much&nbsp;hello&nbsp;from&nbsp;the&nbsp;kernel&nbsp;:)&quot;;<br /><br />	//&nbsp;grab&nbsp;control&nbsp;code<br />	ULONG&nbsp;io_control_code&nbsp;=&nbsp;stack_location-&gt;Parameters.DeviceIoControl.IoControlCode;<br /><br />	if&nbsp;(io_control_code&nbsp;==&nbsp;IO_CODE_SENDMESSAGE)<br />	{<br />		DbgPrint(&quot;[+]&nbsp;device&nbsp;received&nbsp;code:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;io_control_code);<br />		DbgPrint(&quot;[*]&nbsp;data&nbsp;from&nbsp;userland:&nbsp;%s&nbsp;\n&quot;,&nbsp;(char*)Irp-&gt;AssociatedIrp.SystemBuffer);<br /><br />		RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer,&nbsp;message_from_kernel,&nbsp;strlen(Irp-&gt;AssociatedIrp.SystemBuffer));<br />		DbgPrint(&quot;[+]&nbsp;sent&nbsp;message&nbsp;to&nbsp;userland:&nbsp;%s&nbsp;\n&quot;,&nbsp;message_from_kernel);<br />	}<br /><br />	Irp-&gt;IoStatus.Status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	Irp-&gt;IoStatus.Information&nbsp;=&nbsp;strlen(message_from_kernel);<br />	IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br /><br />	return&nbsp;nt_status;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Now we create <code>DriverEntry</code>. <br />In <code>DriverEntry</code> you create the I/O Device and its Symbolic Link, <br />as well as point our driver to all of our custom functions for handle creation, handle closure, etc.<br /><div class="codebox"><div class="codebox">NTSTATUS&nbsp;DriverEntry(PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br /><span style="color:#000000;font-weight:400">{</span><br />	UNREFERENCED_PARAMETER(RegistryPath);<br /><br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br /><br />	//&nbsp;create&nbsp;IO&nbsp;device&nbsp;and&nbsp;symbolic&nbsp;link<br />	nt_status&nbsp;=&nbsp;IoCreateDevice(DriverObject,&nbsp;0,&nbsp;&amp;DEVICE_NAME,&nbsp;FILE_DEVICE_UNKNOWN,&nbsp;FILE_DEVICE_SECURE_OPEN,&nbsp;FALSE,&nbsp;&amp;DriverObject-&gt;DeviceObject);<br />	DbgPrint(&quot;[i]&nbsp;created&nbsp;device&nbsp;%wZ&nbsp;\n&quot;,&nbsp;DEVICE_NAME);<br /><br />	nt_status&nbsp;=&nbsp;IoCreateSymbolicLink(&amp;DEVICE_SYMBOLIC_LINK,&nbsp;&amp;DEVICE_NAME);<br />	DbgPrint(&quot;[i]&nbsp;created&nbsp;symbolic&nbsp;link&nbsp;%wZ&nbsp;\n&quot;,&nbsp;DEVICE_SYMBOLIC_LINK);<br /><br />	//&nbsp;callback&nbsp;functions<br />	DriverObject-&gt;DriverUnload&nbsp;=&nbsp;DriverUnload;<br />	DriverObject-&gt;MajorFunction[IRP_MJ_CREATE]&nbsp;=&nbsp;MJ_Create;				//&nbsp;function&nbsp;to&nbsp;run&nbsp;when&nbsp;handle&nbsp;to&nbsp;our&nbsp;device&#39;s&nbsp;symbol&nbsp;is&nbsp;opened<br />	DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE]&nbsp;=&nbsp;MJ_Close;				//&nbsp;function&nbsp;to&nbsp;run&nbsp;when&nbsp;handle&nbsp;to&nbsp;our&nbsp;device&#39;s&nbsp;symbol&nbsp;is&nbsp;closed<br />	DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]&nbsp;=&nbsp;IoControl;		//&nbsp;function&nbsp;to&nbsp;handle&nbsp;IO&nbsp;requests&nbsp;from&nbsp;userland<br /><br />	DbgPrint(&quot;[i]&nbsp;driver&nbsp;loaded&nbsp;\n&quot;);<br /><br />	return&nbsp;nt_status;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />Lastly we write our DriverUnload function, which simply deletes the device and it&#39;s symbolic link.<br /><div class="codebox"><div class="codebox">void&nbsp;DriverUnload(PDRIVER_OBJECT&nbsp;DriverObject)<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;delete&nbsp;device&nbsp;and&nbsp;symbolic&nbsp;link<br />	IoDeleteSymbolicLink(&amp;DEVICE_SYMBOLIC_LINK);<br />	IoDeleteDevice(DriverObject-&gt;DeviceObject);<br /><br />	DbgPrint(&quot;[i]&nbsp;driver&nbsp;unloaded&nbsp;\n&quot;);<br /><br />	return;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### Example Kernel Land Code</h3></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;ntddk.h&gt;<br />#include&nbsp;&lt;wdf.h&gt;<br /><br />UNICODE_STRING&nbsp;DEVICE_NAME&nbsp;=&nbsp;RTL_CONSTANT_STRING(L&quot;\\Device\\Moogle&quot;);<br />UNICODE_STRING&nbsp;DEVICE_SYMBOLIC_LINK&nbsp;=&nbsp;RTL_CONSTANT_STRING(L&quot;\\DosDevices\\MoogleSymbolicLink&quot;);<br /><br />//&nbsp;I/O&nbsp;control&nbsp;codes<br />#define&nbsp;IO_CODE_SENDMESSAGE&nbsp;CTL_CODE(FILE_DEVICE_UNKNOWN,&nbsp;0x801,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS)<br /><br />/*<br />When&nbsp;a&nbsp;handle&nbsp;to&nbsp;the&nbsp;driver&nbsp;is&nbsp;created.<br />*/<br />NTSTATUS&nbsp;MJ_Create(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br />{<br />	UNREFERENCED_PARAMETER(DeviceObject);<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	//PIO_STACK_LOCATION&nbsp;stack_location&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br /><br />	DbgPrint(&quot;[i]&nbsp;handle&nbsp;created&nbsp;to&nbsp;device&nbsp;\n&quot;);<br /><br />	Irp-&gt;IoStatus.Status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	Irp-&gt;IoStatus.Information&nbsp;=&nbsp;0;<br />	IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br /><br />	return&nbsp;nt_status;<br />}<br /><br />/*<br />When&nbsp;a&nbsp;handle&nbsp;to&nbsp;the&nbsp;driver&nbsp;is&nbsp;closed.<br />*/<br />NTSTATUS&nbsp;MJ_Close(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br />{<br />	UNREFERENCED_PARAMETER(DeviceObject);<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	//PIO_STACK_LOCATION&nbsp;stack_location&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br /><br />	DbgPrint(&quot;[i]&nbsp;handle&nbsp;to&nbsp;device&nbsp;closed&nbsp;\n&quot;);<br /><br />	Irp-&gt;IoStatus.Status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	Irp-&gt;IoStatus.Information&nbsp;=&nbsp;0;<br />	IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br /><br />	return&nbsp;nt_status;<br />}<br /><br />NTSTATUS&nbsp;IoControl(PDEVICE_OBJECT&nbsp;DeviceObject,&nbsp;PIRP&nbsp;Irp)<br />{<br />	UNREFERENCED_PARAMETER(DeviceObject);<br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	PIO_STACK_LOCATION&nbsp;stack_location&nbsp;=&nbsp;IoGetCurrentIrpStackLocation(Irp);<br />	char*&nbsp;message_from_kernel&nbsp;=&nbsp;&quot;much&nbsp;hello&nbsp;from&nbsp;the&nbsp;kernel&nbsp;:)&quot;;<br /><br />	//&nbsp;grab&nbsp;control&nbsp;code<br />	ULONG&nbsp;io_control_code&nbsp;=&nbsp;stack_location-&gt;Parameters.DeviceIoControl.IoControlCode;<br /><br />	if&nbsp;(io_control_code&nbsp;==&nbsp;IO_CODE_SENDMESSAGE)<br />	{<br />		DbgPrint(&quot;[+]&nbsp;device&nbsp;received&nbsp;code:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;io_control_code);<br />		DbgPrint(&quot;[*]&nbsp;data&nbsp;from&nbsp;userland:&nbsp;%s&nbsp;\n&quot;,&nbsp;(char*)Irp-&gt;AssociatedIrp.SystemBuffer);<br /><br />		RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer,&nbsp;message_from_kernel,&nbsp;strlen(message_from_kernel));<br />		DbgPrint(&quot;[+]&nbsp;sent&nbsp;message&nbsp;to&nbsp;userland:&nbsp;%s&nbsp;\n&quot;,&nbsp;message_from_kernel);<br />	}<br /><br />	Irp-&gt;IoStatus.Status&nbsp;=&nbsp;STATUS_SUCCESS;<br />	Irp-&gt;IoStatus.Information&nbsp;=&nbsp;strlen(message_from_kernel);<br />	IoCompleteRequest(Irp,&nbsp;IO_NO_INCREMENT);<br /><br />	return&nbsp;nt_status;<br />}<br /><br />void&nbsp;DriverUnload(PDRIVER_OBJECT&nbsp;DriverObject)<br />{<br />	//&nbsp;delete&nbsp;device&nbsp;and&nbsp;symbolic&nbsp;link<br />	IoDeleteSymbolicLink(&amp;DEVICE_SYMBOLIC_LINK);<br />	IoDeleteDevice(DriverObject-&gt;DeviceObject);<br /><br />	DbgPrint(&quot;[i]&nbsp;driver&nbsp;unloaded&nbsp;\n&quot;);<br /><br />	return;<br />}<br /><br />NTSTATUS&nbsp;DriverEntry(PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br /><span style="color:#000000;font-weight:400">{</span><br />	UNREFERENCED_PARAMETER(RegistryPath);<br /><br />	NTSTATUS&nbsp;nt_status&nbsp;=&nbsp;STATUS_SUCCESS;<br /><br />	//&nbsp;create&nbsp;IO&nbsp;device&nbsp;and&nbsp;symbolic&nbsp;link<br />	nt_status&nbsp;=&nbsp;IoCreateDevice(DriverObject,&nbsp;0,&nbsp;&amp;DEVICE_NAME,&nbsp;FILE_DEVICE_UNKNOWN,&nbsp;FILE_DEVICE_SECURE_OPEN,&nbsp;FALSE,&nbsp;&amp;DriverObject-&gt;DeviceObject);<br />	DbgPrint(&quot;[i]&nbsp;created&nbsp;device&nbsp;%wZ&nbsp;\n&quot;,&nbsp;DEVICE_NAME);<br /><br />	nt_status&nbsp;=&nbsp;IoCreateSymbolicLink(&amp;DEVICE_SYMBOLIC_LINK,&nbsp;&amp;DEVICE_NAME);<br />	DbgPrint(&quot;[i]&nbsp;created&nbsp;symbolic&nbsp;link&nbsp;%wZ&nbsp;\n&quot;,&nbsp;DEVICE_SYMBOLIC_LINK);<br /><br />	//&nbsp;callback&nbsp;functions<br />	DriverObject-&gt;DriverUnload&nbsp;=&nbsp;DriverUnload;<br />	DriverObject-&gt;MajorFunction[IRP_MJ_CREATE]&nbsp;=&nbsp;MJ_Create;				//&nbsp;function&nbsp;to&nbsp;run&nbsp;when&nbsp;handle&nbsp;to&nbsp;our&nbsp;device&#39;s&nbsp;symbol&nbsp;is&nbsp;opened<br />	DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE]&nbsp;=&nbsp;MJ_Close;				//&nbsp;function&nbsp;to&nbsp;run&nbsp;when&nbsp;handle&nbsp;to&nbsp;our&nbsp;device&#39;s&nbsp;symbol&nbsp;is&nbsp;closed<br />	DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]&nbsp;=&nbsp;IoControl;		//&nbsp;function&nbsp;to&nbsp;handle&nbsp;IO&nbsp;requests&nbsp;from&nbsp;userland<br /><br />	DbgPrint(&quot;[i]&nbsp;driver&nbsp;loaded&nbsp;\n&quot;);<br /><br />	return&nbsp;nt_status;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## How-to: Userland</h2></strong><br />The userland code is fairly well commented, so it shouldn&#39;t need an explanation.<br />It simply sends a message - <code>&quot;hello from userland :)&quot;</code> - and receives a message back from the kernel.<br /><br />It opens a handle to the kernel driver with <code>CreateFile</code>,<br />and sends a control code with <code>DeviceIoControl</code>.<br /><br /><strong><h3>### Example Userland Code</h3></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />#define&nbsp;IO_CODE_SENDMESSAGE&nbsp;CTL_CODE(FILE_DEVICE_UNKNOWN,&nbsp;0x801,&nbsp;METHOD_BUFFERED,&nbsp;FILE_ANY_ACCESS)<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	HANDLE&nbsp;h_device;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	wchar_t&nbsp;target_device[]&nbsp;=&nbsp;L&quot;\\\\.\\MoogleSymbolicLink&quot;;<br />	char&nbsp;in_message[]&nbsp;=&nbsp;&quot;hello&nbsp;from&nbsp;userland&nbsp;:)&quot;;<br />	char&nbsp;out_message[128]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	DWORD&nbsp;bytes_returned&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;handle&nbsp;to&nbsp;driver<br />	h_device&nbsp;=&nbsp;CreateFileW(target_device,&nbsp;GENERIC_ALL,&nbsp;0,&nbsp;0,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_SYSTEM,&nbsp;0);<br />	if&nbsp;(h_device&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;device&nbsp;%ws:&nbsp;%d&nbsp;\n&quot;,&nbsp;target_device,&nbsp;GetLastError());<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	//&nbsp;send&nbsp;I/O&nbsp;control&nbsp;code&nbsp;&amp;&nbsp;receive&nbsp;data&nbsp;back<br />	printf(&quot;[i]&nbsp;sending&nbsp;code&nbsp;0x%x&nbsp;\n&quot;,&nbsp;IO_CODE_SENDMESSAGE);<br />	b_ret&nbsp;=&nbsp;DeviceIoControl(h_device,&nbsp;IO_CODE_SENDMESSAGE,&nbsp;in_message,&nbsp;strlen(in_message),&nbsp;out_message,&nbsp;sizeof(out_message),&nbsp;&amp;bytes_returned,&nbsp;NULL);<br /><br />	printf(&quot;[i]&nbsp;received&nbsp;%d&nbsp;bytes&nbsp;back&nbsp;from&nbsp;kernel:&nbsp;\n\t%s&nbsp;\n&quot;,&nbsp;bytes_returned,&nbsp;out_message);<br /><br />	CloseHandle(h_device);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Demo</h2></strong><br />A debuggee machine is running our kernel driver.<br />A debugger machine is running WinDbg and is connected to the debuggee machine.<br /><br />I&#39;m loading the driver with OSR Driver Loader.<br />On the debuggee machine I <code>Register Service</code> and <code>Start Service</code>.<br />Our kernel driver to hide processes is now running.<br /><a href=""><img src="images/1813-2.png" alt="images/1813-2.png" /></a><br /><br />Back on WinDbg I can see that our device has been created.<br /><a href=""><img src="images/1813-3.png" alt="images/1813-3.png" /></a><br /><br />And back on the debuggee machine where our driver is loaded, we can see our driver in <code>WinObj</code><br /><a href=""><img src="images/1813-4.png" alt="images/1813-4.png" /></a><br /><br />In an Administrator PowerShell prompt, I run my userland program.<br />(if not running as Admin, the program fails because we get ACCESS DENIED)<br /><br />We got a message back from the kernel!<br /><a href=""><img src="images/1813-5.png" alt="images/1813-5.png" /></a><br /><br />And back in WinDbg we see everything that happened<br /><a href=""><img src="images/1813-6.png" alt="images/1813-6.png" /></a><br /><br /></div>
</body>
</html>
