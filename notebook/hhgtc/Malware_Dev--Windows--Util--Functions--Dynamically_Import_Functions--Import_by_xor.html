<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Import by xor</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Import by xor</h1></strong><br />This is the same as importing by hash except that your function names are xor&#39;ed instead of hashed.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />//&nbsp;function&nbsp;typedefs<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_Beep)(DWORD&nbsp;dwFreq,&nbsp;DWORD&nbsp;dwDuration);<br /><br />/*<br />Encrypted&nbsp;strings<br />XOR&nbsp;key&nbsp;=&nbsp;&quot;hey&quot;&nbsp;=&nbsp;&quot;\x68\x65\x79&quot;<br /><br />Encryption&nbsp;done&nbsp;at&nbsp;this&nbsp;URL:<br />https://gchq.github.io/CyberChef/#recipe=XOR(%7B&#39;option&#39;:&#39;Hex&#39;,&#39;string&#39;:&#39;%5C%5Cx68%5C%5Cx65%5C%5Cx79&#39;%7D,&#39;Standard&#39;,true)To_Hex(&#39;%5C%5Cx&#39;,0)<br />*/<br />wchar_t&nbsp;enc_Kernel32_dll_path[]&nbsp;=&nbsp;L&quot;\x2b\x5f\x25\x3f\x0c\x17\x0c\x0a\x0e\x1b\x39\x2a\x11\x16\x0d\x0d\x08\x4a\x5a\x39\x32\x2d\x37\x37\x2d\x29\x4a\x5a\x4b\x3d\x24\x29&quot;;	//&nbsp;C:\Windows\System32\KERNEL32.DLL<br />char&nbsp;enc_Beep[]&nbsp;=&nbsp;&quot;\x2a\x65\x1c\x18&quot;;<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;ANSI&nbsp;text.<br />The&nbsp;original&nbsp;string&nbsp;is&nbsp;XOR&#39;d&nbsp;and&nbsp;returned,&nbsp;so&nbsp;the&nbsp;function&nbsp;can&nbsp;be&nbsp;used&nbsp;like&nbsp;this:<br />	printf(&quot;%s&nbsp;\n&quot;,&nbsp;xorA(&quot;plaintext&quot;));<br /><br />NOTE:<br />This&nbsp;function&nbsp;modifies&nbsp;the&nbsp;original&nbsp;string.<br />If&nbsp;decrypting,&nbsp;XOR&nbsp;the&nbsp;string&nbsp;again&nbsp;after&nbsp;use&nbsp;to&nbsp;prevent&nbsp;the&nbsp;plaintext&nbsp;string<br />from&nbsp;being&nbsp;left&nbsp;in&nbsp;memory.<br />*/<br />char*&nbsp;xorA(char*&nbsp;str)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;h&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;y&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br />	int&nbsp;str_len&nbsp;=&nbsp;strlen(str);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;str_len;&nbsp;i++)<br />	{<br />		if&nbsp;((str[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(str[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_len]))<br />			continue;<br />		else<br />			str[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_len];<br />	}<br /><br />	return&nbsp;str;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;Unicode&nbsp;text.<br />The&nbsp;original&nbsp;string&nbsp;is&nbsp;XOR&#39;d&nbsp;and&nbsp;returned,&nbsp;so&nbsp;the&nbsp;function&nbsp;can&nbsp;be&nbsp;used&nbsp;like&nbsp;this:<br />	printf(&quot;%s&nbsp;\n&quot;,&nbsp;xorA(&quot;plaintext&quot;));<br /><br />NOTE:<br />This&nbsp;function&nbsp;modifies&nbsp;the&nbsp;original&nbsp;string.<br />If&nbsp;decrypting,&nbsp;XOR&nbsp;the&nbsp;string&nbsp;again&nbsp;after&nbsp;use&nbsp;to&nbsp;prevent&nbsp;the&nbsp;plaintext&nbsp;string<br />from&nbsp;being&nbsp;left&nbsp;in&nbsp;memory.<br />*/<br />wchar_t*&nbsp;xorW(wchar_t*&nbsp;str)<br />{<br />	wchar_t&nbsp;key[]&nbsp;=&nbsp;{&nbsp;L&#39;h&#39;,&nbsp;L&#39;e&#39;,&nbsp;L&#39;y&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key)&nbsp;/&nbsp;2;		//&nbsp;sizeof(key)&nbsp;comes&nbsp;out&nbsp;as&nbsp;double&nbsp;key&nbsp;length&nbsp;(idk&nbsp;why),&nbsp;so&nbsp;must&nbsp;divide&nbsp;by&nbsp;2<br />	int&nbsp;str_len&nbsp;=&nbsp;wcslen(str);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;string_length;&nbsp;i++)<br />	{<br />		//&nbsp;If&nbsp;byte&nbsp;==&nbsp;00&nbsp;don&#39;t&nbsp;xor&nbsp;(because&nbsp;it&nbsp;shows&nbsp;key)<br />		//&nbsp;If&nbsp;byte&nbsp;is&nbsp;same&nbsp;as&nbsp;key&nbsp;don&#39;t&nbsp;XOR&nbsp;(because&nbsp;will&nbsp;produce&nbsp;00)<br />		if&nbsp;((str[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(str[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_length]))<br />			continue;<br />		else<br />			str[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_length];<br />	}<br /><br />	return&nbsp;string_copy;<br />}<br /><br />/*<br />Grabs&nbsp;PEB,<br />grabs&nbsp;PED_LDR_DATA&nbsp;from&nbsp;PEB&nbsp;to&nbsp;get&nbsp;info&nbsp;about&nbsp;loaded&nbsp;DLLs,<br />and&nbsp;loops&nbsp;through&nbsp;the&nbsp;loaded&nbsp;DLLs&nbsp;to&nbsp;find&nbsp;the&nbsp;DLL&nbsp;we&nbsp;want&nbsp;and&nbsp;grabs&nbsp;its&nbsp;base&nbsp;address.<br /><br />Be&nbsp;careful.&nbsp;The&nbsp;DLL&nbsp;name&nbsp;has&nbsp;to&nbsp;be&nbsp;exact&nbsp;(could&nbsp;use&nbsp;something&nbsp;else&nbsp;than&nbsp;strcmp&nbsp;tbf)<br />e.g:&nbsp;&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;&nbsp;vs&nbsp;&quot;C:\\WINDOWS\\System32\\KERNEL32.DLL&quot;<br /><br />Return:<br />NULL&nbsp;on&nbsp;error.<br />*/<br />LPVOID&nbsp;FindLoadedDLLBaseAddress(const&nbsp;wchar_t*&nbsp;dll_name)<br />{<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_list&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_entry&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;dll_base&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;PEB<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br /><br />	//&nbsp;grab&nbsp;list&nbsp;of&nbsp;loaded&nbsp;DLLs<br />	dll_list&nbsp;=&nbsp;(PLIST_ENTRY)&amp;p_peb-&gt;Ldr-&gt;InMemoryOrderModuleList;<br />	//&nbsp;grab&nbsp;first&nbsp;DLL&nbsp;in&nbsp;list&nbsp;of&nbsp;DLLs<br />	dll_entry&nbsp;=&nbsp;dll_list-&gt;Flink;<br /><br />	printf(&quot;peb&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_peb);<br />	printf(&quot;dll&nbsp;list&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_list);<br />	printf(&quot;dll&nbsp;entry&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_entry);<br /><br />	printf(&quot;[*]&nbsp;looping&nbsp;through&nbsp;loaded&nbsp;DLLs...&nbsp;\n&quot;);<br />	//&nbsp;loop&nbsp;through&nbsp;loaded&nbsp;DLLs<br />	while&nbsp;(dll_list&nbsp;!=&nbsp;dll_entry)<br />	{<br />		//&nbsp;grab&nbsp;DLL<br />		PLDR_DATA_TABLE_ENTRY&nbsp;module&nbsp;=&nbsp;CONTAINING_RECORD(dll_entry,&nbsp;LDR_DATA_TABLE_ENTRY,&nbsp;InMemoryOrderLinks);<br /><br />		printf(&quot;\t&nbsp;%ws&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;module-&gt;FullDllName.Buffer,&nbsp;module-&gt;DllBase);<br /><br />		//&nbsp;if&nbsp;DLL&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />		if&nbsp;(wcscmp(dll_name,&nbsp;module-&gt;FullDllName.Buffer)&nbsp;==&nbsp;0)<br />		{<br />			dll_base&nbsp;=&nbsp;module-&gt;DllBase;<br />			break;<br />		}<br /><br />		//&nbsp;increment&nbsp;to&nbsp;next&nbsp;DLL<br />		dll_entry&nbsp;=&nbsp;dll_entry-&gt;Flink;<br />	}<br /><br />	return&nbsp;dll_base;<br />}<br /><br />/*<br />Find&nbsp;the&nbsp;address&nbsp;of&nbsp;an&nbsp;exported&nbsp;function&nbsp;from&nbsp;a&nbsp;DLL.<br />Only&nbsp;tested&nbsp;with&nbsp;a&nbsp;DLL&nbsp;already&nbsp;loaded&nbsp;in&nbsp;memory.<br />*/<br />LPVOID&nbsp;FindExportedDLLFunctionAddress(LPVOID&nbsp;dll_base_address,&nbsp;const&nbsp;char*&nbsp;requested_function)<br />{<br />	LPVOID&nbsp;function_address&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_directory&nbsp;=&nbsp;NULL;<br /><br />	DWORD*&nbsp;export_dir_names&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;export_dir_ordinals&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_dir_functions&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;export&nbsp;directory&nbsp;from&nbsp;DLL<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_base_address;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	export_directory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br /><br />	printf(&quot;\t&nbsp;exports&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;export_directory);<br /><br />	export_dir_names&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNames);<br />	export_dir_ordinals&nbsp;=&nbsp;(WORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNameOrdinals);<br />	export_dir_functions&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfFunctions);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;exports<br />	//&nbsp;if&nbsp;requested&nbsp;function&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;export_directory-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		//&nbsp;grab&nbsp;function&nbsp;name<br />		char*&nbsp;function_name&nbsp;=&nbsp;(char*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_names[i]);<br />		printf(&quot;\t\t&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />		//&nbsp;compare&nbsp;function&nbsp;name&nbsp;to&nbsp;requested&nbsp;function.&nbsp;if&nbsp;correct,&nbsp;save&nbsp;address&nbsp;and&nbsp;exit<br />		if&nbsp;(strcmp(function_name,&nbsp;requested_function)&nbsp;==&nbsp;0)<br />		{<br />			function_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_functions[export_dir_ordinals[i]]);<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;function_address;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	LPVOID&nbsp;kernel32_base_address&nbsp;=&nbsp;NULL;<br /><br />	kernel32_base_address&nbsp;=&nbsp;FindLoadedDLLBaseAddress(xorW(enc_Kernel32_dll_path));<br />	t_Beep&nbsp;d_Beep&nbsp;=&nbsp;(t_Beep)FindExportedDLLFunctionAddress(kernel32_base_address,&nbsp;xorA(enc_Beep));<br /><br />	d_Beep(1000,&nbsp;1000);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
