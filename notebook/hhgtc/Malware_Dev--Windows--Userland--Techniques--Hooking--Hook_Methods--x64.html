<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>x64</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x64 Hooks</h1></strong><br />Ways / instructions to hook functions on x86.<br /><br /><strong>Links</strong><br />• <a href="https://www.ragestorm.net/blogs/?p=107">https://www.ragestorm.net/blogs/?p=107</a> - Trampolines in x64<br />• <a href="http://sandsprite.com/blogs/index.php?uid=7&pid=235&year=2012">http://sandsprite.com/blogs/index.php?uid=7&amp;pid=235&amp;year=2012</a><br />• <a href="https://github.com/search?q=x64+inline+hook">https://github.com/search?q=x64+inline+hook</a><br />• <a href="https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra">https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra</a><br />• <a href="https://www.unknowncheats.me/forum/c-and-c-/302719-steam-x64-detours.html">https://www.unknowncheats.me/forum/c-and-c-/302719-steam-x64-detours.html</a> - Demonstrates how Steam does it<br />• <a href="https://www.unknowncheats.me/forum/c-and-c-/134871-64-bit-detour-function.html">https://www.unknowncheats.me/forum/c-and-c-/134871-64-bit-detour-function.html</a><br /><br />Minhook has a bunch of different methods:<br /><a href="https://github.com/TsudaKageyu/minhook/blob/master/src/trampoline.h">https://github.com/TsudaKageyu/minhook/blob/master/src/trampoline.h</a><br /><br />Windows NT hotpatch?? Don&#39;t know what this is.<br /><a href="https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1502">https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1502</a><br /><br /><strong><h2>## 5 bytes - E9 jmp relative</h2></strong><br />The E9 <code>jmp relative</code> instruction is limited to a + or - 2GB range.<br /><br />On 32bit this isn&#39;t a problem, as 4GB covers the entire available address space on 32bit machines.<br />But on 64bit machines, the address of our trampoline or hook code might be more than 2GB away from the target function we&#39;re hooking, so an <code>E9</code> jmp relative instruction won&#39;t jump far enough to get us there.<br /><br />Therefore, it&#39;s only possible to use an E9 jump on x64 if you can find free memory <br />within a + or - 2GB range from your target function&#39;s address.<br /><br />Refer here for a function to find free memory within a 2gb range:<br /><a href="Malware_Dev--Windows--Kernel_land--About--Basics--Notifications.html">Useful &gt; Find Memory within 2gb</a><br /><br />If you find free memory within a 2gb range,<br />you could assign trampoline space there and jump to where to wherever you want.<br /><br /><strong><h2>## 5 bytes - E8 call</h2></strong><br />Exactly the same as above except that E8 is <code>call</code>, not <code>jmp</code><br /><br /><strong><h2>## 6 bytes - FF 25 - Indirect Jump</h2></strong><br />Referenced here:<br />• <a href="https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for">https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for</a><br />• <a href="https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx">https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx</a><br /><br />FF 25 is the instruction for an indirect jump <br />It&#39;s 6 bytes long.<br /><br />The first 2 bytes are <code>FF 25</code>, <br />and the following 4 bytes are a 32bit value.<br /><br />This 32bit value is a memory address that stores the REAL destination of where to jump to<br />i.e. it will read the value @ 32bit address - (e.g the 64bit value at address <code>7622EE90</code>) - and jump there<br /><br /><div class="codebox"><div class="codebox">BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INSTRUCTION:<br />FF&nbsp;25&nbsp;90&nbsp;EE&nbsp;22&nbsp;76		jmp&nbsp;7622EE90</div></div><br /><br />For an x64 hook, you could find some free memory within a 2GB range of your <code>FF 25</code> instruction<br />and write there the 64bit address of where you want to jump to (hook code, trampoline, etc.)<br /><br />To find memory within a 2gb range:<br /><a href="Malware_Dev--Windows--Kernel_land--About--Basics--Notifications.html">Useful &gt; Find Memory within 2gb</a><br /><br />For a complete example of using FF 25:<br />FF 25 -&gt; 64bit addr in 2gb range -&gt; Trampoline<br /><br /><strong><h2>## 10 bytes - push &lt;addr&gt;; ret - UNSURE</h2></strong><br />You can push the address you want to jump to onto the stack and then return.<br />I haven&#39;t tested this on x64. I haven&#39;t seen anyone use it. I&#39;m guessing it doesn&#39;t work and there&#39;s something obvious I&#39;m missing.<br /><br />Takes 10 bytes.<br /><div class="codebox"><div class="codebox">ADDRESS:&nbsp;&nbsp;&nbsp;BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		INSTRUCTION:<br />0	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;68&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??		push&nbsp;offset&nbsp;my_function<br />9	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C3										ret</div></div><br /><br />5th June 2021:<br />I just found it refernced here:<br /><a href="https://github.com/rdbo/DX11-BaseHook/blob/c77091b7c204b50f721342d10380fee6b5e49826/include/libmem%2B%2B/libmem.hpp#L131">https://github.com/rdbo/DX11-BaseHook/blob/c77091b7c204b50f721342d10380fee6b5e49826/include/libmem%2B%2B/libmem.hpp#L131</a><br />Perhaps it does work.<br /><br /><strong><h2>## 12 bytes - mov RAX, &lt;address&gt; ; jmp RAX</h2></strong><br />• <a href="https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1506">https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1506</a><br /><br />To jump straight to a 64bit address, <br />you can copy the address into RAX and then call <code>jmp rax</code> to jump to the address<br /><br />This takes 12 bytes.<br /><br /><div class="codebox"><div class="codebox">ADDRESS:&nbsp;&nbsp;&nbsp;BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		INSTRUCTION:<br />0	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;B8&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??	mov&nbsp;RAX,&nbsp;&lt;64bit_address&gt;<br />10	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FF&nbsp;E0									jmp&nbsp;RAX</div></div><br /><br />The disadvantage to this is that it spoils a register,<br />but sometimes ruining what&#39;s stored in RAX doesn&#39;t matter <br />so you&#39;re usually ok to use this technique.<br /><br /><h2>## 12 bytes - mov RAX; push RAX; ret;</h2><br />Basically the same as above.<br />Move the address to jump to into RAX.<br />To jump there, push RAX onto the stack and then return.<br /><br /><div class="codebox"><div class="codebox">ADDRESS:&nbsp;&nbsp;&nbsp;BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		INSTRUCTION:<br />0	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;B8&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??	mov&nbsp;rax,&nbsp;&lt;64bit_address&gt;<br />10	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50										push&nbsp;rax<br />11	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C3										ret</div></div><br /><br />Same disadvantages as above too (spoils register.)<br />Referenced here:<br />• <a href="https://github.com/rdbo/DX11-BaseHook/blob/c77091b7c204b50f721342d10380fee6b5e49826/include/libmem%2B%2B/libmem.hpp#L130">https://github.com/rdbo/DX11-BaseHook/blob/c77091b7c204b50f721342d10380fee6b5e49826/include/libmem%2B%2B/libmem.hpp#L130</a><br /><br /><h2>## 12 bytes - mov RAX; call RAX;</h2><br />Same as above again<br />Move the address to jump to into RAX, and jump there with <code>call rax</code><br /><br /><div class="codebox"><div class="codebox">ADDRESS:&nbsp;&nbsp;&nbsp;BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		INSTRUCTION:<br />0	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;B8&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??&nbsp;??	mov&nbsp;rax,&nbsp;&lt;64bit_address&gt;<br />10	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FF&nbsp;D0									call&nbsp;rax</div></div><br /><br />Same disadvantages as above too (spoils register.)<br />Referenced here:<br />• <a href="https://github.com/rdbo/DX11-BaseHook/blob/c77091b7c204b50f721342d10380fee6b5e49826/include/libmem%2B%2B/libmem.hpp#L132">https://github.com/rdbo/DX11-BaseHook/blob/c77091b7c204b50f721342d10380fee6b5e49826/include/libmem%2B%2B/libmem.hpp#L132</a><br /><br /><strong><h2>## 14 bytes - FF 25 - Write 64bit address after</h2></strong><br />If you leave the following 4 bytes after FF 25 empty, <br />and then write an 8 byte address in the bytes after the instruction,<br />it will jump to the 64bit address.<br /><br />I HAVEN&#39;T BEEN ABLE TO GET THIS TO WORK.<br />Only tested on x64 MessageBoxA<br /><br />Examples:<br />• <a href="https://www.unknowncheats.me/forum/1223255-post2.html">https://www.unknowncheats.me/forum/1223255-post2.html</a> - Always uses 14 bytes. No length disassembler.<br />• <a href="https://www.unknowncheats.me/forum/c-and-c-/302719-steam-x64-detours.html">https://www.unknowncheats.me/forum/c-and-c-/302719-steam-x64-detours.html</a> - This is how steam hooks functions<br />• <a href="https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1523">https://github.com/WindowsNT/hotpatch/blob/acb4353a4b202a39294df114f47fb7b49784f2fe/hotpatch.h#L1523</a><br /><br />In total, this will take 14 bytes (6 byte jmp + 8 byte address)<br /><div class="codebox"><div class="codebox">BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INSTRUCTION:<br />FF&nbsp;25&nbsp;00&nbsp;00&nbsp;00&nbsp;00		jmp&nbsp;qword&nbsp;ptr&nbsp;[00007FF79CAB131Bh]<br />1B<br />13<br />AB<br />9C<br />F7<br />7F<br />00&nbsp;00</div></div><br /><br /><strong><h2>## 14 bytes - FF 25 F2 - Write 64bit address before</h2></strong><br />You can also write the 64bit 8 byte address before the instruction.<br />Using <code>FF 25 F2</code> will reference the 8 bytes before the instruction.<br /><br />Source: <br />• <a href="http://sandsprite.com/blogs/index.php?uid=7&pid=235&year=2012">http://sandsprite.com/blogs/index.php?uid=7&amp;pid=235&amp;year=2012</a><br /><br />Here the <code>FF 25 F2</code> instruction is saying it will jump to <code>0x00007FFECBCFACE,</code> <br />which is the start of our 64bit address.<br />It will then read this address and jump there.<br /><br /><div class="codebox"><div class="codebox">ADDRESS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INSTRUCTION:<br />00007FFECBCFACE8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??<br />00007FFECBCFACE9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??<br />00007FFECBCFACEA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??<br />00007FFECBCFACEB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??<br />00007FFECBCFACEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??<br />00007FFECBCFACED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??<br />00007FFECBCFACEE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??&nbsp;??<br />00007FFECBCFACF0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FF&nbsp;25&nbsp;F2&nbsp;FF&nbsp;FF&nbsp;FF&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qword&nbsp;ptr&nbsp;<span style="color:#000000;font-weight:400">[</span>7FFECBCFACE8h<span style="color:#000000;font-weight:400">]</span></div></div><br /><br /><strong><h2>## 16 bytes - push rax, mov rax &lt;address&gt;, xchg, ret</h2></strong><br />This is the equivalent of the 12 byte <br /><code>mov rax, &lt;address&gt; ; jmp rax</code> seen above but it doesn&#39;t ruin the RAX register.<br /><br />Used in <br />• PolyHook<br /><br /><div class="codebox"><div class="codebox">ADDRESS:&nbsp;&nbsp;&nbsp;BYTES:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		&nbsp;INSTRUCTION:<br />0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;rax<br />1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;B8&nbsp;A0&nbsp;E1&nbsp;C2&nbsp;0E&nbsp;FC&nbsp;7F&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movabs&nbsp;rax,&nbsp;0x7ffc0ec2e1a0<br />11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;87&nbsp;04&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xchg&nbsp;qword&nbsp;ptr&nbsp;[rsp],&nbsp;rax<br />15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret<br /><br />DWORD64&nbsp;64bit_address&nbsp;=&nbsp;0x7ffc0ec2e1a0;<br />unsigned&nbsp;char&nbsp;hook[16]&nbsp;=<br />{<br />&nbsp;&nbsp;0x50,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;push&nbsp;rax<br />&nbsp;&nbsp;0x48,&nbsp;0xB8,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;movbs&nbsp;rax,&nbsp;&lt;64bit&nbsp;address&gt;<br />&nbsp;&nbsp;0x48,&nbsp;0x87,&nbsp;0x04,&nbsp;0x24,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;xchg&nbsp;qword&nbsp;ptr&nbsp;[rsp],&nbsp;rax<br />&nbsp;&nbsp;0xC3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ret<br />};<br />memcpy_s(hook&nbsp;+&nbsp;3,&nbsp;8,&nbsp;&amp;64bit_address,&nbsp;8);</div></div><br /><br /><strong><h2>## 6 bytes + 2gb range - E9 -&gt; FF 25 00 00 00 &lt;trampoline&gt;</h2></strong><br />This is a bit of combo.<br />Overwrite the first 5 bytes of the function with a 5 byte E9.<br />Use that E9 to reach 14 bytes of space within a +/- 2gb range of the original function.<br />In those 14 bytes, write an <code>FF 25 00 00 00</code> with the 64bit address of the trampoline after.<br /><br />This overwrites 5 bytes in the original function.<br />And requries finding 14 bytes of free space within a +/- 2gb range of the original function.<br /><br />This is exactly how the steam overlay hooks functions:<br /><a href="https://www.unknowncheats.me/forum/c-and-c-/302719-steam-x64-detours.html">https://www.unknowncheats.me/forum/c-and-c-/302719-steam-x64-detours.html</a><br /><br />Also used in:<br />• Minhook</div>
</body>
</html>
