<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>FireWalker - Locate Original Bytes</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># FireWalker - Detect Hook &amp; Locate Original Bytes</h1></strong><br />The FireWalker technique was published by MDSecLabs.<br />All credit goes here:<br />• <a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/</a><br />• <a href="https://github.com/mdsecactivebreach/firewalker">https://github.com/mdsecactivebreach/firewalker</a><br /><br />Because hooking a function overwrites bytes within the original function, hook installers typically copy the original bytes they overwrite into a buffer with a jump back to the original function + N overwritten bytes. This means the original function can still be called despite being hooked.<br /><br />A solution to this is unhooking, which restores the original bytes that the hook overwrote.<br />However, some EDR / hook detection mechanisms will periodically check to see if their hooks have been removed.<br />This renders unhooking useless (unless your periodically check for hooks yourself, which becomes a weird cat &amp; mouse game).<br /><br />FireWalker proposes that you detect the hook, leave the hook in place, and instead of restoring the original bytes you look for the buffer in which the original bytes have been copied too when the hook was first installed.<br />This way you can leave the hook in place (evading EDR defenses) and bypass the hook (by locating the original bytes and jumping straight to them).</div>
</body>
</html>
