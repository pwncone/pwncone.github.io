<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Memory Layout</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x86 Memory Layout</h1></strong><br />Memory stores you program&#39;s instructions and data.<br />Here&#39;s what the memory layout looks like for an x86 process.<br /><br /><a href=""><img src="images/569-1.png" alt="images/569-1.png" /></a>b<br /><br /><strong><h2>## The Heap</h2></strong><br />The heap is an area of dynamic memory that stores temporary values.<br />The heap grows to numerically higher memory addresses.<br /><br /><strong><h2>## The Stack</h2></strong><br />The stack is used for functions - it holds function parameters and local variables.<br />The stack is a <code>FIFO</code> structure - <code>First In Last Out</code>.<br />This means that the first item you put on the stack will be last item you get back out.<br /><br />You can think of the stack as a stack of plates:<br />• the first plate you put on the stack is the last one you&#39;ll get out<br /><br /><a href=""><img src="images/569-2.png" alt="images/569-2.png" /></a><br /><br />The <code>ESP</code> register points to the top of the stack.<br />The <code>EBP</code> register points to the bottom of the stack.<br /><br /><a href=""><img src="images/569-3.png" alt="images/569-3.png" /></a><br /><br />The <code>PUSH</code> instruction pushes data onto the stack.<br />The <code>POP</code> instruction pops data off the stack.<br /><br /><a href=""><img src="images/569-4.png" alt="images/569-4.png" /></a><br /><br />The stack starts at a high address and grows to numerically lower addresses.<br />Depending on the diagram, the stack will either grow upwards or downwards. This is why it&#39;s best to think of the stack as growing to numerically lower addresses.<br /><br />The reason the stack starts at a high address is historical.<br />Early computers divided memory into 2 parts: the heap and the stack.<br />It was not known how big both the heap and the stack were going to be when the program was running, so the heap and the stack were placed at opposite ends of memory and grew towards to the middle. The stack, just by chance, was placed at the high address.<br /><br /><a href=""><img src="images/569-5.png" alt="images/569-5.png" /></a><br /><br /><strong><h3>### Stack Frames</h3></strong><br />The stack is used for functions.<br />When a function is called, a stack frame is created.<br />The stack frame stores all of the function&#39;s arguments and temporary variables.<br />When the function returns, the stack frame is cleared.<br /><br />Functions can call other functions.<br />If this happens, another stack frame gets created on top of the existing stack frame.<br /><br /><a href=""><img src="images/569-6.png" alt="images/569-6.png" /></a><br /><br /><br /><strong><h3>### Internals of a Stack Frame</h3></strong><br />When a function is called:<br />1. The function&#39;s arguments are pushed onto the stack<br />2. The address in EIP at the time of the function being called gets pushed onto the stack<br />   ◇ This value is used as the <code>return address</code> <br />   ◇ When the function leaves, the CPU will jump to this return address so that it can continue executing code from where the function was called<br />3. The EBP gets pushed onto the stack<br />4. The function&#39;s local variables are pushed onto the stack<br /><br /><code>EBP</code> points to the base of the current stack frame.<br />It gets used to access the function arguments and local variables within the current stack frame.<br />   ◇ <code>EBP - N</code> will grab local variables, because they&#39;re stored at lower addresses<br />   ◇ <code>EBP + N</code> will grab function arguments, which are stored at high memory addresses because they&#39;re pushed first onto the stack<br /><br /><a href=""><img src="images/569-7.png" alt="images/569-7.png" /></a><br /><br /><strong><h3>### Lifecycle of a Function on the Stack</h3></strong><br />Functions will prepare the stack frame, and clean it up afterwards.<br /><br /><strong>Setup:</strong><br />1. First, the function&#39;s arguments are pushed onto the stuck<br />   ◇ They are done so in reverse order<br />   ◇ <code>push arg3</code> <code>push arg2</code> <code>push arg1</code><br />2. The function gets called<br />   ◇ <code>call &lt;function&gt;</code><br />3. The value in EIP gets pushed onto the stack as the <code>return address</code><br />   ◇ This value gets used as the address to return to after the function has returned<br />   ◇ It points back to where to the original function was called, so that the program can continue executing<br />4. The value in EBP - the old EBP - gets pushed onto the stack<br />   ◇ This is so that we can return to the previous stack frame once this function has returned<br />5. Space for the function&#39;s local variables gets allocated by subtracting N no. of variables from ESP <br />   ◇ The stack grows to lower addresses<br />   ◇ By subtracting <code>0xF</code> from ESP, the stack size gets increased by <code>0xF</code> byes (12 bytes)<br /><br />The function runs.<br /><br /><strong>Cleanup:</strong><br />7. <code>leave</code> - The leave instruction does 2 things:<br />   ◇ Sets <code>ESP</code> to <code>EBP</code> - this decreases the size of the stack and removes the local variables<br />   ◇ Pops the old <code>EBP</code> stored on the stack into <code>EBP</code> - now the old stack frame has been restored.<br />8. <code>ret</code> - The <code>ret</code> instruction causes the function to exit<br />   ◇ The <code>return address</code> stored on the stack is popped into EIP, and the program continues execution from where the function was called<br /><br /><a href=""><img src="images/569-8.png" alt="images/569-8.png" /></a><br /><br /><a href=""><img src="images/569-9.png" alt="images/569-9.png" /></a><br /><br /><br /></div>
</body>
</html>
