<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Dynamically Import Functions</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Dynamically Import Functions</h1></strong><br /><a href="https://docs.microsoft.com/en-us/windows/win32/dlls/using-run-time-dynamic-linking">https://docs.microsoft.com/en-us/windows/win32/dlls/using-run-time-dynamic-linking</a><br /><br />You can dynamically import functions by:<br />• creating a typedef of the function<br />• loading the DLL that contains the function you want with <code>LoadLibraryA</code><br />• and grabbing the address of the function in the DLL with <code>GetProcAddress</code><br /><br />By dynamically importing functions this way, the only functions that will show up in your PE&#39;s imports are<br /><code>LoadLibrary</code> / <code>GetModuleHandle</code> and <code>GetProcAddress</code><br /><a href=""><img src="images/1559-1.png" alt="images/1559-1.png" /></a><br /><br />In my examples:<br />• <code>t_Function</code> - means typedef<br />• <code>d_Function</code> - means dynamic. This is the actual function call<br /><br />The typedef format is like this:<br /><code>typedef RETURN_VALUE(__stdcall* t_FunctionName)(PARAMETERS);</code><br /><br /><strong><h2>## Examples</h2></strong><br />Grab <code>MessageBoxA</code> from <code>User32.dll</code><br /><code>User32.dll</code> isn&#39;t loaded into the binary by default, so we have to load it with <code>LoadLibraryA</code><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />//&nbsp;typedef&nbsp;of&nbsp;functions<br />typedef&nbsp;int(__stdcall*&nbsp;t_MessageBoxA)(<br />	HWND&nbsp;&nbsp;&nbsp;hWnd,<br />	LPCSTR&nbsp;lpText,<br />	LPCSTR&nbsp;lpCaption,<br />	UINT&nbsp;&nbsp;&nbsp;uType<br />);<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;load&nbsp;User32.dll&nbsp;and&nbsp;grab&nbsp;address&nbsp;of&nbsp;MessageBoxA&nbsp;in&nbsp;User32.dll<br />	t_MessageBoxA&nbsp;d_MessageBoxA&nbsp;=&nbsp;(t_MessageBoxA)GetProcAddress(LoadLibraryA(&quot;User32.dll&quot;),&nbsp;&quot;MessageBoxA&quot;);<br />	<br />	//&nbsp;use&nbsp;dynamically&nbsp;imported&nbsp;Beep<br />	d_MessageBoxA(NULL,&nbsp;&quot;hey&nbsp;:)&quot;,&nbsp;&quot;much&nbsp;title&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />If the function you want is stored in <code>Kernel32.dll</code>, you can use <code>GetModuleHandle</code> instead of <code>LoadLibrary</code>.<br /><code>Kernel32.dll</code> is loaded automatically into a program&#39;s address space on startup, which means that you don&#39;t need to load it into your program with <code>LoadLibrary</code><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />//&nbsp;typedef&nbsp;of&nbsp;functions<br />typedef&nbsp;BOOL(__stdcall*&nbsp;t_Beep)(DWORD&nbsp;dwFreq,&nbsp;DWORD&nbsp;dwDuration);<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;grab&nbsp;address&nbsp;of&nbsp;Beep&nbsp;in&nbsp;Kernel32.dll<br />	t_Beep&nbsp;d_Beep&nbsp;=&nbsp;(t_Beep)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;),&nbsp;&quot;Beep&quot;);<br />	<br />	//&nbsp;use&nbsp;dynamically&nbsp;imported&nbsp;Beep<br />	d_Beep(1000,&nbsp;1000);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Real-world / Useful example</h2></strong><br />If you&#39;re doing this in a larger program, you don&#39;t want to be using <code>GetProcAddress</code> in every function where you need an import.<br /><br />Therefore, the best solution I can think of is to store your imports and function typedefs in a header and write a function to resolve all your imports at the start of the program.<br /><br />This is reversible because it&#39;s a little obvious.<br />But your imports will be reversed at some point soon ayway so what does it matter.<br /><br />I&#39;m not smart enough to figure out how to put this into loop.<br /><br /><strong><h3>### Example</h3></strong><br />There are 3 files:<br />• <code>noimport.h</code><br />• <code>noimport.c</code><br />• <code>main.c</code> <br /><br /><a href=""><img src="images/1559-2.png" alt="images/1559-2.png" /></a><br /><br /><strong>noimport.h</strong><br />Stores our function typedefs, our hashed functions, and the functions we&#39;ve written in <code>noimport.c</code><br /><div class="codebox"><div class="codebox">#pragma&nbsp;once<br /><br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />//&nbsp;my&nbsp;functions<br />ULONG&nbsp;hash(char*&nbsp;str);<br />LPVOID&nbsp;FindLoadedDLLBaseAddress(const&nbsp;wchar_t*&nbsp;dll_name);<br />LPVOID&nbsp;FindExportedDLLFunctionAddress(LPVOID&nbsp;dll_base_address,&nbsp;ULONG&nbsp;hashed_requested_function);<br />int&nbsp;ImportFunctionsByHash(void);<br /><br />//&nbsp;hashed&nbsp;functions<br />#define&nbsp;hashed_Beep&nbsp;1310994705l<br /><br />//&nbsp;function&nbsp;typedefs<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_Beep)(DWORD&nbsp;dwFreq,&nbsp;DWORD&nbsp;dwDuration);<br />t_Beep&nbsp;d_Beep;<br /></div></div><br /><br /><strong>noimport.c</strong><br />Contains all the functions we need to find DLL base addresses, grab exported functions, import the functions, etc.<br />It&#39;s where all the leg work for importing by hash is done.<br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;noimport.h&quot;<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />/*<br />djb2&nbsp;hash&nbsp;algorithm&nbsp;by&nbsp;Dan&nbsp;Bernstein.<br />Hash&nbsp;length&nbsp;is&nbsp;longer&nbsp;for&nbsp;longer&nbsp;strings.<br />*/<br />ULONG&nbsp;hash(char*&nbsp;str)<br />{<br />	ULONG&nbsp;hash&nbsp;=&nbsp;4725;		//&nbsp;original&nbsp;from&nbsp;djb2&nbsp;code&nbsp;is&nbsp;5381<br />	int&nbsp;c;<br /><br />	while&nbsp;(c&nbsp;=&nbsp;*str++)<br />		hash&nbsp;=&nbsp;((hash&nbsp;&lt;&lt;&nbsp;5)&nbsp;+&nbsp;hash)&nbsp;+&nbsp;c;		//&nbsp;hash&nbsp;*&nbsp;33&nbsp;+&nbsp;c<br /><br />	return&nbsp;hash;<br />}<br /><br />/*<br />Grabs&nbsp;PEB,<br />grabs&nbsp;PED_LDR_DATA&nbsp;from&nbsp;PEB&nbsp;to&nbsp;get&nbsp;info&nbsp;about&nbsp;loaded&nbsp;DLLs,<br />and&nbsp;loops&nbsp;through&nbsp;the&nbsp;loaded&nbsp;DLLs&nbsp;to&nbsp;find&nbsp;the&nbsp;DLL&nbsp;we&nbsp;want&nbsp;and&nbsp;grabs&nbsp;its&nbsp;base&nbsp;address.<br /><br />Be&nbsp;careful.&nbsp;The&nbsp;DLL&nbsp;name&nbsp;has&nbsp;to&nbsp;be&nbsp;exact&nbsp;(could&nbsp;use&nbsp;something&nbsp;else&nbsp;than&nbsp;strcmp&nbsp;tbf)<br />e.g:&nbsp;&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;&nbsp;vs&nbsp;&quot;C:\\WINDOWS\\System32\\KERNEL32.DLL&quot;<br /><br />Return:<br />NULL&nbsp;on&nbsp;error.<br />*/<br />LPVOID&nbsp;FindLoadedDLLBaseAddress(const&nbsp;wchar_t*&nbsp;dll_name)<br />{<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_list&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_entry&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;dll_base&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;PEB<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br /><br />	//&nbsp;grab&nbsp;list&nbsp;of&nbsp;loaded&nbsp;DLLs<br />	dll_list&nbsp;=&nbsp;(PLIST_ENTRY)&amp;p_peb-&gt;Ldr-&gt;InMemoryOrderModuleList;<br />	//&nbsp;grab&nbsp;first&nbsp;DLL&nbsp;in&nbsp;list&nbsp;of&nbsp;DLLs<br />	dll_entry&nbsp;=&nbsp;dll_list-&gt;Flink;<br /><br />	//printf(&quot;peb&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_peb);<br />	//printf(&quot;dll&nbsp;list&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_list);<br />	//printf(&quot;dll&nbsp;entry&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_entry);<br />	//printf(&quot;[*]&nbsp;looping&nbsp;through&nbsp;loaded&nbsp;DLLs...&nbsp;\n&quot;);<br />	<br />	//&nbsp;loop&nbsp;through&nbsp;loaded&nbsp;DLLs<br />	while&nbsp;(dll_list&nbsp;!=&nbsp;dll_entry)<br />	{<br />		//&nbsp;grab&nbsp;DLL<br />		PLDR_DATA_TABLE_ENTRY&nbsp;module&nbsp;=&nbsp;CONTAINING_RECORD(dll_entry,&nbsp;LDR_DATA_TABLE_ENTRY,&nbsp;InMemoryOrderLinks);<br /><br />		//printf(&quot;\t&nbsp;%ws&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;module-&gt;FullDllName.Buffer,&nbsp;module-&gt;DllBase);<br /><br />		//&nbsp;if&nbsp;DLL&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />		if&nbsp;(wcscmp(dll_name,&nbsp;module-&gt;FullDllName.Buffer)&nbsp;==&nbsp;0)<br />		{<br />			dll_base&nbsp;=&nbsp;module-&gt;DllBase;<br />			break;<br />		}<br /><br />		//&nbsp;increment&nbsp;to&nbsp;next&nbsp;DLL<br />		dll_entry&nbsp;=&nbsp;dll_entry-&gt;Flink;<br />	}<br /><br />	return&nbsp;dll_base;<br />}<br /><br />/*<br />Find&nbsp;the&nbsp;address&nbsp;of&nbsp;an&nbsp;exported&nbsp;function&nbsp;from&nbsp;a&nbsp;DLL.<br />Only&nbsp;tested&nbsp;with&nbsp;a&nbsp;DLL&nbsp;already&nbsp;loaded&nbsp;in&nbsp;memory.<br />*/<br />LPVOID&nbsp;FindExportedDLLFunctionAddress(LPVOID&nbsp;dll_base_address,&nbsp;ULONG&nbsp;hashed_requested_function)<br />{<br />	LPVOID&nbsp;function_address&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_directory&nbsp;=&nbsp;NULL;<br /><br />	DWORD*&nbsp;export_dir_names&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;export_dir_ordinals&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_dir_functions&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;export&nbsp;directory&nbsp;from&nbsp;DLL<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_base_address;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	export_directory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br /><br />	//printf(&quot;\t&nbsp;exports&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;export_directory);<br /><br />	export_dir_names&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNames);<br />	export_dir_ordinals&nbsp;=&nbsp;(WORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNameOrdinals);<br />	export_dir_functions&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfFunctions);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;exports<br />	//&nbsp;if&nbsp;requested&nbsp;function&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;export_directory-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		//&nbsp;grab&nbsp;function&nbsp;name<br />		char*&nbsp;function_name&nbsp;=&nbsp;(char*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_names[i]);<br />		//printf(&quot;\t\t&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />		//&nbsp;compare&nbsp;hashed&nbsp;function&nbsp;name&nbsp;to&nbsp;hashed&nbsp;requested&nbsp;function.&nbsp;if&nbsp;correct,&nbsp;save&nbsp;address&nbsp;and&nbsp;exit<br />		if&nbsp;(hash(function_name)&nbsp;==&nbsp;hashed_requested_function)<br />		{<br />			function_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_functions[export_dir_ordinals[i]]);<br />			printf(&quot;[+]&nbsp;imported&nbsp;%s&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;function_name,&nbsp;function_address);<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;function_address;<br />}<br /><br />/*<br />Imports&nbsp;functions&nbsp;by&nbsp;hash.<br />Returns:<br />	0&nbsp;on&nbsp;no&nbsp;errors.<br />	&gt;0&nbsp;on&nbsp;failed&nbsp;import.&nbsp;Number&nbsp;indicates&nbsp;which&nbsp;import&nbsp;failed.<br />*/<br />int&nbsp;ImportFunctionsByHash(void)<br />{<br />	int&nbsp;import_number&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;kernel32_base_address&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;kernel32.dll&nbsp;base&nbsp;address<br />	kernel32_base_address&nbsp;=&nbsp;FindLoadedDLLBaseAddress(L&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;);<br /><br />	//&nbsp;import&nbsp;functions&nbsp;by&nbsp;hash<br />	d_Beep&nbsp;=&nbsp;(t_Beep)FindExportedDLLFunctionAddress(kernel32_base_address,&nbsp;hashed_Beep);<br />	if&nbsp;(d_Beep&nbsp;==&nbsp;NULL)<br />		return&nbsp;1;<br /><br />	return&nbsp;import_number;<br />}<br /><br /></div></div><br /><br /><strong>main.c</strong><br />This is where our main program code will go.<br />We first import the functions we want by hash, and then proceed as normal.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />#include&nbsp;&quot;noimport.h&quot;<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	int&nbsp;error_number&nbsp;=&nbsp;0;<br />	error_number&nbsp;=&nbsp;ImportFunctionsByHash();<br />	if&nbsp;(error_number&nbsp;&gt;&nbsp;0)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;import&nbsp;by&nbsp;hash:&nbsp;%d&nbsp;\n&quot;,&nbsp;error_number);<br />		return&nbsp;1;<br />	}<br /><br />	d_Beep(1000,&nbsp;2000);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /><br /><br /><br /><br /></div>
</body>
</html>
