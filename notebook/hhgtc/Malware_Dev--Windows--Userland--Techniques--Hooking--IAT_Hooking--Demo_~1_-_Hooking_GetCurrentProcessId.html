<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Demo #1 - Hooking GetCurrentProcessId</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Demo #1 - Hooking GetCurrentProcessId</h1></strong><br />Here I&#39;m going to hook <code>GetCurrentProcessId()</code> to return 1 instead of the real process ID.<br />This demo is running on <code>Windows 10 2004 19041.630</code> and all of the code is compiled as x64.<br />This includes:<br />• the target program<br />• the DLL to inject<br />• the DLL injector<br /><br /><strong><h2>## Setup / Code</h2></strong><br />Here is the program I&#39;ll be injecting into.<br />It simply prints the current process&#39;s process ID every 3 seconds.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	DWORD&nbsp;process_id&nbsp;=&nbsp;0;<br /><br />	while&nbsp;(TRUE)<br />	{<br />		process_id&nbsp;=&nbsp;GetCurrentProcessId();<br />		printf(&quot;process&nbsp;ID:&nbsp;%d&nbsp;\n&quot;,&nbsp;process_id);<br /><br />		Sleep(3000);<br />	}<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1690-1.png" alt="images/1690-1.png" /></a><br /><br /><a href=""><img src="images/1690-2.png" alt="images/1690-2.png" /></a><br /><br />Here&#39;s my DLL injection code:<br />(writes DLL path into target -&gt; creates thread in target to call LoadLibraryA)<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	LPVOID&nbsp;LoadLibraryA_address&nbsp;=&nbsp;NULL;<br />	char*&nbsp;dll_path&nbsp;=&nbsp;NULL;<br />	SIZE_T&nbsp;dll_path_len&nbsp;=&nbsp;0;<br />	int&nbsp;target_pid&nbsp;=&nbsp;0;<br />	HANDLE&nbsp;h_target&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_target_thread&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;target_memory&nbsp;=&nbsp;NULL;<br />	<br />	printf(&quot;#&nbsp;dll&nbsp;injector&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;Writes&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target&nbsp;and&nbsp;calls&nbsp;LoadLibraryA&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;advise&nbsp;running&nbsp;as&nbsp;Adminstrator&nbsp;\n&quot;);<br />	printf(&quot;\n&quot;);<br />	<br />	if&nbsp;(argc&nbsp;!=&nbsp;3)<br />	{<br />		printf(&quot;[-]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;dll_injector.exe&nbsp;[target&nbsp;pid]&nbsp;[dll&nbsp;path]&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br />	<br />	target_pid&nbsp;=&nbsp;atoi(argv[1]);<br />	dll_path&nbsp;=&nbsp;argv[2];<br />	dll_path_len&nbsp;=&nbsp;strlen(dll_path);<br /><br />	printf(&quot;[*]&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;target_pid);<br />	printf(&quot;[*]&nbsp;dll&nbsp;to&nbsp;inject:&nbsp;%s&nbsp;\n&quot;,&nbsp;dll_path);<br />	printf(&quot;[*]&nbsp;dll&nbsp;path&nbsp;len:&nbsp;%lld&nbsp;\n\n&quot;,&nbsp;dll_path_len);<br /><br />	//&nbsp;open&nbsp;handle&nbsp;to&nbsp;target&nbsp;process<br />	h_target&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;target_pid);<br />	if&nbsp;(h_target&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;handle&nbsp;to&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;opened&nbsp;handle&nbsp;to&nbsp;target&nbsp;process&nbsp;\n&quot;);<br /><br />	//&nbsp;allocate&nbsp;space&nbsp;for&nbsp;DLL&nbsp;path&nbsp;in&nbsp;target<br />	target_memory&nbsp;=&nbsp;VirtualAllocEx(h_target,&nbsp;NULL,&nbsp;dll_path_len,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_READWRITE);<br />	if&nbsp;(target_memory&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;allocated&nbsp;memory&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_memory);<br /><br />	//&nbsp;write&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target<br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_target,&nbsp;target_memory,&nbsp;(LPVOID)dll_path,&nbsp;dll_path_len,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		VirtualFreeEx(h_target,&nbsp;target_memory,&nbsp;dll_path_len,&nbsp;MEM_RELEASE);<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;dll&nbsp;path&nbsp;written&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_memory);<br /><br />	//&nbsp;grab&nbsp;address&nbsp;of&nbsp;LoadLibraryA<br />	/*<br />	The&nbsp;LoadLibraryA&nbsp;function&nbsp;exists&nbsp;in&nbsp;Kernel32.dll<br />	Kernel32.dll&nbsp;is&nbsp;loaded&nbsp;into&nbsp;every&nbsp;running&nbsp;process<br />	Kernel32.dll&nbsp;lives&nbsp;at&nbsp;the&nbsp;same&nbsp;location&nbsp;in&nbsp;every&nbsp;process:<br />	-&nbsp;0x753b0000&nbsp;on&nbsp;32bit<br />	-&nbsp;0x7ff9cfe10000&nbsp;on&nbsp;64bit<br /><br />	Therefore,&nbsp;we&nbsp;can&nbsp;simply&nbsp;grab&nbsp;the&nbsp;address&nbsp;of&nbsp;LoadLibraryA&nbsp;in&nbsp;our&nbsp;own&nbsp;process,&nbsp;<br />	and&nbsp;it&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;address&nbsp;for&nbsp;every&nbsp;other&nbsp;running&nbsp;process&nbsp;on&nbsp;the&nbsp;system.<br />	*/<br />	LoadLibraryA_address&nbsp;=&nbsp;(LPVOID)GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;),&nbsp;&quot;LoadLibraryA&quot;);<br />	printf(&quot;[+]&nbsp;LoadLibraryA&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;LoadLibraryA);<br /><br />	//&nbsp;create&nbsp;thread&nbsp;in&nbsp;target&nbsp;process&nbsp;to&nbsp;execute&nbsp;LoadLibraryA&nbsp;and&nbsp;load&nbsp;our&nbsp;DLL<br />	h_target_thread&nbsp;=&nbsp;CreateRemoteThread(h_target,&nbsp;NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)LoadLibraryA_address,&nbsp;target_memory,&nbsp;0,&nbsp;NULL);<br />	if&nbsp;(h_target_thread&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;thread&nbsp;in&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		VirtualFreeEx(h_target,&nbsp;target_memory,&nbsp;dll_path_len,&nbsp;MEM_RELEASE);<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;LoadLibraryA&nbsp;called&nbsp;in&nbsp;target!&nbsp;your&nbsp;DLL&nbsp;is&nbsp;being&nbsp;loaded...&nbsp;\n&quot;);<br /><br />	//&nbsp;wait&nbsp;for&nbsp;remote&nbsp;thread&nbsp;to&nbsp;exit<br />	//WaitForSingleObject(h_target_thread,&nbsp;INFINITE);<br /><br />	//&nbsp;free&nbsp;remote&nbsp;memory&nbsp;containing&nbsp;DLL&nbsp;path<br />	//VirtualFreeEx(h_target,&nbsp;target_memory,&nbsp;dll_path_len,&nbsp;MEM_RELEASE);<br /><br />cleanup:<br />	if&nbsp;(h_target)&nbsp;CloseHandle(h_target);<br />	if&nbsp;(h_target_thread)&nbsp;CloseHandle(h_target);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1690-3.png" alt="images/1690-3.png" /></a><br /><br />And here&#39;s the IAT hooking code.<br />This is compiled as a DLL and will be injected into the target process.<br />It hooks <code>GetCurrentProcessId()</code>.<br />The code is farily well commented so hopefully it&#39;s be readable.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />//&nbsp;typedefs&nbsp;of&nbsp;hooked&nbsp;functions<br />typedef&nbsp;int(__stdcall*&nbsp;t_GetCurrentProcessId)();<br />t_GetCurrentProcessId&nbsp;og_GetCurrentProcessId;<br /><br />int&nbsp;hooked_GetCurrentProcessId()<br />{<br />	return&nbsp;1;<br />}<br /><br />void&nbsp;HookFunctionsInIAT(void)<br />{<br />	LPVOID&nbsp;image_base&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;import_directory&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;import_lookup_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;import_address_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_BY_NAME&nbsp;import_name&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	//&nbsp;grab&nbsp;base&nbsp;address,&nbsp;DOS&nbsp;header,&nbsp;and&nbsp;PE&nbsp;header&nbsp;of&nbsp;host&nbsp;process<br />	image_base&nbsp;=&nbsp;(LPVOID)GetModuleHandleA(NULL);<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)image_base;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />	import_directory&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)image_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;DLLs&nbsp;in&nbsp;Import&nbsp;Directory<br />	while&nbsp;(import_directory-&gt;Name&nbsp;!=&nbsp;0)<br />	{<br />		import_lookup_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((DWORD_PTR)image_base&nbsp;+&nbsp;import_directory-&gt;OriginalFirstThunk);<br />		import_address_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((DWORD_PTR)image_base&nbsp;+&nbsp;import_directory-&gt;FirstThunk);<br /><br />		//&nbsp;loop&nbsp;through&nbsp;imported&nbsp;functions&nbsp;in&nbsp;DLL<br />		while&nbsp;(import_lookup_table-&gt;u1.AddressOfData&nbsp;!=&nbsp;0)<br />		{<br />			//&nbsp;if&nbsp;import&nbsp;by&nbsp;ordinal,&nbsp;skip&nbsp;because&nbsp;we&nbsp;can&#39;t&nbsp;hook&nbsp;ordinals<br />			if&nbsp;(IMAGE_SNAP_BY_ORDINAL(import_lookup_table-&gt;u1.Ordinal))<br />			{<br />				continue;<br />			}<br />			//&nbsp;if&nbsp;import&nbsp;by&nbsp;name<br />			else<br />			{<br />				//&nbsp;grab&nbsp;import&nbsp;name&nbsp;from&nbsp;IMAGE_IMPORT_NAME&nbsp;struct<br />				import_name&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)image_base&nbsp;+&nbsp;import_lookup_table-&gt;u1.AddressOfData);<br /><br />				//&nbsp;if&nbsp;we&#39;ve&nbsp;found&nbsp;GetCurrentProcessId<br />				if&nbsp;(strcmp(import_name-&gt;Name,&nbsp;&quot;GetCurrentProcessId&quot;)&nbsp;==&nbsp;0)<br />				{<br />					//&nbsp;save&nbsp;the&nbsp;function&nbsp;address<br />					og_GetCurrentProcessId&nbsp;=&nbsp;(t_GetCurrentProcessId)import_address_table-&gt;u1.Function;<br /><br />					//&nbsp;make&nbsp;writable&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;function&nbsp;in&nbsp;the&nbsp;Import&nbsp;Address&nbsp;Table<br />#ifdef&nbsp;_WIN64<br />					VirtualProtect(&amp;import_address_table-&gt;u1.Function,&nbsp;sizeof(ULONGLONG),&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />#else<br />					VirtualProtect(&amp;import_address_table-&gt;u1.Function,&nbsp;sizeof(DWORD),&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />#endif<br /><br />					//&nbsp;write&nbsp;address&nbsp;of&nbsp;hooked_GetCurrentProcessId&nbsp;function&nbsp;into&nbsp;IAT<br />					import_address_table-&gt;u1.Function&nbsp;=&nbsp;(DWORD_PTR)hooked_GetCurrentProcessId;<br /><br />					//&nbsp;revert&nbsp;Import&nbsp;Address&nbsp;Table&nbsp;back&nbsp;to&nbsp;original&nbsp;state<br />#ifdef&nbsp;_WIN64<br />					VirtualProtect(&amp;import_address_table-&gt;u1.Function,&nbsp;sizeof(ULONGLONG),&nbsp;old_protect,&nbsp;&amp;old_protect);<br />#else<br />					VirtualProtect(&amp;import_address_table-&gt;u1.Function,&nbsp;sizeof(DWORD),&nbsp;old_protect,&nbsp;&amp;old_protect);<br />#endif<br /><br />					break;<br />				}<br />			}<br /><br />			import_lookup_table++;<br />			import_address_table++;<br />		}<br /><br />		import_directory++;<br />	}<br /><br />	return;<br />}<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br /><span style="color:#000000;font-weight:400">{</span><br />	switch&nbsp;(fdwReason)<br />	{<br />	case&nbsp;DLL_PROCESS_ATTACH:<br />		HookFunctionsInIAT();<br />		break;<br />	case&nbsp;DLL_THREAD_ATTACH:<br />		break;<br />	case&nbsp;DLL_THREAD_DETACH:<br />		break;<br />	case&nbsp;DLL_PROCESS_DETACH:<br />		break;<br />	}<br /><br />	return&nbsp;TRUE;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1690-4.png" alt="images/1690-4.png" /></a><br /><br /><strong><h2>## Demo</h2></strong><br />I run my target program.<br /><code>GetCurrentProcessId()</code> is reporting the current process ID as <code>5236</code><br /><a href=""><img src="images/1690-5.png" alt="images/1690-5.png" /></a><br /><br />I inject my DLL into the target with my injector.<br />When attached, my DLL then hooks <code>GetCurrentProcessId</code> in the Import Address Table.<br /><br />The hook is successfull!<br />We can see that <code>GetCurrentProcessId</code> is now returning <code>1</code>.<br /><a href=""><img src="images/1690-6.png" alt="images/1690-6.png" /></a><br /><br />That&#39;s it! Simple as that.<br /><br />From Process Hacker, we can see that our DLL is loaded in the target process.<br /><a href=""><img src="images/1690-7.png" alt="images/1690-7.png" /></a><br /></div>
</body>
</html>
