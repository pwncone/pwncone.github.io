<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Physical Address vs Virtual Address vs Relative Virtual Address vs Raw Address</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Physical Address vs Virtual Address vs Relative Virtual Address vs Raw Address</h1></strong><br />• <a href="https://stackoverflow.com/questions/2170843/va-virtual-address-rva-relative-virtual-address">https://stackoverflow.com/questions/2170843/va-virtual-address-rva-relative-virtual-address</a><br /><br />• Physical Address is the address in physical memory/hardware (what the CPU sees)<br /><br />• Virtual Address is an address in virtual memory (the memory manager maps physical memory to virtual memory)<br />   ◇ e.g. <code>0x40001000</code><br /><br />• RVA - Relative Virtual Address - is an address relative to a Virtual Address<br />   ◇ the specification should tell you what Virtual Address it&#39;s relative to<br />   ◇ in PE files this is usually relative to the load base address<br />      ▪ e.g. <code>0x1000</code> - it&#39;s <code>0x1000</code> bytes from the image&#39;s base address<br /><br />• Raw Address is the address in the file on disk<br />   ◇ when a PE file gets mapped into memory- like with <code>CreateFileMapping</code> - you use the Virtual Address <br />   ◇ if you&#39;re examining a PE file on disk - like with <code>ReadFile</code> - you use the Raw Address<br />   ◇ sometimes Raw Addresses are also offsets offsets (if you&#39;re looking at PE files)<br /><br /><strong><h2>## What&#39;s the point of RVAs?</h2></strong><br />A PE file might not be loaded at it&#39;s preferred base address - e.g. <code>0x00400000</code><br />Therefore, RVAs are used to find values in the PE file once its been loaded into memory.<br /><br /><strong>To find a Relative Virtual Address</strong><br />Subtract <code>base address</code> from <code>virtual address</code> to find the relative virtual address.<br /><code>(virtual address)0x00401000 - (base address)0x00400000 = (RVA)0x1000</code><br /><br /><strong>To convert RVA to Virtual Address</strong><br />To convert RVA to Virtual Address, add <code>RVA</code> to <code>base address</code><br /><code>(base address)0x00400000 + (RVA)0x1000 = (virtual address)0x00401000</code><br /><br /><strong><h2>## Convert VA to Raw</h2></strong><br />You can also convert a virtual address to a raw address.<br /><br />The code below loops through the PE&#39;s sections,<br />and finds which section your <code>VirtualAddress</code> is in.<br /><br />It then calculates the <code>RawAddress</code> by:<br />• subtracting the start of the section from the <code>VirtualAddress</code> to find the Relative Virtual Address,<br />• and adds the RVA to the address of the start of the section on disk<br /><br /><div class="codebox"><div class="codebox">/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br /><span style="color:#000000;font-weight:400">{</span><br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br />		<br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## About Virtual Memory</h2></strong><br />Windows processes (.exe) run in Virtual Memory.<br />That is, each windows process has its own block of Virtual Memory only visible to itself.<br /><br />Virtual Memory provides each process the illusion that it has its own large, private address space.<br /><br />This allows executables to always start at the same based address:<br />• <code>0x00400000</code> for 32bit executables<br />• <code>0x0000000140000000</code> for 64bit executables<br /><br />The Windows memory manager maps a physical memory address to a virtual memory addresses.<br /><a href=""><img src="images/1531-1.png" alt="images/1531-1.png" /></a></div>
</body>
</html>
