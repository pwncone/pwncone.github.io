<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Relocations - PLT and GOT</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Linux - ELF - Dynamic Linking - PLT and GOT</h1></strong><br /><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html</a><br /><a href="https://blog.techorganic.com/2016/03/18/64-bit-linux-stack-smashing-tutorial-part-3/">https://blog.techorganic.com/2016/03/18/64-bit-linux-stack-smashing-tutorial-part-3/</a><br /><a href="https://www.youtube.com/watch?v=kUk5pw4w0h4&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=20&t=0s">https://www.youtube.com/watch?v=kUk5pw4w0h4</a><br /><br />Dynamic linking is where the required libraries for external functions you&#39;re using - like <code>printf()</code> from <code>libc</code> - get loaded into memory when the binary is run (at runtime).<br /><br />The memory address of the loaded library - <code>libc</code> - can be different every time.<br />This is due to things like:<br />• ASLR (which randomises the memory address of where your binary is loaded each time)<br />• OS differences<br />• library version differences<br />• etc.<br /><br />Therefore, because the address of the loaded library - <code>libc</code> - can change every time,<br />your binary needs a way to to find the location of where the library is loaded in memory and the memory address of the function it wants - like <code>printf()</code>.<br /><br />This is where the PLT and the GOT come in.<br /><br /><strong><h2>## PLT and GOT</h2></strong><br /><strong>PLT - Process Linkage Table</strong><br />The PLT has an entry for each library function in your binary.<br />Each entry contains a stub, which points that functions location in the GOT table<br /><br /><strong>GOT - Global Offset Table </strong><br />The GOT stores the memory addresses of the external library functions you&#39;re using.<br /><br /><div class="codebox"><div class="codebox">&nbsp;&nbsp;&nbsp;&nbsp;PLT&nbsp;Table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GOT&nbsp;Table<br />&lt;func&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;stub&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;stub&gt;&nbsp;&nbsp;&lt;func&nbsp;memory&nbsp;address&gt;<br />puts()&nbsp;&nbsp;&nbsp;-&nbsp;0x04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04&nbsp;-&nbsp;0x385966298248&nbsp;&nbsp;(memory&nbsp;address&nbsp;of&nbsp;puts())<br />printf()&nbsp;-&nbsp;0x06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x06&nbsp;-&nbsp;0x152980360123&nbsp;&nbsp;(memory&nbsp;address&nbsp;of&nbsp;printf())</div></div><br /><br /><strong>Diagram</strong><br />• <code>Library Functions</code> - These are the functions used in your code that are from libraries<br />• <code>PLT Table</code> - The PLT table points to a function&#39;s entry in the GOT table<br />• <code>GOT Table</code> - The GOT table contains the addresses to functions in libraries<br /><br /><a href=""><img src="images/599-1.png" alt="images/599-1.png" /></a><br /><br /><strong><h2>## Compile Time</h2></strong><br />At compile time, all external library functions that are to be dynamically linked are noted down as <code>relocation</code> types (R_386_32, for example).<br /><br />You can see the relocations in your binary using <br /><code>readelf --relocs &lt;binary&gt;</code><br /><br />The linker will then set up a series of memory sections for the relocations it needs to perform at runtime:<br /><code>.got</code>, <code>.plt</code>, <code>.got.plt</code> and <code>.plt.got</code><br /><br /><strong><h2>## Runtime - How Library Function Addresses Are Resolved</h2></strong><br />Upon compilation, the GOT table will be empty:<br /><div class="codebox"><div class="codebox">&nbsp;&nbsp;&nbsp;&nbsp;PLT&nbsp;Table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GOT&nbsp;Table<br />&lt;func&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;stub&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;stub&gt;&nbsp;&nbsp;&lt;func&nbsp;memory&nbsp;address&gt;<br />puts()&nbsp;&nbsp;&nbsp;-&nbsp;0x04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL<br />printf()&nbsp;-&nbsp;0x06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x06&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL</div></div><br /><br />At runtime, when your binary needs to run a linked/library function, it queries the PLT table entry for that function.<br />   ◇ The PLT table entry contains a stub which points that function&#39;s entry in the <em>Global Offset Table</em><br />   ◇ The PLT then reads the GOT table sees that the GOT doesn&#39;t have an address for that function<br /><br />Because the GOT table doesn&#39;t contain an address for that function, it looks it up.<br />   ◇ The GOT table runs a function called <code>_dl_runtime_resolve</code> which is part of <code>ld.so</code> - Linux&#39;s dynamic linker/loader. <br />   ◇ The <code>_dl_runtime_resolve</code> function will find the address of the function you&#39;re calling - e.g. find the address of <code>printf()</code> in <code>libc</code> - and writes that address to the <code>GOT - Global Offset Table</code><br /><br /><a href=""><img src="images/599-2.png" alt="images/599-2.png" /></a><br /><br />Now, whenever that function is called again - e.g. printf() - the PLT table will use its stub to read the function&#39;s address from the GOT table and jump straight to that function - e.g. jump straight to printf() in libc.<br /><br /></div>
</body>
</html>
