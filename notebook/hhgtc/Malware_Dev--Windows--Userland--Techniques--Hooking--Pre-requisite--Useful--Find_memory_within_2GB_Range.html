<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Find memory within 2GB Range</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Useful - Find memory within 2GB range</h1></strong><br /><strong>Links</strong><br />• <a href="https://github.com/nettitude/InlineFunctionHooking/blob/21ff3e7f2c32601713fa2cb24830bd426d5a03ad/HookEngine/HookEngine.cpp#L281">https://github.com/nettitude/InlineFunctionHooking/blob/21ff3e7f2c32601713fa2cb24830bd426d5a03ad/HookEngine/HookEngine.cpp#L281</a><br />• <a href="https://stackoverflow.com/questions/54729401/allocating-memory-within-a-2gb-range">https://stackoverflow.com/questions/54729401/allocating-memory-within-a-2gb-range</a><br />• <a href="https://github.com/TsudaKageyu/minhook/blob/423d1e45af2ed2719a5c31e990e935ef301ed9c3/src/buffer.c#L89">https://github.com/TsudaKageyu/minhook/blob/423d1e45af2ed2719a5c31e990e935ef301ed9c3/src/buffer.c#L89</a><br />• <a href="http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html">http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html</a> - Check his AllocPageNearAddress() func<br /><br /><div class="codebox"><div class="codebox">/*<br />Inspiration&nbsp;for&nbsp;the&nbsp;code&nbsp;is&nbsp;from&nbsp;here:<br />https://github.com/TsudaKageyu/minhook/blob/423d1e45af2ed2719a5c31e990e935ef301ed9c3/src/buffer.c#L89<br />All&nbsp;credit&nbsp;goes&nbsp;there.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />void*&nbsp;FindMemoryWithin2GBRange(void*&nbsp;base)<br />{<br />	SYSTEM_INFO&nbsp;sys_info&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	MEMORY_BASIC_INFORMATION&nbsp;mbi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	size_t&nbsp;ret&nbsp;=&nbsp;0;<br /><br />	UINT_PTR&nbsp;mem_address&nbsp;=&nbsp;(UINT_PTR)base;<br />	UINT_PTR&nbsp;min_addr&nbsp;=&nbsp;mem_address&nbsp;-&nbsp;0x7FFFFFFF;		//&nbsp;+&nbsp;2gb<br />	UINT_PTR&nbsp;max_addr&nbsp;=&nbsp;mem_address&nbsp;+&nbsp;0x7FFFFFFF;		//&nbsp;-&nbsp;2gb<br /><br />	/*<br />	Grab&nbsp;allocation&nbsp;granularity&nbsp;(boundary&nbsp;on&nbsp;which&nbsp;memory&nbsp;aligns,&nbsp;usually&nbsp;0x10000&nbsp;-&nbsp;65kb)<br />	and&nbsp;calculate&nbsp;start&nbsp;address&nbsp;to&nbsp;search&nbsp;from&nbsp;by&nbsp;rounding&nbsp;down&nbsp;to&nbsp;the&nbsp;nearest&nbsp;allocation&nbsp;granularity.<br />	*/<br />	GetSystemInfo(&amp;sys_info);<br />	mem_address&nbsp;-=&nbsp;mem_address&nbsp;%&nbsp;sys_info.dwAllocationGranularity;<br /><br />	//&nbsp;Search&nbsp;for&nbsp;memory&nbsp;below<br />	do<br />	{<br />		ret&nbsp;=&nbsp;VirtualQuery((void*)mem_address,&nbsp;&amp;mbi,&nbsp;sizeof(mbi));<br />		if&nbsp;(ret&nbsp;==&nbsp;0)	//&nbsp;if&nbsp;VirtualQuery&nbsp;failed<br />			break;<br /><br />		if&nbsp;(mbi.State&nbsp;==&nbsp;MEM_FREE)<br />			return&nbsp;(void*)mem_address;<br /><br />		/*<br />		AllocationBase&nbsp;points&nbsp;to&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;the&nbsp;range&nbsp;of&nbsp;pages&nbsp;queried&nbsp;by&nbsp;VirtualAlloc.<br />		e.g.<br />			You&nbsp;VirtualQuery&nbsp;an&nbsp;address&nbsp;in&nbsp;the&nbsp;middle&nbsp;of&nbsp;User32.dll&nbsp;-&nbsp;0x7ffecbcfacf0<br />			mbi.AllocationBase&nbsp;will&nbsp;be&nbsp;0x7ffecbc80000&nbsp;(the&nbsp;address&nbsp;of&nbsp;User32.dll)<br />		Subtract&nbsp;the&nbsp;dwAllocationGranulairty&nbsp;to&nbsp;find&nbsp;the&nbsp;next&nbsp;memory&nbsp;page&nbsp;to&nbsp;query.<br />		*/<br />		mem_address&nbsp;=&nbsp;(UINT_PTR)mbi.AllocationBase&nbsp;-&nbsp;sys_info.dwAllocationGranularity;<br />	}&nbsp;while&nbsp;(mem_address&nbsp;&gt;=&nbsp;min_addr);<br /><br />	//&nbsp;Search&nbsp;for&nbsp;memory&nbsp;above<br />	mem_address&nbsp;-=&nbsp;mem_address&nbsp;%&nbsp;sys_info.dwAllocationGranularity;		//&nbsp;Reset&nbsp;start&nbsp;address<br />	do<br />	{<br />		ret&nbsp;=&nbsp;VirtualQuery((void*)mem_address,&nbsp;&amp;mbi,&nbsp;sizeof(mbi));<br />		if&nbsp;(ret&nbsp;==&nbsp;0)	//&nbsp;if&nbsp;VirtualQuery&nbsp;failed<br />			break;<br /><br />		if&nbsp;(mbi.State&nbsp;==&nbsp;MEM_FREE)<br />			return&nbsp;(void*)mem_address;<br /><br />		//&nbsp;Calculate&nbsp;end&nbsp;of&nbsp;queried&nbsp;memory&nbsp;region<br />		mem_address&nbsp;=&nbsp;(UINT_PTR)mbi.BaseAddress&nbsp;+&nbsp;mbi.RegionSize;<br />		//&nbsp;Add&nbsp;allocation&nbsp;granularity&nbsp;(-1&nbsp;in&nbsp;case&nbsp;memory&nbsp;regions&nbsp;are&nbsp;spaced&nbsp;0x10000&nbsp;bytes&nbsp;(size&nbsp;of&nbsp;dwAllocationGranularity)&nbsp;between&nbsp;eachother)<br />		mem_address&nbsp;+=&nbsp;sys_info.dwAllocationGranularity&nbsp;-&nbsp;1;<br />		//&nbsp;Round&nbsp;down&nbsp;to&nbsp;allocation&nbsp;granularity<br />		mem_address&nbsp;-=&nbsp;mem_address&nbsp;%&nbsp;sys_info.dwAllocationGranularity;<br /><br />	}&nbsp;while&nbsp;(mem_address&nbsp;&gt;=&nbsp;min_addr);<br /><br />	return&nbsp;NULL;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	void*&nbsp;target_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(&quot;User32.dll&quot;),&nbsp;&quot;MessageBoxA&quot;);<br />	void*&nbsp;free_memory&nbsp;=&nbsp;FindMemoryWithin2GBRange(target_func);<br />	if&nbsp;(free_memory&nbsp;!=&nbsp;NULL)<br />		printf(&quot;[*]&nbsp;free&nbsp;memory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;free_memory);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
