<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Retrieving syscalls from Disk</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Retrieving syscalls from Disk</h1></strong><br />â€¢ <a href="https://www.ired.team/offensive-security/defense-evasion/retrieving-ntdll-syscall-stubs-at-run-time">https://www.ired.team/offensive-security/defense-evasion/retrieving-ntdll-syscall-stubs-at-run-time</a><br /><br />DISCLAIMER:<br />Apologies to self because my explanation here is terrible. Writing fails me today. If you can read the code, the code should explain itself. Find function bytes &gt; save them to a var &gt; make them executable &gt; execute them. That&#39;s it.<br /><br />Syscall values for functions can change between versions of Windows.<br />By retrieving the syscall bytes from disk, you avoid hardcoding the syscall values into your code and your program will be portable across different versions of Windows.<br /><br />Here are the syscall bytes for <code>NQueryInformationProcess</code> from Ntdll.dll:<br />(I&#39;m on Windows 10 x64 2004 19041.746)<br /><div class="codebox"><div class="codebox">lkd&gt;&nbsp;u&nbsp;Ntdll!NtQueryInformationProcess<br />ntdll!NtQueryInformationProcess:<br />00007ff8`9498c2c0&nbsp;4c8bd1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r10,rcx<br />00007ff8`9498c2c3&nbsp;b819000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eax,19h<br />00007ff8`9498c2c8&nbsp;f604250803fe7f01&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;ptr&nbsp;[SharedUserData+0x308&nbsp;(00000000`7ffe0308)],1<br />00007ff8`9498c2d0&nbsp;7503&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ntdll!NtQueryInformationProcess+0x15&nbsp;(00007ff8`9498c2d5)<br />00007ff8`9498c2d2&nbsp;0f05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syscall<br />00007ff8`9498c2d4&nbsp;c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret<br />00007ff8`9498c2d5&nbsp;cd2e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2Eh<br />00007ff8`9498c2d7&nbsp;c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret</div></div><br /><br />If we want to call NtQueryInformationProcess, we&#39;ll need to save all of the bytes up to the <code>syscall; ret</code> instruction.<br />That&#39;s 21 bytes in total.<br /><br />To retrieve the syscall bytes for NtQueryInformationProcess from disk, <br />we can loop through Ntdll.dll until we find NtQueryInformationProcess, save the bytes at that function into a char[] array, mark our saved bytes as executable, and then cast them to a typedef of NtQueryInformationProcess.<br /><br />For example, here is our typedef for <code>NtQueryInformationProcess</code><br /><div class="codebox"><div class="codebox">typedef&nbsp;NTSTATUS(__kernel_entry*&nbsp;t_NtQueryInformationProcess)(<br />	HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />	PROCESSINFOCLASS&nbsp;ProcessInformationClass,<br />	PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformation,<br />	ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformationLength,<br />	PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength<br />	);</div></div><br /><br />Here is the char array where we&#39;ll save the 21 bytes needed for the syscall:<br /><div class="codebox"><div class="codebox">#define&nbsp;N_SYSCALL_BTYES&nbsp;21<br />char&nbsp;syscallbytes_NtQueryInformationProcess[N_SYSCALL_BTYES]&nbsp;=&nbsp;{&nbsp;0&nbsp;};</div></div><br /><br />And here is the char array containing the syscall bytes being typecasted to an NtQueryInformationProcess function.<br />To call NtQueryInformationProcess using our syscall bytes, we&#39;ll call <code>syscall_NtQueryInformationProcess();</code><br /><div class="codebox"><div class="codebox">t_NtQueryInformationProcess&nbsp;syscall_NtQueryInformationProcess&nbsp;=&nbsp;(t_NtQueryInformationProcess)syscallbytes_NtQueryInformationProcess;</div></div><br /><br /><strong><h2>## Demo</h2></strong><br />In this demo I&#39;ve queried for the PEB address of Notepad.exe (process ID 5124).<br />First we&#39;ve found the syscall bytes for <code>NtQueryInformationProcess</code> (and NtClose too just for demo purposes),<br />and then executed those bytes to call NtQueryInformationProcess.<br /><br />We can verify that the syscall has worked because <code>NtQueryInformationProcess</code> has returned the correct PEB base address (as shown in Process Hacker&#39;s notepad.exe properties).<br /><br /><a href=""><img src="images/1717-1.png" alt="images/1717-1.png" /></a><br /><br /><br /><strong><h2>## Simple Code</h2></strong><br />This is a simple implementation that hopefully shows the technique.<br />It doesn&#39;t have any of the extra prints like in the demo and <code>GrabSyscallFromNtdll()</code> retrieves the syscall bytes for 1 function at a time<br /><br /><div class="codebox"><div class="codebox">/*<br />Compiled&nbsp;as&nbsp;Debug&nbsp;x64&nbsp;on&nbsp;Windows&nbsp;10&nbsp;x64&nbsp;2004&nbsp;with&nbsp;Visual&nbsp;Studio&nbsp;2019.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />/*<br />Number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read&nbsp;@&nbsp;function.<br />On&nbsp;Windows&nbsp;10&nbsp;x64&nbsp;2004&nbsp;(19041.746),&nbsp;need&nbsp;to&nbsp;read&nbsp;21&nbsp;bytes&nbsp;to&nbsp;reach&nbsp;`syscall;&nbsp;ret`&nbsp;for&nbsp;each&nbsp;Nt&nbsp;function.<br />*/<br />#define&nbsp;N_SYSCALL_BTYES&nbsp;21<br /><br />//&nbsp;Nt&nbsp;FUNCTION&nbsp;TYPEDEFS<br />//&nbsp;-----------------------------------------------------<br />char&nbsp;syscallbytes_NtQueryInformationProcess[N_SYSCALL_BTYES]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />typedef&nbsp;NTSTATUS(__kernel_entry*&nbsp;t_NtQueryInformationProcess)(<br />	HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />	PROCESSINFOCLASS&nbsp;ProcessInformationClass,<br />	PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformation,<br />	ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformationLength,<br />	PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength<br />	);<br />t_NtQueryInformationProcess&nbsp;syscall_NtQueryInformationProcess&nbsp;=&nbsp;(t_NtQueryInformationProcess)syscallbytes_NtQueryInformationProcess;<br /><br />//&nbsp;CODE<br />//&nbsp;-----------------------------------------------------<br /><br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Opens&nbsp;Ntdll.dll&nbsp;from&nbsp;disk&nbsp;and&nbsp;loops&nbsp;through&nbsp;its&nbsp;export&nbsp;table&nbsp;to&nbsp;find&nbsp;your&nbsp;desired&nbsp;function.<br />It&nbsp;will&nbsp;then&nbsp;save&nbsp;the&nbsp;function&#39;s&nbsp;bytes&nbsp;into&nbsp;the&nbsp;into&nbsp;the&nbsp;`char*&nbsp;syscall_bytes`&nbsp;variable&nbsp;and&nbsp;mark&nbsp;them&nbsp;as&nbsp;executable.<br /><br />Parameters:<br />	char*&nbsp;function_name&nbsp;-&nbsp;Name&nbsp;of&nbsp;the&nbsp;Ntdll.dll&nbsp;function&nbsp;you&nbsp;want&nbsp;to&nbsp;grab&nbsp;the&nbsp;syscall&nbsp;bytes&nbsp;for<br />	char*&nbsp;syscall_bytes&nbsp;-&nbsp;A&nbsp;char&nbsp;arary&nbsp;to&nbsp;store&nbsp;the&nbsp;syscall&nbsp;bytes&nbsp;at<br />*/<br />BOOL&nbsp;GrabSyscallFromNtdll(char*&nbsp;function_name,&nbsp;char*&nbsp;syscall_bytes)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br /><br />	LPVOID&nbsp;ntdll_buf&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;buf_size&nbsp;=&nbsp;0;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_dir&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;name_pointer_table&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;ordinal_table&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_address_table&nbsp;=&nbsp;NULL;<br />	char*&nbsp;export_name&nbsp;=&nbsp;NULL;<br />	SIZE_T&nbsp;export_buf_addr&nbsp;=&nbsp;0;<br /><br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Open&nbsp;Ntdll.dll&nbsp;and&nbsp;read&nbsp;it&nbsp;into&nbsp;a&nbsp;buffer<br />	ntdll_buf&nbsp;=&nbsp;ReadFileIntoBuffer(&quot;C:\\Windows\\System32\\Ntdll.dll&quot;,&nbsp;&amp;buf_size);<br />	if&nbsp;(ntdll_buf&nbsp;==&nbsp;NULL)<br />		goto&nbsp;cleanup;<br /><br />	//&nbsp;Grab&nbsp;Ntdll.dll&nbsp;export&nbsp;directory<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)ntdll_buf;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((SIZE_T)dos_header&nbsp;+&nbsp;(SIZE_T)dos_header-&gt;e_lfanew);<br />	export_dir&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress));<br /><br />	export_address_table&nbsp;=&nbsp;(DWORD*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_dir-&gt;AddressOfFunctions));<br />	name_pointer_table&nbsp;=&nbsp;(DWORD*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_dir-&gt;AddressOfNames));<br />	ordinal_table&nbsp;=&nbsp;(WORD*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_dir-&gt;AddressOfNameOrdinals));<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;Ntdll.dll&nbsp;exports<br />	for&nbsp;(DWORD&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;export_dir-&gt;NumberOfNames;&nbsp;j++)<br />	{<br />		//&nbsp;Grab&nbsp;export&nbsp;name&nbsp;&amp;&nbsp;address&nbsp;of&nbsp;function&nbsp;in&nbsp;buffer<br />		export_name&nbsp;=&nbsp;(char*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;name_pointer_table[j]));<br />		export_buf_addr&nbsp;=&nbsp;(SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_address_table[ordinal_table[j]]);<br /><br />		//&nbsp;If&nbsp;it&#39;s&nbsp;the&nbsp;function&nbsp;we&nbsp;want<br />		if&nbsp;(strcmp(export_name,&nbsp;function_name)&nbsp;==&nbsp;0)<br />		{<br />			//&nbsp;Save&nbsp;the&nbsp;syscall&nbsp;bytes&nbsp;1&nbsp;by&nbsp;1<br />			for&nbsp;(int&nbsp;k&nbsp;=&nbsp;0;&nbsp;k&nbsp;&lt;&nbsp;N_SYSCALL_BTYES;&nbsp;k++)<br />				memcpy_s((BYTE*)syscall_bytes&nbsp;+&nbsp;k,&nbsp;1,&nbsp;(BYTE*)export_buf_addr&nbsp;+&nbsp;k,&nbsp;1);<br /><br />			//&nbsp;Make&nbsp;those&nbsp;bytes&nbsp;executable<br />			b_ret&nbsp;=&nbsp;VirtualProtect(syscall_bytes,&nbsp;N_SYSCALL_BTYES,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />			if&nbsp;(b_ret&nbsp;=&nbsp;FALSE)<br />			{<br />				printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;mark&nbsp;syscall&nbsp;bytes&nbsp;as&nbsp;executable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />				ok&nbsp;=&nbsp;FALSE;<br />				goto&nbsp;cleanup;<br />			}<br />			<br />			break;<br />		}<br />	}<br /><br />cleanup:<br />	if&nbsp;(ntdll_buf)&nbsp;free(ntdll_buf);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	if&nbsp;(argc&nbsp;!=&nbsp;2)<br />	{<br />		printf(&quot;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;binary.exe&nbsp;&lt;process_id&gt;&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	GrabSyscallFromNtdll(&quot;NtQueryInformationProcess&quot;,&nbsp;syscallbytes_NtQueryInformationProcess);<br /><br />	int&nbsp;process_id&nbsp;=&nbsp;atoi(argv[1]);<br />	HANDLE&nbsp;h_process&nbsp;=&nbsp;NULL;<br />	PROCESS_BASIC_INFORMATION&nbsp;pbi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	h_process&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;process_id);<br />	syscall_NtQueryInformationProcess(h_process,&nbsp;ProcessBasicInformation,&nbsp;&amp;pbi,&nbsp;sizeof(pbi),&nbsp;NULL);<br />	printf(&quot;[+]&nbsp;PEB&nbsp;base&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pbi.PebBaseAddress);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Complete Code</h2></strong><br />This is a more complete version of the code above that saves all of the functions to syscall into a struct and loops through it, finding the syscall bytes.<br />This is the code seen in the demo.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />/*<br />Number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read&nbsp;@&nbsp;function.<br />On&nbsp;Windows&nbsp;10&nbsp;x64&nbsp;2004&nbsp;(19041.746),&nbsp;need&nbsp;to&nbsp;read&nbsp;21&nbsp;bytes&nbsp;to&nbsp;reach&nbsp;`syscall;&nbsp;ret`&nbsp;for&nbsp;each&nbsp;Nt&nbsp;function.<br />*/<br />#define&nbsp;N_SYSCALL_BTYES&nbsp;21<br /><br />//&nbsp;Nt&nbsp;FUNCTION&nbsp;TYPEDEFS<br />//&nbsp;-----------------------------------------------------<br />char&nbsp;syscallbytes_NtQueryInformationProcess[N_SYSCALL_BTYES]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />typedef&nbsp;NTSTATUS(__kernel_entry&nbsp;*t_NtQueryInformationProcess)(<br />	HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />	PROCESSINFOCLASS&nbsp;ProcessInformationClass,<br />	PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformation,<br />	ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformationLength,<br />	PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength<br />	);<br />t_NtQueryInformationProcess&nbsp;syscall_NtQueryInformationProcess&nbsp;=&nbsp;(t_NtQueryInformationProcess)syscallbytes_NtQueryInformationProcess;<br /><br />char&nbsp;syscallbytes_NtClose[N_SYSCALL_BTYES]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />typedef&nbsp;NTSTATUS(__kernel_entry&nbsp;*t_NtClose)(HANDLE&nbsp;Handle);<br />t_NtClose&nbsp;syscall_NtClose&nbsp;=&nbsp;(t_NtClose)syscallbytes_NtClose;<br /><br />//&nbsp;SYSCALL&nbsp;STRUCT<br />//&nbsp;-----------------------------------------------------<br />struct&nbsp;SYSCALL_FUNCTIONS<br />{<br />	char*&nbsp;function_name;<br />	char*&nbsp;syscall_bytes;<br />};<br /><br />struct&nbsp;SYSCALL_FUNCTIONS&nbsp;SyscallFunctionList[]&nbsp;=<br />{<br />	{&quot;NtQueryInformationProcess&quot;,&nbsp;syscallbytes_NtQueryInformationProcess},<br />	{&quot;NtClose&quot;,&nbsp;syscallbytes_NtClose}<br />};<br /><br />//&nbsp;CODE<br />//&nbsp;-----------------------------------------------------<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Opens&nbsp;Ntdll.dll&nbsp;from&nbsp;disk,&nbsp;finds&nbsp;its&nbsp;export&nbsp;table,&nbsp;and&nbsp;loops&nbsp;through&nbsp;the&nbsp;functions&nbsp;in&nbsp;the&nbsp;export&nbsp;table&nbsp;<br />to&nbsp;find&nbsp;the&nbsp;functions&nbsp;we&nbsp;want&nbsp;from&nbsp;the&nbsp;SyscallFunctionList&nbsp;struct.<br /><br />Upon&nbsp;finding&nbsp;a&nbsp;desired&nbsp;function,&nbsp;<br />it&nbsp;will&nbsp;save&nbsp;the&nbsp;functions&nbsp;byte&#39;s&nbsp;up&nbsp;to&nbsp;`syscall;&nbsp;ret`&nbsp;into&nbsp;a&nbsp;char*&nbsp;variable&nbsp;and&nbsp;mark&nbsp;them&nbsp;as&nbsp;executable.<br />*/<br />BOOL&nbsp;GrabSyscallsFromNtdll(void)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;ntdll_buf&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_dir&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;name_pointer_table&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;ordinal_table&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_address_table&nbsp;=&nbsp;NULL;<br />	char*&nbsp;export_name&nbsp;=&nbsp;NULL;<br />	SIZE_T&nbsp;export_buf_addr&nbsp;=&nbsp;0;<br /><br />	int&nbsp;syscall_count&nbsp;=&nbsp;0;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	printf(&quot;[*]&nbsp;retrieving&nbsp;syscalls&nbsp;\n&quot;);<br /><br />	//&nbsp;Open&nbsp;Ntdll.dll<br />	h_file&nbsp;=&nbsp;CreateFileA(&quot;C:\\Windows\\System32\\Ntdll.dll&quot;,&nbsp;GENERIC_READ,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;Ntdll.dll:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;Get&nbsp;size,&nbsp;create&nbsp;buffer,&nbsp;and&nbsp;read&nbsp;Ntdll.dll&nbsp;into&nbsp;buffer<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	ntdll_buf&nbsp;=&nbsp;malloc(file_size);<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;ntdll_buf,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;Ntdll.dll&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;+&nbsp;read&nbsp;Ntdll.dll&nbsp;into&nbsp;buffer&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ntdll_buf);<br /><br />	//&nbsp;Grab&nbsp;Ntdll.dll&nbsp;export&nbsp;directory<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)ntdll_buf;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((SIZE_T)dos_header&nbsp;+&nbsp;(SIZE_T)dos_header-&gt;e_lfanew);<br />	export_dir&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress));<br /><br />	export_address_table&nbsp;=&nbsp;(DWORD*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_dir-&gt;AddressOfFunctions));<br />	name_pointer_table&nbsp;=&nbsp;(DWORD*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_dir-&gt;AddressOfNames));<br />	ordinal_table&nbsp;=&nbsp;(WORD*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_dir-&gt;AddressOfNameOrdinals));<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;syscall&nbsp;list<br />	syscall_count&nbsp;=&nbsp;sizeof(SyscallFunctionList)&nbsp;/&nbsp;sizeof(struct&nbsp;SYSCALL_FUNCTIONS);<br />	printf(&quot;\t&nbsp;*&nbsp;number&nbsp;of&nbsp;syscalls&nbsp;to&nbsp;find:&nbsp;%d&nbsp;\n&quot;,&nbsp;syscall_count);<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;syscall_count;&nbsp;i++)<br />	{<br />		printf(&quot;\t&nbsp;*&nbsp;searching&nbsp;for&nbsp;%s&nbsp;\n&quot;,&nbsp;SyscallFunctionList[i].function_name);<br />		<br />		//&nbsp;Loop&nbsp;through&nbsp;Ntdll.dll&nbsp;exports<br />		for&nbsp;(DWORD&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;export_dir-&gt;NumberOfNames;&nbsp;j++)<br />		{<br />			//&nbsp;Grab&nbsp;export&nbsp;name&nbsp;&amp;&nbsp;address&nbsp;of&nbsp;function&nbsp;in&nbsp;buffer<br />			export_name&nbsp;=&nbsp;(char*)((SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;name_pointer_table[j]));<br />			export_buf_addr&nbsp;=&nbsp;(SIZE_T)ntdll_buf&nbsp;+&nbsp;va2raw(ntdll_buf,&nbsp;export_address_table[ordinal_table[j]]);<br /><br />			//&nbsp;If&nbsp;it&#39;s&nbsp;the&nbsp;function&nbsp;we&nbsp;want<br />			if&nbsp;(strcmp(export_name,&nbsp;SyscallFunctionList[i].function_name)&nbsp;==&nbsp;0)<br />			{<br />				printf(&quot;\t\t&nbsp;+&nbsp;found&nbsp;@&nbsp;0x%zx&nbsp;\n&quot;,&nbsp;export_buf_addr);<br /><br />				//&nbsp;Save&nbsp;the&nbsp;syscall&nbsp;bytes&nbsp;1&nbsp;by&nbsp;1<br />				for&nbsp;(int&nbsp;k&nbsp;=&nbsp;0;&nbsp;k&nbsp;&lt;&nbsp;N_SYSCALL_BTYES;&nbsp;k++)<br />					memcpy_s((BYTE*)SyscallFunctionList[i].syscall_bytes&nbsp;+&nbsp;k,&nbsp;1,&nbsp;(BYTE*)export_buf_addr&nbsp;+&nbsp;k,&nbsp;1);<br /><br />				printf(&quot;\t\t&nbsp;+&nbsp;copied&nbsp;syscall&nbsp;bytes&nbsp;to:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;SyscallFunctionList[i].syscall_bytes);<br />				<br />				printf(&quot;\t\t&nbsp;*&nbsp;syscall&nbsp;bytes&nbsp;=&nbsp;&quot;);<br />				for&nbsp;(int&nbsp;l&nbsp;=&nbsp;0;&nbsp;l&nbsp;&lt;&nbsp;N_SYSCALL_BTYES;&nbsp;l++)<br />					printf(&quot;%02hhX&nbsp;&quot;,&nbsp;SyscallFunctionList[i].syscall_bytes[l]);<br />				printf(&quot;\n&quot;);<br /><br />				//&nbsp;Make&nbsp;those&nbsp;bytes&nbsp;executable<br />				b_ret&nbsp;=&nbsp;VirtualProtect(SyscallFunctionList[i].syscall_bytes,&nbsp;N_SYSCALL_BTYES,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />				if&nbsp;(b_ret&nbsp;=&nbsp;FALSE)<br />				{<br />					printf(&quot;\t\t&nbsp;-&nbsp;failed&nbsp;to&nbsp;mark&nbsp;syscall&nbsp;bytes&nbsp;as&nbsp;executable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />					ok&nbsp;=&nbsp;FALSE;<br />					goto&nbsp;cleanup;<br />				}<br />				printf(&quot;\t\t&nbsp;+&nbsp;set&nbsp;bytes&nbsp;@&nbsp;0x%p&nbsp;as&nbsp;EXECUTE_READWRITE&nbsp;\n&quot;,&nbsp;SyscallFunctionList[i].syscall_bytes);<br />				<br />				printf(&quot;\t\t&nbsp;+&nbsp;%s&nbsp;syscall&nbsp;ready&nbsp;\n&quot;,&nbsp;SyscallFunctionList[i].function_name);<br />				<br />				//&nbsp;Move&nbsp;on&nbsp;to&nbsp;next&nbsp;item&nbsp;in&nbsp;syscall&nbsp;list<br />				break;<br />			}<br />		}<br />	}<br /><br />cleanup:<br />	if&nbsp;(ntdll_buf)&nbsp;free(ntdll_buf);<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br />	<br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	if&nbsp;(argc&nbsp;!=&nbsp;2)<br />	{<br />		printf(&quot;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;binary.exe&nbsp;&lt;process_id&gt;&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	GrabSyscallsFromNtdll();<br /><br />	int&nbsp;process_id&nbsp;=&nbsp;atoi(argv[1]);<br />	HANDLE&nbsp;h_process&nbsp;=&nbsp;NULL;<br />	PROCESS_BASIC_INFORMATION&nbsp;pbi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	h_process&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;process_id);<br />	syscall_NtQueryInformationProcess(h_process,&nbsp;ProcessBasicInformation,&nbsp;&amp;pbi,&nbsp;sizeof(pbi),&nbsp;NULL);<br />	printf(&quot;[+]&nbsp;PEB&nbsp;base&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pbi.PebBaseAddress);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
