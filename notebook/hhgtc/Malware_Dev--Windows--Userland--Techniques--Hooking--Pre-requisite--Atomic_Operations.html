<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Atomic Operations</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Thread-safe / Atomic Operations</h1></strong><br />Because you&#39;re overwriting the bytes of a function, <br />what happens if you overwrite the bytes whilst another thread is executing them? <br />You&#39;ll run into problems.<br /><br />Most of the time this won&#39;t happen, <br />but to fix this issue you can use atomic operations.<br /><a href="https://stackoverflow.com/questions/52196678/what-are-atomic-operations-for-newbies">https://stackoverflow.com/questions/52196678/what-are-atomic-operations-for-newbies</a><br /><br />Atomic operations mean that no other thread will be able to see your modifications until they&#39;re finished.<br /><br /><strong><h2>## WinAPI - InterlockedExchange</h2></strong><br />For atomic operations via the Windows API, <br />you can use InterlockedExchange:<br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchange">https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchange</a><br /><br /><strong><h3>### 32bit Bad Example</h3></strong><br />Including for reference sake. This is a bad use of InterlockedExchange.<br />I only want to write 2 bytes to the address - EB F9 - but InterlockedExchange takes a 4 byte value <br />so I&#39;m forced to write extra data.<br />The extra data are the original instructions found at that function.<br /><br />This works, but it&#39;s not ideal.<br /><br /><div class="codebox"><div class="codebox">/*<br />Here&#39;&nbsp;I&#39;m&nbsp;writing&nbsp;4&nbsp;bytes&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;a&nbsp;function:<br />EB&nbsp;F9&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;short<br />55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;ebp<br />8B&nbsp;(EC)&nbsp;&nbsp;mov&nbsp;ebp,&nbsp;esp<br />*/<br /><br />InterlockedExchange((LONG*)func_addr,&nbsp;0x8B55F9EB);</div></div><br /><br /><strong><h3>### 32bit Good Example</h3></strong><br />Examples:<br />• <a href="http://www.rohitab.com/discuss/topic/29465-api-hooking/?p=10033488">http://www.rohitab.com/discuss/topic/29465-api-hooking/?p=10033488</a><br /><br /><div class="codebox"><div class="codebox">/*<br />*(DWORD*)orig_func&nbsp;grabs&nbsp;the&nbsp;data&nbsp;@&nbsp;func_addr.<br />AND&nbsp;the&nbsp;data&nbsp;at&nbsp;func_addr&nbsp;with&nbsp;0xFFFF0000&nbsp;(to&nbsp;grab&nbsp;the&nbsp;first&nbsp;2&nbsp;bytes&nbsp;@&nbsp;func_addr)<br />and&nbsp;then&nbsp;OR&nbsp;that&nbsp;data&nbsp;with&nbsp;0xF9EB&nbsp;(to&nbsp;overwrite&nbsp;the&nbsp;2&nbsp;bytes).<br />e.g.<br />*(DWORD*)orig_func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0x8B55FF8B<br />*(DWORD*)orig_func&nbsp;&amp;&nbsp;0xFFFF0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0x8B550000<br />(*(DWORD*)orig_func&nbsp;&amp;&nbsp;0xFFFF0000)&nbsp;|&nbsp;0xF9EB&nbsp;=&nbsp;0x8B55F9EB<br /><br />This&nbsp;will&nbsp;replace&nbsp;just&nbsp;the&nbsp;first&nbsp;2&nbsp;bytes&nbsp;@&nbsp;func&nbsp;addr.<br />*/<br />InterlockedExchange((LONG*)func_addr,&nbsp;(LONG)((*(DWORD*)func_addr&nbsp;&amp;&nbsp;0xFFFF0000)&nbsp;|&nbsp;0xF9EB));</div></div><br /><br /><strong><h2>## Use cmpxcg8b instruction</h2></strong><br />• <a href="https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp">https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp</a><br /><br />Pad to buffer to 8 bytes and use lock cmpxchg8b<br />to atomically write data data to the address.</div>
</body>
</html>
