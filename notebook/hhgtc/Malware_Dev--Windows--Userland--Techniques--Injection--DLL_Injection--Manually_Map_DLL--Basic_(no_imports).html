<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Basic (no imports)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Manually Map DLL - Basic version with no imports</h1></strong><br />• <a href="https://github.com/rootm0s/Injectors/blob/master/ManualMapDll/inject_darawkMethod.c">https://github.com/rootm0s/Injectors/blob/master/ManualMapDll/inject_darawkMethod.c</a><br /><br />This is the most basic form of DLL manual mapper.<br />It:<br />• loads the DLL into a local buffer<br />• fixes its imports<br />• performs base relocations<br />• allocates memory in the target process<br />• maps the DLL into the target by writing its headers first, followed by its sections<br />• starts execution of the DLL by starting a <code>CreateRemoteThread</code> at the at the address of the injected DLL&#39;s <code>DllMain</code> function<br /><br /><strong><h3>### The problem with this basic version</h3></strong><br />The problem with this technique is that extra libraries that are required by your DLL aren&#39;t loaded into the target process. <br />This is because we don&#39;t execute any extra code in the target process to load them.<br />e.g. you use <code>MessageBoxA</code> in your DLL, this requires <code>USER32.dll</code> to be loaded in the target process. If it&#39;s not, your call to <code>MessageBoxA</code> will fail.<br /><br />If you want to use WinAPI functions in your DLL, that WinAPI functions&#39;s DLL must already be loaded in the target process.<br /><br /><strong><h2>## Demo</h2></strong><br />This is the DLL I&#39;m injecting.<br />We&#39;re not using a reason and a switch case in this DLL because when we pass execution to the <code>DllMain</code> with <code>CreateRemoteThread</code> we don&#39;t pass any parameters.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />void&nbsp;Hello(void)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;MessageBoxA(NULL,&nbsp;&quot;hey!&nbsp;i&#39;m&nbsp;a&nbsp;DLL.&nbsp;i&#39;ve&nbsp;been&nbsp;attached&nbsp;:)&quot;,&nbsp;&quot;smile&quot;,&nbsp;MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;Hello();<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />I&#39;m injecting into <code>notepad.exe</code>, which has a PID of <code>4152</code><br />In my DLL I&#39;m using <code>MessageBoxA</code>. <br /><code>MessageBoxA</code> will run because notepad is a GUI application and USER32.dll (which contains MessageBoxA) will almost definitely be loaded.<br /><a href=""><img src="images/1647-1.png" alt="images/1647-1.png" /></a><br /><br /><a href=""><img src="images/1647-2.png" alt="images/1647-2.png" /></a><br /><br />I run my manual mapper in an Administrator PowerShell prompt and give it the target PID and the DLL to inject.<br /><a href=""><img src="images/1647-3.png" alt="images/1647-3.png" /></a><br /><br />And our manual mapper injects the DLL into the target.<br />• in the PowerShell window you can see the manual mapper&#39;s output.<br />• in the taskbar you&#39;ll see that Notepad has 2 windows - the notepad window and our injected MessageBoxA<br />• in the bottom right you can see the injected DLL&#39;s DOS header at address <code>0x000001D0652D0000</code><br /><a href=""><img src="images/1647-4.png" alt="images/1647-4.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br /><div class="codebox"><div class="codebox">/*<br />Manually&nbsp;map&nbsp;a&nbsp;DLL&nbsp;into&nbsp;a&nbsp;target&nbsp;process.<br /><br />This&nbsp;code:<br />-&nbsp;loads&nbsp;the&nbsp;DLL&nbsp;locally<br />-&nbsp;fixes&nbsp;its&nbsp;Import&nbsp;Address&nbsp;Table<br />-&nbsp;performs&nbsp;base&nbsp;relocations<br />-&nbsp;allocates&nbsp;memory&nbsp;in&nbsp;the&nbsp;target&nbsp;process&nbsp;for&nbsp;the&nbsp;DLL<br />-&nbsp;writes&nbsp;the&nbsp;DLL&#39;s&nbsp;headers<br />-&nbsp;writes&nbsp;the&nbsp;DLL&#39;s&nbsp;sections<br />-&nbsp;creates&nbsp;a&nbsp;remote&nbsp;thread&nbsp;at&nbsp;the&nbsp;the&nbsp;injected&nbsp;DLL&#39;s&nbsp;DllMain&nbsp;function<br /><br />NOTE&nbsp;#1:<br />Imported&nbsp;functions&nbsp;from&nbsp;DLLs&nbsp;not&nbsp;already&nbsp;present&nbsp;in&nbsp;the&nbsp;target&nbsp;process&nbsp;will&nbsp;fail.<br />This&nbsp;is&nbsp;because&nbsp;we&#39;re&nbsp;not&nbsp;running&nbsp;any&nbsp;extra&nbsp;code&nbsp;in&nbsp;the&nbsp;target&nbsp;process&nbsp;to&nbsp;load&nbsp;extra&nbsp;libraries&nbsp;that&nbsp;our&nbsp;injected&nbsp;DLL&nbsp;might&nbsp;need.<br /><br />If&nbsp;you&nbsp;want&nbsp;to&nbsp;use&nbsp;WinAPI&nbsp;functions&nbsp;in&nbsp;your&nbsp;DLL,&nbsp;that&nbsp;WinAPI&nbsp;function&#39;s&nbsp;DLL&nbsp;must&nbsp;already&nbsp;be&nbsp;loaded&nbsp;in&nbsp;the&nbsp;target&nbsp;process:<br />e.g.&nbsp;to&nbsp;use&nbsp;MessageBoxA&nbsp;in&nbsp;your&nbsp;DLL,&nbsp;USER32.dll&nbsp;must&nbsp;be&nbsp;loaded&nbsp;in&nbsp;the&nbsp;target&nbsp;process<br /><br />NOTE&nbsp;#2:<br />We&#39;re&nbsp;not&nbsp;calling&nbsp;our&nbsp;DLL&nbsp;with&nbsp;DLL_PROCESS_ATTACH,&nbsp;so&nbsp;your&nbsp;DLL&nbsp;shouldn&#39;t&nbsp;use&nbsp;a&nbsp;switch&nbsp;case.&nbsp;Just&nbsp;leave&nbsp;it&nbsp;empty:<br />```<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />void&nbsp;Hello(void)<br />{<br />	MessageBoxA(NULL,&nbsp;&quot;hey!&nbsp;i&#39;m&nbsp;a&nbsp;DLL.&nbsp;i&#39;ve&nbsp;been&nbsp;attached&nbsp;:)&quot;,&nbsp;&quot;smile&quot;,&nbsp;MB_OK);<br />	return;<br />}<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br />{<br />	Hello();<br />	return&nbsp;TRUE;<br />}<br />```<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />/*<br />Make&nbsp;sure&nbsp;to&nbsp;call&nbsp;free(file_buffer)&nbsp;after&nbsp;you&#39;re&nbsp;done.<br />*/<br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />BOOL&nbsp;ResolveImports(LPVOID&nbsp;file_buffer)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_OPTIONAL_HEADER&nbsp;pe_optional_header&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;import_directory&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;import_lookup_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;import_address_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_BY_NAME&nbsp;import_name&nbsp;=&nbsp;NULL;<br /><br />	HANDLE&nbsp;h_library&nbsp;=&nbsp;NULL;<br />	FARPROC&nbsp;import_address&nbsp;=&nbsp;NULL;<br /><br />	dos_header&nbsp;=&nbsp;file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />	import_directory&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress));<br />	printf(&quot;\t&nbsp;import&nbsp;directory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;import_directory);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;DLLs<br />	while&nbsp;(import_directory-&gt;Name&nbsp;!=&nbsp;0)<br />	{<br />		//&nbsp;grab&nbsp;DLL&nbsp;name<br />		char*&nbsp;dll_name&nbsp;=&nbsp;(char*)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;import_directory-&gt;Name));<br /><br />		//&nbsp;load&nbsp;DLL<br />		h_library&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />		if&nbsp;(h_library&nbsp;==&nbsp;NULL)<br />			return&nbsp;FALSE;<br /><br />		printf(&quot;\t&nbsp;[+]&nbsp;loaded&nbsp;%s&nbsp;locally&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_name,&nbsp;h_library);<br /><br />		import_lookup_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;import_directory-&gt;OriginalFirstThunk));<br />		import_address_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;import_directory-&gt;FirstThunk));<br /><br />		//&nbsp;loop&nbsp;through&nbsp;imported&nbsp;functions&nbsp;in&nbsp;DLL<br />		while&nbsp;(import_lookup_table-&gt;u1.AddressOfData&nbsp;!=&nbsp;0)<br />		{<br />			//&nbsp;if&nbsp;import&nbsp;by&nbsp;ordinal<br />			if&nbsp;(IMAGE_SNAP_BY_ORDINAL(import_lookup_table-&gt;u1.Ordinal))<br />			{<br />				//&nbsp;grab&nbsp;import&nbsp;ordinal&nbsp;number<br />				ULONGLONG&nbsp;import_ordinal&nbsp;=&nbsp;IMAGE_ORDINAL(import_lookup_table-&gt;u1.Ordinal);<br />				printf(&quot;\t\t&nbsp;[import&nbsp;by&nbsp;ordinal]&nbsp;%37llx&nbsp;&quot;,&nbsp;import_ordinal);<br /><br />				//&nbsp;grab&nbsp;function&nbsp;address&nbsp;from&nbsp;loaded&nbsp;library&nbsp;&amp;&nbsp;write&nbsp;into&nbsp;Import&nbsp;Address&nbsp;Table<br />				import_address&nbsp;=&nbsp;GetProcAddress(h_library,&nbsp;(LPCSTR)import_ordinal);<br />				import_address_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_address;<br /><br />				printf(&quot;\t\t&nbsp;[value&nbsp;in&nbsp;ILT]&nbsp;0x%p&nbsp;\t&nbsp;[modified&nbsp;to&nbsp;in&nbsp;IAT]&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)import_lookup_table-&gt;u1.Function,&nbsp;import_address);<br />			}<br />			//&nbsp;if&nbsp;import&nbsp;by&nbsp;name<br />			else<br />			{<br />				//&nbsp;grab&nbsp;import&nbsp;name&nbsp;from&nbsp;IMAGE_IMPORT_NAME&nbsp;struct<br />				import_name&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;import_lookup_table-&gt;u1.AddressOfData));<br />				printf(&quot;\t\t&nbsp;[import&nbsp;by&nbsp;name]&nbsp;%40s&nbsp;&quot;,&nbsp;import_name-&gt;Name);<br /><br />				//&nbsp;grab&nbsp;function&nbsp;address&nbsp;from&nbsp;loaded&nbsp;library&nbsp;&amp;&nbsp;write&nbsp;into&nbsp;Import&nbsp;Address&nbsp;Table<br />				import_address&nbsp;=&nbsp;GetProcAddress(h_library,&nbsp;import_name-&gt;Name);<br />				import_address_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_address;<br /><br />				printf(&quot;\t\t&nbsp;[value&nbsp;in&nbsp;ILT]&nbsp;0x%p&nbsp;\t&nbsp;[modified&nbsp;to&nbsp;in&nbsp;IAT]&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)import_lookup_table-&gt;u1.Function,&nbsp;import_address);<br />			}<br /><br />			//&nbsp;advance&nbsp;to&nbsp;next&nbsp;function<br />			import_lookup_table++;<br />			import_address_table++;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;DLL<br />		import_directory++;<br />	}<br /><br />	return&nbsp;okay;<br />}<br /><br />/*<br />Loop&nbsp;through&nbsp;relocation&nbsp;table&nbsp;and&nbsp;perform&nbsp;base&nbsp;relocations.<br />Uses&nbsp;raw&nbsp;addresses.<br />*/<br />BOOL&nbsp;PerformBaseRelocations(LPVOID&nbsp;file_buffer,&nbsp;LPVOID&nbsp;target_base)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_OPTIONAL_HEADER&nbsp;pe_optional_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_block&nbsp;=&nbsp;NULL;<br />	PBASE_RELOCATION_ENTRY&nbsp;reloc_entry&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;reloc_table_size&nbsp;=&nbsp;0;<br /><br />	SIZE_T&nbsp;image_base_delta&nbsp;=&nbsp;0;<br /><br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br /><br />	//&nbsp;calcuate&nbsp;difference&nbsp;in&nbsp;base&nbsp;addresses&nbsp;-&nbsp;the&nbsp;delta<br />	image_base_delta&nbsp;=&nbsp;(SIZE_T)target_base&nbsp;-&nbsp;(SIZE_T)pe_header-&gt;OptionalHeader.ImageBase;<br /><br />	printf(&quot;\t&nbsp;original&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)pe_header-&gt;OptionalHeader.ImageBase);<br />	printf(&quot;\t&nbsp;target&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_base);<br />	printf(&quot;\t&nbsp;delta:&nbsp;0x%p&nbsp;\n\n&quot;,&nbsp;(LPVOID)image_base_delta);<br /><br />	if&nbsp;(image_base_delta&nbsp;==&nbsp;0)<br />	{<br />		printf(&quot;[!]&nbsp;image&nbsp;bases&nbsp;are&nbsp;the&nbsp;same.&nbsp;no&nbsp;relocations&nbsp;needed!&nbsp;\n&quot;);<br />		okay&nbsp;=&nbsp;TRUE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;grab&nbsp;relocation&nbsp;table<br />	reloc_table&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD_PTR)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress));<br />	reloc_table_size&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br />	printf(&quot;\t&nbsp;-----&nbsp;RELOCATION&nbsp;DIRECTORY&nbsp;-----&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;reloc_table);<br /><br />	//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;block<br />	//&nbsp;first&nbsp;relocation&nbsp;block&nbsp;is&nbsp;at&nbsp;same&nbsp;address&nbsp;as&nbsp;relocation&nbsp;table<br />	reloc_block&nbsp;=&nbsp;reloc_table;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;relocation&nbsp;table<br />	DWORD&nbsp;block_count&nbsp;=&nbsp;1;<br />	DWORD&nbsp;no_of_entries_in_block&nbsp;=&nbsp;0;<br />	DWORD&nbsp;position_in_reloc_table&nbsp;=&nbsp;0;<br /><br />	while&nbsp;(position_in_reloc_table&nbsp;&lt;&nbsp;reloc_table_size)<br />	{<br />		//&nbsp;read&nbsp;block&nbsp;info<br />		no_of_entries_in_block&nbsp;=&nbsp;(reloc_block-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br /><br />		printf(&quot;\t\t&nbsp;block&nbsp;#%d&nbsp;\n&quot;,&nbsp;block_count);<br />		printf(&quot;\t\t\t&nbsp;size:&nbsp;0x%x&nbsp;\n&quot;,&nbsp;reloc_block-&gt;SizeOfBlock);<br />		printf(&quot;\t\t\t&nbsp;no.&nbsp;of&nbsp;entries:&nbsp;%d&nbsp;\n\n&quot;,&nbsp;no_of_entries_in_block);<br /><br />		//&nbsp;grab&nbsp;first&nbsp;relocation&nbsp;entry&nbsp;in&nbsp;block<br />		reloc_entry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(reloc_block&nbsp;+&nbsp;1);<br /><br />		//&nbsp;loop&nbsp;through&nbsp;entries&nbsp;in&nbsp;block<br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;no_of_entries_in_block;&nbsp;i++)<br />		{<br />			//&nbsp;grab&nbsp;address&nbsp;of&nbsp;relocation.&nbsp;value&nbsp;at&nbsp;that&nbsp;address&nbsp;is&nbsp;the&nbsp;function&nbsp;address&nbsp;to&nbsp;relocate<br />#ifdef&nbsp;_WIN64<br />			PDWORD64&nbsp;reloc_addr&nbsp;=&nbsp;(LPVOID)((DWORD64)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;reloc_block-&gt;VirtualAddress)&nbsp;+&nbsp;reloc_entry-&gt;Offset);<br />#else<br />			PDWORD&nbsp;reloc_addr&nbsp;=&nbsp;(LPVOID)((DWORD)file_buffer&nbsp;+&nbsp;va2raw(file_buffer,&nbsp;reloc_block-&gt;VirtualAddress)&nbsp;+&nbsp;reloc_entry-&gt;Offset);<br />#endif<br /><br />			printf(&quot;\t\t\t&nbsp;reloc&nbsp;#%d&nbsp;\t[TypeOffset]&nbsp;0x%X%X&nbsp;&quot;,&nbsp;i,&nbsp;reloc_entry-&gt;Type,&nbsp;reloc_entry-&gt;Offset);<br />			printf(&quot;\t\t&nbsp;[original&nbsp;value]&nbsp;0x%p&nbsp;&quot;,&nbsp;(LPVOID)*reloc_addr);<br /><br />			/*<br />			Perform&nbsp;relocations&nbsp;by&nbsp;adding&nbsp;the&nbsp;image&nbsp;base&nbsp;delta&nbsp;to&nbsp;the&nbsp;value&nbsp;stored&nbsp;at&nbsp;the&nbsp;relocation&nbsp;address.<br />			LOW&nbsp;relocations&nbsp;point&nbsp;to&nbsp;the&nbsp;lower&nbsp;8&nbsp;bits&nbsp;of&nbsp;WORD&nbsp;values.<br />			HIGH&nbsp;relocations&nbsp;point&nbsp;to&nbsp;the&nbsp;higher&nbsp;8&nbsp;bits&nbsp;of&nbsp;WORD&nbsp;values.<br />			HIGHLOW&nbsp;relocations&nbsp;point&nbsp;to&nbsp;DWORD&nbsp;values.<br />			DIR64&nbsp;relocations&nbsp;point&nbsp;to&nbsp;DWORD64&nbsp;values.<br />			*/<br />			switch&nbsp;(reloc_entry-&gt;Type)<br />			{<br />			case&nbsp;IMAGE_REL_BASED_ABSOLUTE:		//&nbsp;0<br />				printf(&quot;\t\t&nbsp;[type]&nbsp;ABSOLUTE-&nbsp;skipping&nbsp;relocation&nbsp;&quot;);<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_HIGH:			//&nbsp;1<br />				printf(&quot;\t\t&nbsp;[type]&nbsp;HIGH&nbsp;&quot;);<br />				PWORD&nbsp;reloc_addr_HIGH&nbsp;=&nbsp;(PWORD)reloc_addr;				//&nbsp;typecast&nbsp;reloc_addr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;WORD<br />				*reloc_addr_HIGH&nbsp;+=&nbsp;HIWORD(image_base_delta);			//&nbsp;add&nbsp;the&nbsp;higher&nbsp;8&nbsp;bits&nbsp;of&nbsp;the&nbsp;delta&nbsp;at&nbsp;reloc_addr<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_LOW:			//&nbsp;2<br />				printf(&quot;\t\t&nbsp;[type]&nbsp;LOW&nbsp;&quot;);<br />				PWORD&nbsp;reloc_addr_LOW&nbsp;=&nbsp;(PWORD)reloc_addr;				//&nbsp;typecast&nbsp;reloc_addr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;WORD<br />				*reloc_addr_LOW&nbsp;+=&nbsp;LOWORD(image_base_delta);			//&nbsp;add&nbsp;the&nbsp;lower&nbsp;8&nbsp;bits&nbsp;of&nbsp;the&nbsp;delta&nbsp;at&nbsp;reloc_addr<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_HIGHLOW:		//&nbsp;3<br />				printf(&quot;\t\t&nbsp;[type]&nbsp;HIHGLOW&nbsp;&quot;);<br />				PDWORD&nbsp;reloc_addr_HIGHLOW&nbsp;=&nbsp;(PDWORD)reloc_addr;			//&nbsp;typecast&nbsp;reloc_addr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;DWORD<br />				*reloc_addr_HIGHLOW&nbsp;+=&nbsp;image_base_delta;				//&nbsp;add&nbsp;the&nbsp;delta&nbsp;to&nbsp;the&nbsp;value&nbsp;at&nbsp;reloc_addr<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_DIR64:			//&nbsp;10<br />				printf(&quot;\t\t&nbsp;[type]&nbsp;DIR64&nbsp;&quot;);<br />				PDWORD64&nbsp;reloc_addr_DIR64&nbsp;=&nbsp;(PDWORD64)reloc_addr;		//&nbsp;typecast&nbsp;relocAddr&nbsp;as&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;DWORD64<br />				*reloc_addr_DIR64&nbsp;+=&nbsp;image_base_delta;					//&nbsp;add&nbsp;the&nbsp;delta&nbsp;to&nbsp;the&nbsp;value&nbsp;at&nbsp;reloc_addr<br />				break;<br />			default:<br />				printf(&quot;\t\t&nbsp;[type]&nbsp;UNKNOWN-&nbsp;skipping&nbsp;relocation&nbsp;&quot;);<br />				break;<br />			}<br /><br />			//&nbsp;read&nbsp;data&nbsp;at&nbsp;reloc_addr&nbsp;to&nbsp;check&nbsp;it&#39;s&nbsp;been&nbsp;modified<br />			printf(&quot;\t\t&nbsp;[modified&nbsp;value]&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)*reloc_addr);<br /><br />			//&nbsp;advance&nbsp;to&nbsp;next&nbsp;entry<br />			reloc_entry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;block<br />		block_count&nbsp;+=&nbsp;1;<br />		position_in_reloc_table&nbsp;+=&nbsp;reloc_block-&gt;SizeOfBlock;<br />		reloc_block&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((DWORD64)reloc_block&nbsp;+&nbsp;reloc_block-&gt;SizeOfBlock);<br />	}<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br /><br />	char*&nbsp;dll_path&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;dll_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;dll_buffer_size&nbsp;=&nbsp;0;<br />	LPVOID&nbsp;dllmain_addr&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	int&nbsp;target_pid&nbsp;=&nbsp;0;<br />	HANDLE&nbsp;h_target&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_target_thread&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;target_dll_base&nbsp;=&nbsp;NULL;<br /><br />	LPVOID&nbsp;target_loader_base&nbsp;=&nbsp;NULL;<br /><br />	printf(&quot;#&nbsp;manual&nbsp;dll&nbsp;injector&nbsp;(no&nbsp;imports)&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;Manually&nbsp;maps&nbsp;a&nbsp;DLL&nbsp;into&nbsp;a&nbsp;target&nbsp;process&nbsp;and&nbsp;creates&nbsp;a&nbsp;remote&nbsp;thread&nbsp;at&nbsp;DllMain&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;the&nbsp;DLL&nbsp;mapping&nbsp;is&nbsp;done&nbsp;from&nbsp;this&nbsp;process,&nbsp;so&nbsp;loading&nbsp;your&nbsp;injected&nbsp;DLL&#39;s&nbsp;required&nbsp;modules&nbsp;isn&#39;t&nbsp;possible&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;(so&nbsp;you&nbsp;can&nbsp;only&nbsp;use&nbsp;functions&nbsp;from&nbsp;DLLs&nbsp;already&nbsp;loaded&nbsp;in&nbsp;the&nbsp;target&nbsp;process:&nbsp;USER32,&nbsp;ADVAPI,&nbsp;KERNEL32,&nbsp;etc.)&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;advise&nbsp;running&nbsp;as&nbsp;Adminstrator&nbsp;\n&quot;);<br />	printf(&quot;\n&quot;);<br /><br />	if&nbsp;(argc&nbsp;!=&nbsp;3)<br />	{<br />		printf(&quot;[-]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;dll_injector.exe&nbsp;[target&nbsp;pid]&nbsp;[dll&nbsp;path]&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	target_pid&nbsp;=&nbsp;atoi(argv[1]);<br />	dll_path&nbsp;=&nbsp;argv[2];<br /><br />	printf(&quot;[*]&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;target_pid);<br />	printf(&quot;[*]&nbsp;dll&nbsp;to&nbsp;inject:&nbsp;%s&nbsp;\n\n&quot;,&nbsp;dll_path);<br /><br />	//&nbsp;load&nbsp;DLL&nbsp;into&nbsp;local&nbsp;memory<br />	dll_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(dll_path,&nbsp;&amp;dll_buffer_size);<br />	if&nbsp;(dll_buffer&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;DLL&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;DLL&nbsp;read&nbsp;into&nbsp;buffer.&nbsp;size&nbsp;=&nbsp;%d&nbsp;\n&quot;,&nbsp;dll_buffer_size);<br /><br />	//&nbsp;get&nbsp;DLL&nbsp;headers<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dll_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br /><br />	//&nbsp;check&nbsp;if&nbsp;valid&nbsp;DLL&nbsp;file<br />	if&nbsp;(dos_header-&gt;e_magic&nbsp;!=&nbsp;IMAGE_DOS_SIGNATURE)<br />	{<br />		printf(&quot;[!]&nbsp;DLL&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;DOS&nbsp;file&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	if&nbsp;(pe_header-&gt;Signature&nbsp;!=&nbsp;IMAGE_NT_SIGNATURE)<br />	{<br />		printf(&quot;[!]&nbsp;DLL&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;PE&nbsp;file&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	//&nbsp;open&nbsp;handle&nbsp;to&nbsp;target&nbsp;process<br />	h_target&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;target_pid);<br />	if&nbsp;(h_target&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;handle&nbsp;to&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;opened&nbsp;handle&nbsp;to&nbsp;target&nbsp;process&nbsp;\n&quot;);<br /><br />	//&nbsp;allocate&nbsp;space&nbsp;for&nbsp;DLL&nbsp;in&nbsp;target<br />	target_dll_base&nbsp;=&nbsp;VirtualAllocEx(h_target,&nbsp;NULL,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(target_dll_base&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;allocated&nbsp;%d&nbsp;bytes&nbsp;of&nbsp;memory&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_buffer_size,&nbsp;target_dll_base);<br /><br />	//&nbsp;fix&nbsp;import&nbsp;address&nbsp;table<br />	/*<br />	If&nbsp;this&nbsp;code&nbsp;was&nbsp;running&nbsp;in&nbsp;the&nbsp;target&nbsp;process,&nbsp;here&#39;s&nbsp;where&nbsp;you&#39;d&nbsp;import&nbsp;all&nbsp;the&nbsp;required&nbsp;DLLs&nbsp;your&nbsp;injected&nbsp;DLL&nbsp;needs.<br />	However,&nbsp;since&nbsp;the&nbsp;code&nbsp;is&nbsp;running&nbsp;here&nbsp;we&nbsp;can&#39;t&nbsp;do&nbsp;that.<br />	*/<br />	printf(&quot;\n[*]&nbsp;fixing&nbsp;import&nbsp;address&nbsp;table&nbsp;\n&quot;);<br />	b_ret&nbsp;=&nbsp;ResolveImports(dll_buffer);<br /><br />	//&nbsp;perform&nbsp;base&nbsp;relocations<br />	printf(&quot;\n[*]&nbsp;performing&nbsp;base&nbsp;relocations&nbsp;\n&quot;);<br />	b_ret&nbsp;=&nbsp;PerformBaseRelocations(dll_buffer,&nbsp;target_dll_base);<br /><br />	//&nbsp;write&nbsp;DLL&nbsp;headers&nbsp;into&nbsp;target<br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_target,&nbsp;target_dll_base,&nbsp;dll_buffer,&nbsp;pe_header-&gt;OptionalHeader.SizeOfHeaders,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;DLL&nbsp;path&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		VirtualFreeEx(h_target,&nbsp;target_dll_base,&nbsp;dll_buffer_size,&nbsp;MEM_RELEASE);<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;written&nbsp;DLL&nbsp;headers&nbsp;into&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_dll_base);<br /><br />	//&nbsp;write&nbsp;DLL&nbsp;sections&nbsp;into&nbsp;target<br />	printf(&quot;[*]&nbsp;writing&nbsp;sections&nbsp;into&nbsp;target&nbsp;\n&quot;);<br /><br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	LPVOID&nbsp;section_address&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;write_address&nbsp;=&nbsp;NULL;<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		section_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_buffer&nbsp;+&nbsp;section_header-&gt;PointerToRawData);<br />		write_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)target_dll_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br /><br />		b_ret&nbsp;=&nbsp;WriteProcessMemory(h_target,&nbsp;write_address,&nbsp;section_address,&nbsp;section_header-&gt;SizeOfRawData,&nbsp;0);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;%s&nbsp;to&nbsp;0x%p:&nbsp;%d&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_address,&nbsp;GetLastError());<br />			goto&nbsp;cleanup;<br />		}<br />		else<br />			printf(&quot;\t&nbsp;wrote&nbsp;%s&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_address);<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	dllmain_addr&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)target_dll_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint);<br /><br />	//&nbsp;create&nbsp;a&nbsp;thread&nbsp;in&nbsp;the&nbsp;target&nbsp;process&nbsp;at&nbsp;our&nbsp;injected&nbsp;DLL&#39;s&nbsp;DllMain<br />	printf(&quot;[*]&nbsp;executing&nbsp;injected&nbsp;DLL&#39;s&nbsp;DllMain&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dllmain_addr);<br />	h_target_thread&nbsp;=&nbsp;CreateRemoteThread(h_target,&nbsp;NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)dllmain_addr,&nbsp;NULL,&nbsp;0,&nbsp;NULL);<br /><br />	printf(&quot;[+]&nbsp;done!&nbsp;\n&quot;);<br /><br />cleanup:<br />	if&nbsp;(h_target)&nbsp;CloseHandle(h_target);<br />	if&nbsp;(h_target_thread)&nbsp;CloseHandle(h_target_thread);<br />	if&nbsp;(dll_buffer)&nbsp;free(dll_buffer);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /></div>
</body>
</html>
