<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Manual Map</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1># Manually Map your Driver</h1><br />You could manually map your driver into the kernel.<br /><br /><h2>## Limitations</h2><br /><strong>Links</strong><br />• <a href="https://www.unknowncheats.me/forum/2852342-post13.html">https://www.unknowncheats.me/forum/2852342-post13.html</a> - Helpful post about limitations<br /><br />There are limitations when manually mapping drivers.<br />For references on how to create a driver suitable to be manually mapped, refer to:<br />• DummyDrv and 2 here - <a href="https://github.com/hfiref0x/TDL/tree/master/Source">https://github.com/hfiref0x/TDL/tree/master/Source</a><br />• Manual Map &gt; Manually Mapped Driver Examples<br /><br />In short, you can<br />• Once manually mapped, create a DeviceObject yourself so that you can use IOCTL communication<br />   ◇ (defeats the point of manually mapping really. Now you driver is visible)<br />• Continue without a DeviceObject and use alternative methods for userland &lt;-&gt; kerneland communication<br />   ◇ Refer to the Userland &lt;-&gt; Kerneland Communication node for that<br /><br /><strong>Limitations</strong><br />• No SEH<br />• No <code>DriverObject</code> is created<br /><br /><strong><h3>### No Unloading</h3></strong><br />You can&#39;t unload a manually mapped driver as you would a normally loaded driver<br />because there&#39;s no <code>DriverObject</code>.<br /><br /><h4>#### Budget Solutions</h4><br /><strong>Unload Yourself</strong><br />You can try to &quot;unload&quot; it yourself <br />(free kernel memory, remove references to it, etc.) <br />but that is HIGHLY pront to error and you could just BSOD.<br /><a href="https://www.unknowncheats.me/forum/2852102-post11.html">https://www.unknowncheats.me/forum/2852102-post11.html</a><br /><br /><strong>ROP, memset(0), PsTerminateSystemThread</strong><br />Alternatively, use ROP to empty all the memory where you driver sits<br />and then call PsTerminateSystemThread.<br /><a href="https://www.unknowncheats.me/forum/2852102-post11.html">https://www.unknowncheats.me/forum/2852102-post11.html</a><br /><br /><strong>Restart</strong><br />You can just restart your system to unload the driver.<br /><br /><h2>## Turla Driver Loader</h2><br />• <a href="https://github.com/hfiref0x/TDL">https://github.com/hfiref0x/TDL</a><br /><br />The &quot;original&quot; driver manual mapper source.<br />Uses Turla group&#39;s VirtualBox.sys driver exploit to write code to kernel memory and execute it.<br />&quot;Custom bootstrap shellcode&quot; maps your kernel driver into executable kernel memory and calls DriverEntry.<br /><br />Source contains demos of drivers which work round the limitations.<br /><br /><h2>## KDMapper</h2><br />• <a href="https://github.com/z175">https://github.com/z175</a> - Original author of KDMapper. No source anymore.<br />• <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/320049-kdmapper-manual-map-driver-using-vulnerable-driver-intel.html">https://www.unknowncheats.me/forum/anti-cheat-bypass/320049-kdmapper-manual-map-driver-using-vulnerable-driver-intel.html</a> - Original author&#39;s thread<br />• <a href="https://github.com/TheCruZ/kdmapper">https://github.com/TheCruZ/kdmapper</a> - Updated version which does extra things for you<br />   ◇ Removes driver from PiDDB cache, MmUnloadedDrivers list, KernelHashBucket, erases PE headers<br />• <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/442344-difference-dsefix-kdmapper.html">https://www.unknowncheats.me/forum/anti-cheat-bypass/442344-difference-dsefix-kdmapper.html</a> - Info<br /><br />KDMapper exploits Intel&#39;s <code>iqvw64e.sys</code> driver to manually map non-signed drivers into memory.<br />More designed for cheat dev because it removes traces of the exploited Intel driver<br />once it&#39;s finished loading your chosen driver (in order to evade anticheat like BE and EAC).<br /><br /><h2>## drvmap</h2><br />• <a href="https://github.com/not-wlan/drvmap">https://github.com/not-wlan/drvmap</a> - Source<br />• <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/252685-drvmap-driver-manual-mapper-using-capcom.html">https://www.unknowncheats.me/forum/anti-cheat-bypass/252685-drvmap-driver-manual-mapper-using-capcom.html</a> - Explanation<br /><br />Same principle as KDMapper.<br />Uses capcom driver to execute kernel code from userland and manually map a driver into kernel space.</div>
</body>
</html>
