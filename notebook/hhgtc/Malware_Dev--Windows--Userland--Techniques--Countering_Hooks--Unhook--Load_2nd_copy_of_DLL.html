<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Load 2nd copy of DLL</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Load Unhooked Versions by Loading A 2nd Copy of the Original DLL &amp; GetProcAddress&#39;ing</h1></strong><br />This is a pretty hilarious method of bypassing hooks, but it works.<br />You can load a 2nd copy of a DLL providing it has a different name.<br /><br />NOTE: This doesn&#39;t work for all DLLs.<br />Ntdll.dll and Kernel32.dll both work, User32.dll doesn&#39;t. I think this is because of dependencies (my best guess)<br /><br />You:<br />• create a copy of the DLL on disk<br />• load that copy with <code>LoadLibrary</code>,<br />• and then <code>GetProcAddress</code> the function you want and link it to a typedef. <br /><br />You&#39;re effectively dynamically loading the functions you want, but by using a 2nd copy of the original DLL you will evade hooks by EDR/anti-cheat/anti-virus/whatever because they&#39;ll only be looking to hook Kernel32.dll, not Kernel32_copy.dll<br /><br />Because you&#39;re copying a file, you obviously need write permissions on the system.<br /><br />Examples:<br />• <a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/">https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/</a> - Search for &quot;The third technique&quot;<br /><br /><strong><h2>## Code</h2></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />typedef&nbsp;DWORD(WINAPI*&nbsp;t_GetCurrentProcessId)();<br />t_GetCurrentProcessId&nbsp;d_GetCurrentProcessId&nbsp;=&nbsp;NULL;<br /><br />/*<br />Creates&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;specified&nbsp;DLL,&nbsp;loads&nbsp;it&nbsp;into&nbsp;the&nbsp;process,&nbsp;and&nbsp;grabs&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;desired&nbsp;function.<br />NOTE:&nbsp;This&nbsp;doesn&#39;t&nbsp;work&nbsp;for&nbsp;all&nbsp;DLLs<br />e.g.&nbsp;Ntdll.dll&nbsp;and&nbsp;Kernel32.dll&nbsp;both&nbsp;work,&nbsp;User32.dll&nbsp;doesn&#39;t.&nbsp;I&nbsp;think&nbsp;this&nbsp;is&nbsp;because&nbsp;of&nbsp;dependencies&nbsp;(my&nbsp;best&nbsp;guess)<br /><br />Parameters:<br />	char*&nbsp;dll_name&nbsp;-&nbsp;the&nbsp;DLL&nbsp;in&nbsp;which&nbsp;the&nbsp;function&nbsp;is&nbsp;contained&nbsp;(&quot;Kernel32.dll&quot;)<br />	char*&nbsp;function_name&nbsp;-&nbsp;the&nbsp;desired&nbsp;function&nbsp;to&nbsp;grab&nbsp;(&quot;GetCurrentProcessID&quot;)<br />	void**&nbsp;dynamic_function&nbsp;-&nbsp;a&nbsp;typedef&nbsp;of&nbsp;the&nbsp;desired&nbsp;function&nbsp;((void*)&amp;d_GetCurrentProcessId)<br />*/<br />BOOL&nbsp;Load2ndDLLFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void**&nbsp;dynamic_function)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	char&nbsp;temp_path[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	char&nbsp;dll_path_orig[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	char&nbsp;dll_path_copy[MAX_PATH]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;Grab&nbsp;current&nbsp;user&#39;s&nbsp;temp&nbsp;folder&nbsp;(usually&nbsp;C:\Users\bob\AppData\Local\Temp)<br />	ExpandEnvironmentStringsA(&quot;%TEMP%&quot;,&nbsp;temp_path,&nbsp;MAX_PATH);<br /><br />	//&nbsp;Create&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;DLL<br />	sprintf_s(dll_path_orig,&nbsp;MAX_PATH,&nbsp;&quot;C:\\Windows\\System32\\%s&quot;,&nbsp;dll_name);<br />	sprintf_s(dll_path_copy,&nbsp;MAX_PATH,&nbsp;&quot;%s\\cpy_%s&quot;,&nbsp;temp_path,&nbsp;dll_name);<br />	CopyFileA(dll_path_orig,&nbsp;dll_path_copy,&nbsp;FALSE);<br /><br />	//&nbsp;Load&nbsp;it<br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_path_copy);<br />	if&nbsp;(hmod_dll&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;load&nbsp;library:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;FALSE;<br />	}<br /><br />	//&nbsp;Grab&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;desired&nbsp;function&nbsp;in&nbsp;the&nbsp;new&nbsp;library<br />	*dynamic_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(dynamic_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;-&nbsp;failed&nbsp;to&nbsp;GetProcAddress:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;FALSE;<br />	}<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span>	<br />	Load2ndDLLFunction(&quot;Kernel32.dll&quot;,&nbsp;&quot;GetCurrentProcessId&quot;,&nbsp;(void*)&amp;d_GetCurrentProcessId);<br /><br />	DWORD&nbsp;process_id&nbsp;=&nbsp;0;<br />	process_id&nbsp;=&nbsp;d_GetCurrentProcessId();<br />	printf(&quot;process&nbsp;id:&nbsp;%d&nbsp;\n&quot;,&nbsp;process_id);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Demo</h2></strong><br />Here we can see our program has printed the correct Process ID - <code>9280</code> - using our dynamically loaded <code>d_GetCurrentProcessId()</code> function.<br /><br />In Process Hacker we can see the loaded modules, and our 2nd copy of Kernel32.dll - <code>cpy_Kernel32.dll</code><br /><a href=""><img src="images/1707-1.png" alt="images/1707-1.png" /></a></div>
</body>
</html>
