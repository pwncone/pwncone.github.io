<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Process creation & termination</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Linux - Processes - Process creation &amp; termination</h1></strong><br /><br /><strong><h2>## Process Creation</h2></strong><br />• When the system boots up, the kernels creates a process called <strong>init</strong><br />   ◇ init has a PID of 1<br />• init is the mother of all processes<br />   ◇ Every new process is a fork of fork of fork of etc. of init<br />• When a new process is created, an existing process clones itself using the <code>fork()</code> system call <br />   ◇ fork() creates a mostly identical child process<br />   ◇ This child process takes on a new process ID (PID) <br />   ◇ And the original process becomes its parent process, wiht a parent process ID (PPID)<br />• The child process can:<br />   ◇ continue to use the same program its parent was using <br />   ◇ Or (more often) use the <code>execve()</code> syscall to launch up a new program<br />   ◇ <code>execve()</code> destroys the memory management that the kernel put into place for that process and sets up new ones for the new program<br /><br /><em><strong>Example: </strong></em><em><br /></em><em>You run </em><em><code>ls</code></em><em> in the terminal</em><br /><br />1. The shell calls <code>fork()</code> to create a copy of the shell<br />2. The new copy of the shell calls <code>exec(ls)</code> to run <code>ls</code><br /><br /><a href=""><img src="images/915-1.png" alt="images/915-1.png" /></a><br /><br /><strong><h1>Process Termination</h1></strong><br />• The terminating process tells the kernel why it&#39;s terminating using a termination status<br />   ◇ A termination status of 0 means that process is exiting with no errors/it succeeded<br />• The parent process then uses the wait() syscall<br />   ◇ This checks the termination status of the child process<br />   ◇ It wants to know how/why the child process is terminating<br /><br /><strong><h3>Orphan Processes</h3></strong><h3> </h3><br />• If a parent process dies before its child processes, the child processes become orphan processes<br />• The kernel recognises that it won&#39;t receive a wait() call from the parent process, so it puts the child processes under the care of init<br />• init will then perform the wait() syscall for the orphan child processes so that they can die<br /><br /><strong><h3>Zombie Processes</h3></strong><br />• If a child terminates without the parent process calling wait(), the kernel turns the child process into a zombie process<br />   ◇ This is because the kernel wants to know how the child process terminated<br />• The child process&#39;s resources get freed, however there&#39;ll still be an entry in the process table for the zombie process<br />• Zombie processes can&#39;t be killed, since they&#39;re technically “dead”<br />• If the parent process calls wait() (for whatever reason), the zombie process will disappear - knowing as “reaping”<br />   ◇ If the parent process doesn&#39;t call wait(), init will call wait() and remove the zombie process</div>
</body>
</html>
