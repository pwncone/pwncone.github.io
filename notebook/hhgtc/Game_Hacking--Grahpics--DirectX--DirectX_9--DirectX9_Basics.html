<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>DirectX9 Basics</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># DirectX9 Basics</h1></strong><br /><a href="http://www.directxtutorial.com/LessonList.aspx?listid=9">http://www.directxtutorial.com/LessonList.aspx?listid=9</a><br /><br /><strong><h2>## The Game Loop</h2></strong><br /><a href=""><img src="images/1257-1.png" alt="images/1257-1.png" /></a><br /><br /><strong>Boot </strong><br />1. Start game (create window, allocate memory<br />2. Load in and set variables (map, player cooridinates, etc.)<br /><br /><strong>Game loop</strong><br />3. Get player input (run, jump, look left, etc.)<br />4. Computer game logic (how high they jumped, did they run into a wall, etc.)<br />5. Render the graphics (wall in front, tree on left, enemy on right, etc.)<br /><br />DONE! Frame gets drawn to screen and loop repeats (get player input &gt; compute logic &gt; render graphics)<br /><br /><strong><h2>## About Windows GUI Applications</h2></strong><br />Windows GUI applications are event driven.<br />Events are user input - mouse clicks, keyboard presses, clicking on X to close or - to minimise, etc.<br />Events are put into a message queue.<br />WndProc - the Window Procedure - (which is a function you write) handles these events.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />LRESULT&nbsp;CALLBACK&nbsp;WindowProcedure(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;msg,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)<br />{<br />	switch&nbsp;(msg)<br />	{<br />	case&nbsp;WM_CLOSE:<br />		DestroyWindow(hWnd);		//&nbsp;Destroys&nbsp;window&nbsp;and&nbsp;LL&nbsp;child&nbsp;windows&nbsp;and&nbsp;removes&nbsp;window&nbsp;from&nbsp;system<br />		break;<br />	case&nbsp;WM_DESTROY:<br />		PostQuitMessage(0);		//&nbsp;Sends&nbsp;WM_QUIT&nbsp;to&nbsp;message&nbsp;loop&nbsp;to&nbsp;quit<br />		break;<br />	default:<br />		return&nbsp;DefWindowProcA(hWnd,&nbsp;msg,&nbsp;wParam,&nbsp;lParam);<br />	}<br />	<br />	return&nbsp;0;<br />}<br /><br />int&nbsp;WINAPI&nbsp;WinMain(HINSTANCE&nbsp;hInstance,&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;PSTR&nbsp;pCmdLine,&nbsp;int&nbsp;nCmdShow)<br /><span style="color:#000000;font-weight:400">{</span><br />	WNDCLASSEXA&nbsp;wc&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	HWND&nbsp;hwnd&nbsp;=&nbsp;NULL;<br />	MSG&nbsp;msg&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	//&nbsp;Step&nbsp;1.&nbsp;Register&nbsp;a&nbsp;Window&nbsp;class<br />	wc.cbSize&nbsp;=&nbsp;sizeof(WNDCLASSEXA);<br />	wc.style&nbsp;=&nbsp;CS_HREDRAW&nbsp;|&nbsp;CS_VREDRAW;<br />	wc.lpfnWndProc&nbsp;=&nbsp;WindowProcedure;<br />	wc.hInstance&nbsp;=&nbsp;hInstance;<br />	wc.hCursor&nbsp;=&nbsp;LoadCursorA(NULL,&nbsp;IDC_ARROW);<br />	wc.hbrBackground&nbsp;=&nbsp;(HBRUSH)COLOR_WINDOW;<br />	wc.lpszClassName&nbsp;=&nbsp;&quot;FirstWindow&quot;;<br /><br />	if&nbsp;(!RegisterClassExA(&amp;wc))<br />	{<br />		MessageBoxA(NULL,&nbsp;&quot;Failed&nbsp;to&nbsp;register&nbsp;window&nbsp;:/&quot;,&nbsp;&quot;Error&quot;,&nbsp;MB_ICONEXCLAMATION&nbsp;|&nbsp;MB_OK);<br />		return&nbsp;-1;<br />	}<br /><br />	//&nbsp;Step&nbsp;2.&nbsp;Create&nbsp;a&nbsp;Window<br />	hwnd&nbsp;=&nbsp;CreateWindowExA(WS_EX_CLIENTEDGE,&nbsp;&quot;FirstWindow&quot;,&nbsp;&quot;My&nbsp;window&nbsp;title&quot;,&nbsp;WS_OVERLAPPEDWINDOW,&nbsp;CW_USEDEFAULT,&nbsp;CW_USEDEFAULT,&nbsp;240,&nbsp;120,&nbsp;NULL,&nbsp;NULL,&nbsp;hInstance,&nbsp;NULL);<br />	if&nbsp;(hwnd&nbsp;==&nbsp;NULL)<br />	{<br />		MessageBoxA(NULL,&nbsp;&quot;Failed&nbsp;to&nbsp;create&nbsp;window&nbsp;:/&quot;,&nbsp;&quot;Error&quot;,&nbsp;MB_ICONEXCLAMATION&nbsp;|&nbsp;MB_OK);<br />		return&nbsp;-1;<br />	}<br /><br />	//&nbsp;Show&nbsp;Window&nbsp;and&nbsp;update&nbsp;it&nbsp;to&nbsp;ensure&nbsp;it&#39;s&nbsp;drawn&nbsp;correctly<br />	ShowWindow(hwnd,&nbsp;nCmdShow);<br />	UpdateWindow(hwnd);<br /><br />	//&nbsp;Step&nbsp;3.&nbsp;Message&nbsp;Loop<br />	while&nbsp;(GetMessageA(&amp;msg,&nbsp;NULL,&nbsp;0,&nbsp;0,&nbsp;PM_REMOVE))<br />	{<br />		TranslateMessage(&amp;msg);<br />		DispatchMessageA(&amp;msg);<br />	}<br /><br />	return&nbsp;msg.wParam;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## PeekMessage()</h2></strong><br />GetMessage() waits for a message.<br />When it receives one, it processes it.<br />This is fine for GUI applications because they don&#39;t do anything autonomous in the background,<br />they wait for a user to do something and then respond.<br /><br />GetMessage() doesn&#39;t work for games.<br />Games do stuff in the background and need to render 30-60 images per second and render them on the screen.<br />Instead, games use PeekMessage().<br />PeekMessage() doesn&#39;t wait for anything. It looks in the queue and checks if there&#39;s anything there.<br /><a href=""><img src="images/1257-2.png" alt="images/1257-2.png" /></a><br /><br />With games, your message loop will look this,<br />using PeekMessage in the <code>while</code> loop instead of GetMessage<br /><div class="codebox"><div class="codebox">//&nbsp;Enter&nbsp;the&nbsp;infinite&nbsp;message&nbsp;loop<br />while(TRUE)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;to&nbsp;see&nbsp;if&nbsp;any&nbsp;messages&nbsp;are&nbsp;waiting&nbsp;in&nbsp;the&nbsp;queue<br />&nbsp;&nbsp;&nbsp;&nbsp;while(PeekMessage(&amp;msg,&nbsp;NULL,&nbsp;0,&nbsp;0,&nbsp;PM_REMOVE))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Translate&nbsp;the&nbsp;message&nbsp;and&nbsp;dispatch&nbsp;it&nbsp;to&nbsp;WindowProc()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TranslateMessage(&amp;msg);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DispatchMessage(&amp;msg);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;message&nbsp;is&nbsp;WM_QUIT,&nbsp;exit&nbsp;the&nbsp;while&nbsp;loop<br />&nbsp;&nbsp;&nbsp;&nbsp;if(msg.message&nbsp;==&nbsp;WM_QUIT)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Run&nbsp;game&nbsp;code&nbsp;here<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...<br /><span style="color:#000000;font-weight:400">}</span></div></div> <br /><br /><strong><h2>## Create a Window</h2></strong><br />Here&#39;s a basic window created with the Windows GUI.<br />Replace <code>PeekMessage</code> with <code>GetMessage</code> to have window stay open,<br />but for DirectX and rendering games we need to use <code>PeekMessage</code>.<br /><br /><br /><strong><h2>## DirectX and COM</h2></strong><br />DirectX is actually a series of COM objects<br />One of these is Direct3D.<br />Direct3D is a class using that runs 2d and 3d graphics using hardware/software/whatever.<br />This is why you see <code>d3d-&gt;CreateDevice</code> and <code>d3d-&gt;Release</code> (because they&#39;re COM objects / C++ classes)<br /><br /><strong><h2>## Create a Blue Window</h2></strong><br /><strong>Direct3d Interface</strong><br /><code>LPDIRECT3D9 d3d;</code><br />This is a pointer to Direct3d.<br /><br /><strong>Direct3d Device</strong><br /><code>LPDIRECT3DDEVICE9 d3d_device;</code><br />The Direct3d device stores info about graphics drivers, video card, graphics hardware, etc.<br />This is a pointer to the Direct3d device (class) that stores all this info<br /><br />Compile options:<br />• Linker &gt; System &gt; Subsystem &gt; <code>Windows</code><br />• <br /><br /><div class="codebox"><div class="codebox">/*<br />Creates&nbsp;a&nbsp;window&nbsp;and&nbsp;directx&nbsp;renders&nbsp;it&nbsp;blue.<br />Written&nbsp;in&nbsp;c&nbsp;(not&nbsp;c++)&nbsp;so&nbsp;using&nbsp;IDirect3d9_CreateDevice&nbsp;(not&nbsp;d3d-&gt;CreateDevice)<br />*/<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;windowsx.h&gt;		//&nbsp;Need&nbsp;this&nbsp;for&nbsp;PeekMessage&nbsp;to&nbsp;handle&nbsp;windows&nbsp;controls&nbsp;(X&nbsp;button,&nbsp;etc.)<br />#include&nbsp;&lt;d3d9.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;d3d9.lib&quot;)<br /><br />LPDIRECT3D9&nbsp;d3d&nbsp;=&nbsp;NULL;					//&nbsp;Pointer&nbsp;to&nbsp;our&nbsp;Direct3d&nbsp;interface<br />LPDIRECT3DDEVICE9&nbsp;d3d_device&nbsp;=&nbsp;NULL;	//&nbsp;Pointer&nbsp;to&nbsp;the&nbsp;device&nbsp;class<br /><br />void&nbsp;InitDirect3d(HWND&nbsp;hWnd)<br />{<br />	//&nbsp;Create&nbsp;Direct3d&nbsp;interface&nbsp;and&nbsp;struct&nbsp;to&nbsp;hold&nbsp;device&nbsp;params<br />	d3d&nbsp;=&nbsp;Direct3DCreate9(D3D_SDK_VERSION);<br />	D3DPRESENT_PARAMETERS&nbsp;d3dpp&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	d3dpp.Windowed&nbsp;=&nbsp;TRUE;<br />	d3dpp.SwapEffect&nbsp;=&nbsp;D3DSWAPEFFECT_DISCARD;	//&nbsp;Discard&nbsp;old&nbsp;frames<br />	d3dpp.hDeviceWindow&nbsp;=&nbsp;hWnd;					//&nbsp;Set&nbsp;window&nbsp;to&nbsp;be&nbsp;used&nbsp;by&nbsp;Direct3d&nbsp;(the&nbsp;window&nbsp;we&#39;ve&nbsp;created&nbsp;in&nbsp;WinMain)<br /><br />	//&nbsp;Create&nbsp;Direct3d&nbsp;device<br />	IDirect3D9_CreateDevice(d3d,&nbsp;D3DADAPTER_DEFAULT,&nbsp;D3DDEVTYPE_HAL,&nbsp;hWnd,&nbsp;D3DCREATE_SOFTWARE_VERTEXPROCESSING,&nbsp;&amp;d3dpp,&nbsp;&amp;d3d_device);<br /><br />	return;<br />}<br /><br />void&nbsp;CleanupDirect3d()<br />{<br />	IDirect3DDevice9_Release(d3d_device);<br />	IDirect3D9_Release(d3d);<br />}<br /><br />void&nbsp;RenderFrame()<br />{<br />	//&nbsp;Clear&nbsp;the&nbsp;window&nbsp;to&nbsp;a&nbsp;deep&nbsp;blue<br />	IDirect3DDevice9_Clear(d3d_device,&nbsp;0,&nbsp;NULL,&nbsp;D3DCLEAR_TARGET,&nbsp;D3DCOLOR_XRGB(0,&nbsp;40,&nbsp;100),&nbsp;1.0f,&nbsp;0);<br /><br />	//&nbsp;Start&nbsp;the&nbsp;3d&nbsp;scene<br />	IDirect3DDevice9_BeginScene(d3d_device);<br />	//&nbsp;Do&nbsp;3d&nbsp;rendering&nbsp;on&nbsp;the&nbsp;back&nbsp;buffer<br />	IDirect3DDevice9_EndScene(d3d_device);<br />	<br />	//&nbsp;Display&nbsp;rendered&nbsp;frame&nbsp;on&nbsp;screen<br />	IDirect3DDevice9_Present(d3d_device,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL);<br />	<br />	return;<br />}<br /><br />LRESULT&nbsp;CALLBACK&nbsp;WindowProcedure(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;msg,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)<br />{<br />	switch&nbsp;(msg)<br />	{<br />	case&nbsp;WM_CLOSE:<br />		DestroyWindow(hWnd);	//&nbsp;Destroys&nbsp;window&nbsp;and&nbsp;LL&nbsp;child&nbsp;windows&nbsp;and&nbsp;removes&nbsp;window&nbsp;from&nbsp;system<br />		break;<br />	case&nbsp;WM_DESTROY:<br />		PostQuitMessage(0);		//&nbsp;Sends&nbsp;WM_QUIT&nbsp;to&nbsp;message&nbsp;loop&nbsp;to&nbsp;quit<br />		break;<br />	default:<br />		return&nbsp;DefWindowProcA(hWnd,&nbsp;msg,&nbsp;wParam,&nbsp;lParam);<br />	}<br />	<br />	return&nbsp;0;<br />}<br /><br />int&nbsp;WINAPI&nbsp;WinMain(HINSTANCE&nbsp;hInstance,&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;PSTR&nbsp;pCmdLine,&nbsp;int&nbsp;nCmdShow)<br /><span style="color:#000000;font-weight:400">{</span><br />	WNDCLASSEXA&nbsp;wc&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	HWND&nbsp;hWnd&nbsp;=&nbsp;NULL;<br />	MSG&nbsp;msg&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	//&nbsp;Register&nbsp;a&nbsp;Window&nbsp;class<br />	wc.cbSize&nbsp;=&nbsp;sizeof(WNDCLASSEXA);<br />	wc.style&nbsp;=&nbsp;CS_HREDRAW&nbsp;|&nbsp;CS_VREDRAW;<br />	wc.lpfnWndProc&nbsp;=&nbsp;WindowProcedure;<br />	wc.hInstance&nbsp;=&nbsp;hInstance;<br />	wc.hCursor&nbsp;=&nbsp;LoadCursorA(NULL,&nbsp;IDC_ARROW);<br />	wc.hbrBackground&nbsp;=&nbsp;(HBRUSH)COLOR_WINDOW;<br />	wc.lpszClassName&nbsp;=&nbsp;&quot;FirstWindow&quot;;<br /><br />	if&nbsp;(!RegisterClassExA(&amp;wc))<br />	{<br />		MessageBoxA(NULL,&nbsp;&quot;Failed&nbsp;to&nbsp;register&nbsp;window&nbsp;:/&quot;,&nbsp;&quot;Error&quot;,&nbsp;MB_ICONEXCLAMATION&nbsp;|&nbsp;MB_OK);<br />		return&nbsp;-1;<br />	}<br /><br />	//&nbsp;Create&nbsp;a&nbsp;Window<br />	hWnd&nbsp;=&nbsp;CreateWindowExA(WS_EX_CLIENTEDGE,&nbsp;&quot;FirstWindow&quot;,&nbsp;&quot;My&nbsp;window&nbsp;title&quot;,&nbsp;WS_OVERLAPPEDWINDOW,&nbsp;CW_USEDEFAULT,&nbsp;CW_USEDEFAULT,&nbsp;240,&nbsp;120,&nbsp;NULL,&nbsp;NULL,&nbsp;hInstance,&nbsp;NULL);<br />	if&nbsp;(hWnd&nbsp;==&nbsp;NULL)<br />	{<br />		MessageBoxA(NULL,&nbsp;&quot;Failed&nbsp;to&nbsp;create&nbsp;window&nbsp;:/&quot;,&nbsp;&quot;Error&quot;,&nbsp;MB_ICONEXCLAMATION&nbsp;|&nbsp;MB_OK);<br />		return&nbsp;-1;<br />	}<br /><br />	//&nbsp;Show&nbsp;Window&nbsp;and&nbsp;update&nbsp;it&nbsp;to&nbsp;ensure&nbsp;it&#39;s&nbsp;drawn&nbsp;correctly<br />	ShowWindow(hWnd,&nbsp;nCmdShow);<br />	UpdateWindow(hWnd);<br /><br />	//&nbsp;Initialise&nbsp;Direct3d<br />	InitDirect3d(hWnd);<br /><br />	//&nbsp;Window&nbsp;message&nbsp;Loop<br />	while&nbsp;(TRUE)<br />	{<br />		while&nbsp;(PeekMessageA(&amp;msg,&nbsp;NULL,&nbsp;0,&nbsp;0,&nbsp;PM_REMOVE))<br />		{<br />			TranslateMessage(&amp;msg);<br />			DispatchMessageA(&amp;msg);<br />		}<br /><br />		if&nbsp;(msg.message&nbsp;==&nbsp;WM_QUIT)<br />			break;<br /><br />		//&nbsp;Render&nbsp;DirectX&nbsp;frame<br />		RenderFrame();<br />	}<br /><br />	//&nbsp;Clean&nbsp;up&nbsp;DirectX<br />	CleanupDirect3d();<br /><br />	return&nbsp;msg.wParam;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1257-3.png" alt="images/1257-3.png" /></a><br /><br /><strong><h2>## Draw a Triangle</h2></strong><br />Direct3d uses FVF - Flexible Vertex Format.<br />Using FVF - you can select which blocks of the vertext to send to VRAM (instead of the whole vertex).<br /><br />e.g.<br />A vertex is a struct.<br />The struct might have 12 elements.<br />You only need to send 2 of these elements to VRAM.<br />Using FVF, you can send just those 2 elements and transfer data to VRAM much faster than if you sent the whole struct.<br /><a href=""><img src="images/1257-4.png" alt="images/1257-4.png" /></a><br /><br /><strong><h3>### Custom Vertex Formats</h3></strong><br /><strong>Create a Vertex Defnition</strong><br />You can define which vertex elements to send using custom vertex formats.<br />These are called Vertex Definitions.<br />e.g. Send just the location and the diffuse colour<br /><code>#define CUSTOMFVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)</code><br /><br /><strong>Create Verticies</strong><br />Now you can create verticies to go with your Vertex Defintion<br /><div class="codebox"><div class="codebox">struct&nbsp;CUSTOMVERTEX<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;FLOAT&nbsp;x,&nbsp;y,&nbsp;z,&nbsp;rhw;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;from&nbsp;the&nbsp;D3DFVF_XYZRHW&nbsp;flag<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;from&nbsp;the&nbsp;D3DFVF_DIFFUSE&nbsp;flag<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong>Build Vertex</strong><br />Lastly, you can build your custom vertex.<br /><div class="codebox"><div class="codebox">CUSTOMVERTEX&nbsp;OurVertex&nbsp;=&nbsp;{320.0f,&nbsp;50.0f,&nbsp;1.0f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(0,&nbsp;0,&nbsp;255)};<br /><br />CUSTOMVERTEX&nbsp;OurVertices[]&nbsp;=<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;{320.0f,&nbsp;50.0f,&nbsp;1.0f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(0,&nbsp;0,&nbsp;255),},<br />&nbsp;&nbsp;&nbsp;&nbsp;{520.0f,&nbsp;400.0f,&nbsp;1.0f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(0,&nbsp;255,&nbsp;0),},<br />&nbsp;&nbsp;&nbsp;&nbsp;{120.0f,&nbsp;400.0f,&nbsp;1.0f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(255,&nbsp;0,&nbsp;0),},<br />};</div></div><br /><br /><strong><h3>### Vertex Buffer</h3></strong><br />To ready an item for Direct3d to use, you use a vertex buffer.<br />A vertex buffer is a block of memory that stores info about your verticies.<br /><br />First you create a buffer:<br /><code>LPDIRECT3DVERTEXBUFFER9 v_buffer;</code><br /><code>CreateVertexBuffer(3*sizeof(CUSTOMVERTEX), 0, CUSTOMFVF, D3DPOOL_MANAGED, &amp;v_buffer, NULL);</code><br /><br />Before you can use it you need to lock the buffer.<br />This tells video hardware not to touch it whilst you&#39;re working on it<br /><code>Lock(0, 0, (void**)&amp;pVoid, 0);</code><br /><br />Next you copy your vertices into the buffer<br /><code>memcpy(pVoid, OurVertices, sizeof(OurVertices));</code><br /><br />And lastly you Unlock the buffer<br />to tell Direct3d that we&#39;re finished with that block of memory<br /><code>Unlock();</code><br /><br /><div class="codebox"><div class="codebox">#define CUSTOMFVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)<br /><br />struct&nbsp;CUSTOMVERTEX<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;FLOAT&nbsp;x,&nbsp;y,&nbsp;z,&nbsp;rhw;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;from&nbsp;the&nbsp;D3DFVF_XYZRHW&nbsp;flag<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;from&nbsp;the&nbsp;D3DFVF_DIFFUSE&nbsp;flag<br />}<br /><br />void&nbsp;InitGraphics()<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;three&nbsp;vertices&nbsp;using&nbsp;the&nbsp;CUSTOMVERTEX&nbsp;struct&nbsp;built&nbsp;earlier<br />&nbsp;&nbsp;&nbsp;&nbsp;CUSTOMVERTEX&nbsp;vertices[]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;320.0f,&nbsp;50.0f,&nbsp;0.5f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(0,&nbsp;0,&nbsp;255),&nbsp;},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;520.0f,&nbsp;400.0f,&nbsp;0.5f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(0,&nbsp;255,&nbsp;0),&nbsp;},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;120.0f,&nbsp;400.0f,&nbsp;0.5f,&nbsp;1.0f,&nbsp;D3DCOLOR_XRGB(255,&nbsp;0,&nbsp;0),&nbsp;},<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;the&nbsp;vertex&nbsp;and&nbsp;store&nbsp;the&nbsp;pointer&nbsp;into&nbsp;v_buffer,&nbsp;which&nbsp;is&nbsp;created&nbsp;globally<br />&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;CreateVertexBuffer(3*sizeof(CUSTOMVERTEX),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUSTOMFVF,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3DPOOL_MANAGED,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;v_buffer,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;VOID*&nbsp;pVoid;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;void&nbsp;pointer<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;v_buffer-&gt;Lock(0,&nbsp;0,&nbsp;(void**)&amp;pVoid,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lock&nbsp;the&nbsp;vertex&nbsp;buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pVoid,&nbsp;vertices,&nbsp;sizeof(vertices));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copy&nbsp;the&nbsp;vertices&nbsp;to&nbsp;the&nbsp;locked&nbsp;buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;v_buffer-&gt;Unlock();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;unlock&nbsp;the&nbsp;vertex&nbsp;buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /></div>
</body>
</html>
