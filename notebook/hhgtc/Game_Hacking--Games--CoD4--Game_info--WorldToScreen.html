<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>WorldToScreen</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># WorldToScreen</h1></strong><br />WorldToScreen is slightly different on this game.<br /><br /><strong>Links</strong><br />• <a href="https://guidedhacking.com/threads/how-to-hack-call-of-duty-games-quake-engine-games.11155/">https://guidedhacking.com/threads/how-to-hack-call-of-duty-games-quake-engine-games.11155/</a> - About WorldToScreen in the Quake Engine plus example<br />• <a href="https://www.unknowncheats.me/forum/581652-post7.html">https://www.unknowncheats.me/forum/581652-post7.html</a> - Good, working example<br /><br /><div class="codebox"><div class="codebox">bool&nbsp;WorldToScreen(vec3&nbsp;world_position,&nbsp;OUT&nbsp;vec2*&nbsp;screen_position,&nbsp;refdef_t*&nbsp;refdef)<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;Calc&nbsp;difference&nbsp;between&nbsp;world&nbsp;position&nbsp;and&nbsp;view&nbsp;origin<br />	vec3&nbsp;delta&nbsp;=&nbsp;Vec3Subtract(world_position,&nbsp;refdef-&gt;origin);<br /><br />	//&nbsp;Transformation&nbsp;matrix<br />	float&nbsp;forward&nbsp;=&nbsp;DotProduct(delta,&nbsp;refdef-&gt;view_axis[0]);<br />	float&nbsp;right&nbsp;=&nbsp;DotProduct(delta,&nbsp;refdef-&gt;view_axis[1]);<br />	float&nbsp;up&nbsp;=&nbsp;DotProduct(delta,&nbsp;refdef-&gt;view_axis[2]);<br /><br />	if&nbsp;(forward&nbsp;&lt;=&nbsp;0.f)<br />		return&nbsp;false;<br /><br />	//&nbsp;Convert&nbsp;3d&nbsp;world&nbsp;space&nbsp;to&nbsp;2d&nbsp;screen&nbsp;coordinates.<br />	screen_position-&gt;x&nbsp;=&nbsp;refdef-&gt;screen_width&nbsp;/&nbsp;2&nbsp;*&nbsp;(1.0f&nbsp;-&nbsp;(right&nbsp;/&nbsp;refdef-&gt;fov.x&nbsp;/&nbsp;forward));<br />	screen_position-&gt;y&nbsp;=&nbsp;refdef-&gt;screen_height&nbsp;/&nbsp;2&nbsp;*&nbsp;(1.0f&nbsp;-&nbsp;(up&nbsp;/&nbsp;refdef-&gt;fov.y&nbsp;/&nbsp;forward));<br /><br />	return&nbsp;true;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><div class="codebox"><div class="codebox">bool&nbsp;WorldToScreen(vec3&nbsp;world_position,&nbsp;OUT&nbsp;vec2*&nbsp;screen_position,&nbsp;refdef_t&nbsp;g_refdef)<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;Calc&nbsp;difference&nbsp;between&nbsp;world&nbsp;position&nbsp;and&nbsp;view&nbsp;origin<br />	vec3&nbsp;delta&nbsp;=&nbsp;Vec3Subtract(world_position,&nbsp;g_refdef.origin);<br /><br />	//&nbsp;Transformation&nbsp;matrix<br />	vec3&nbsp;transform&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	transform.z&nbsp;=&nbsp;DotProduct(delta,&nbsp;g_refdef.view_axis[0]);		//&nbsp;Forward<br />	transform.x&nbsp;=&nbsp;DotProduct(delta,&nbsp;g_refdef.view_axis[1]);		//&nbsp;Right<br />	transform.y&nbsp;=&nbsp;DotProduct(delta,&nbsp;g_refdef.view_axis[2]);		//&nbsp;Up<br /><br />	if&nbsp;(transform.z&nbsp;&lt;=&nbsp;0.f)<br />		return&nbsp;false;<br /><br />	//&nbsp;Convert&nbsp;3d&nbsp;world&nbsp;space&nbsp;to&nbsp;2d&nbsp;screen&nbsp;coordinates.<br />	screen_position-&gt;x&nbsp;=&nbsp;g_refdef.screen_width&nbsp;/&nbsp;2&nbsp;*&nbsp;(1.0f&nbsp;-&nbsp;(transform.x&nbsp;/&nbsp;g_refdef.fov.x&nbsp;/&nbsp;transform.z));<br />	screen_position-&gt;y&nbsp;=&nbsp;g_refdef.screen_height&nbsp;/&nbsp;2&nbsp;*&nbsp;(1.0f&nbsp;-&nbsp;(transform.y&nbsp;/&nbsp;g_refdef.fov.y&nbsp;/&nbsp;transform.z));<br /><br />	return&nbsp;true;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
