<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>sockets</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># POSIX API - Sockets</h1></strong><br />• <a href="https://beej.us/guide/bgnet/html//index.html#socket">https://beej.us/guide/bgnet/html//index.html#socket</a> - comprehensive (almost too comprehensive)<br />• <a href="https://www.thegeekstuff.com/2011/12/c-socket-programming/">https://www.thegeekstuff.com/2011/12/c-socket-programming/</a> - too basic<br />• <a href="https://www.binarytides.com/socket-programming-c-linux-tutorial/">https://www.binarytides.com/socket-programming-c-linux-tutorial/</a> - best<br />• <a href="https://www.tutorialspoint.com/unix_sockets/socket_server_example.htm">https://www.tutorialspoint.com/unix_sockets/socket_server_example.htm</a> - THE BEST<br /><br /><strong>NOTE</strong><br />• I&#39;m only writing down functions that require a explanation (because they can be complicated)<br />• and common stuff I use a lot<br /><br /><strong><h2>General Model</h2></strong><br /><strong><h3>Server</h3></strong><br />1. Create a socket - <code>socket()</code><br />2. Bind the socket - <code>bind()</code><br />3. Listen on the socket for a client - <code>listen()</code><br />4. Accept a connection from a client - <code>accept()</code><br />5. Receive and send data - <code>recv()</code> and <code>send()</code><br />6. Disconnect - <code>close()</code><br /><br /><strong><h3>Client</h3></strong><br />1. Create a socket - <code>socket()</code><br />2. Connect to the server - <code>connect()</code><br />3. Send and receive data - <code>send()</code> and <code>recv()</code><br />4. Disconnect - <code>close()</code><br /><br /><br /><strong><h2>## socket() - Create socket</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><strong><h3>Parameters</h3></strong><br /><code>int socket(int domain, int type, int protocol);</code><br /><br /><em><strong>Domain</strong></em><br />AF_INET = IPv4<br />AF_INET6 = IPv6<br />AF_UNSPEC = IPv4 or IPv6<br /><br /><em><strong>Type</strong></em><br />SOCK_STREAM = TCP<br />SOCK_DGRAM = UDP<br /><br /><em><strong>Protocol</strong></em><br />0 = any protocol<br /><br /><strong><h3>Return Value</h3></strong><br />• Success - returns a file descriptor to the socket<br />• Error - returns <code>-1</code><br /><br /><strong><h3>Usage</h3></strong><br /><code>int sock_fd = socket(AF_INET, SOCK_STREAM, 0);</code><br /><br /><strong><h2>## bind() - Bind socket to address</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><strong><h3>Parameters</h3></strong><br /><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br /><br /><em><strong>sockfd</strong></em><br />Create a socket first<br /><br /><em><strong>struct sockaddr *addr</strong></em><br />Create a <code>sockaddr_in</code> struct and define IPv4/IPv6, port, and address to bind to<br /><div class="codebox"><div class="codebox">struct&nbsp;sockaddr_in&nbsp;bind_info;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />bind_info.sin_family&nbsp;=&nbsp;AF_INET;<br />bind_info.sin_port&nbsp;=&nbsp;htons(8545);<br />bind_info.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(&quot;127.0.0.1&quot;);&nbsp;<br />//&nbsp;inet_addr&nbsp;to&nbsp;return&nbsp;IP&nbsp;address&nbsp;in&nbsp;network&nbsp;byte&nbsp;order<br />//&nbsp;can&nbsp;use&nbsp;INADDR_ANY&nbsp;for&nbsp;localhost&nbsp;<span style="color:#000000;font-weight:400">(</span>binds&nbsp;to&nbsp;0.0.0.0<span style="color:#000000;font-weight:400">)</span></div></div><br /><br />Then typecast it to a <code>sockaddr *</code> when calling the function<br /><br /><em><strong>addrlen</strong></em><br />The size of the struct you&#39;re using above<br /><br /><strong><h3>Return Value</h3></strong><br />• Success - returns <code>0</code><br />• Error - returns <code>-1</code><br /><br /><strong><h3>Usage</h3></strong><br /><code>bind(sock_fd, (struct sockaddr *)&amp;bind_info, sizeof(bind_info));</code><br /><br /><strong><h2>## listen() - Listen on bind for connection</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><strong><h3>Parameters</h3></strong><br /><code>int listen(int sockfd, int backlog);</code><br /><br /><em><strong>backlog</strong></em><br />Defines the maximum length to which the queue of pending connections may grow.<br /><br /><strong><h2>## accept() -  Accept a connection</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />Make sure you&#39;re <code>listen()</code>ing first.<br /><strong><h3>Parameters</h3></strong><br /><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br /><br /><em><strong>addr</strong></em><br />Create a <code>sockaddr_in</code> struct to store the connected client&#39;s info in<br /><code>struct sockaddr_in client1;</code><br /><br /><em><strong>addrlen</strong></em><br />Requires the length of <code>sockaddr_in</code> struct above.<br /><code>int sockaddr_in_size = sizeof(struct sockaddr_in);</code><br /><br /><strong><h3>Usage</h3></strong><br /><code>struct sockaddr_in client1;</code><br /><code>int sockaddr_in_size = sizeof(struct sockaddr_in);</code><br /><code>accept(sock_fd, (struct sockaddr *)&amp;client1, (socklen_t *)&amp;sockaddr_in_size);</code><br /><br /><strong><h3>Return Value</h3></strong><br />• Success - returns file descriptor for the accepted socket<br />• Error - returns <code>-1</code><br /><br /><strong><h3>Get client info</h3></strong><br /><code>char *client1_ip   = inet_ntoa(client1.sin_addr);</code><br /><code>int   client1_port = ntohs(client1.sin_port);</code><br /><br /><strong><h2>## connect() - Connect to remote listener</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><strong><h3>Parameters</h3></strong><br /><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br /><br /><em><strong>addr</strong></em><br />Create a <code>sockaddr_in</code> containing the remote host info<br /><div class="codebox"><div class="codebox">struct&nbsp;sockaddr_in&nbsp;remote_host;<br />remote_host.sin_family&nbsp;=&nbsp;AF_INET;<br />remote_host.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(&quot;10.10.10.10&quot;);<br />remote_host.sin_port&nbsp;=&nbsp;htons(443);</div></div><br /><br /><strong><h3>Return Value</h3></strong><br />• Success - returns <code>0</code><br />• Error - returns <code>-1</code><br /><br /><strong><h3>Usage</h3></strong><br /><code>connect(sockd_fd, (struct sockaddr *)&amp;remote_host, sizeof(remote_host));</code><br /><br /><strong><h2>## recv() - Receive data from remote listener</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><strong><h3>Parameters</h3></strong><br /><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code><br /><br /><strong><h3>Return Value</h3></strong><br />• Success - returns the number of bytes received<br />• Error - returns <code>-1</code><br /><br /><strong><h3>Usage</h3></strong><br /><code>char recv_response[1024];</code><br /><code>recv(sock_fd, recv_response, sizeof(recv_response), 0)</code><br /><br /><strong><h2>## send() - Send data to remote listener</h2></strong><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />Make sure you&#39;re <code>connect()</code>ed first and have <code>recv()</code>eived any junk data first<br /><br /><strong><h3>Usage</h3></strong><br /><code>char message[] = &quot;[+] Hey there :) \n&quot;;</code><br /><code>send(sock_fd, message, sizeof(message), 0);</code><br /><br /><br /><br /><br /><br /><br /><br /></div>
</body>
</html>
