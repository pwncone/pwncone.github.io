<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>List processes</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># List Processes</h1></strong><br />There are multiple ways to do this<br /><br /><strong><h2>## CreateToolhelp32Snapshot</h2></strong><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes">https://docs.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes</a><br /><br /><code>CreateToolhelp32Snapshot</code> grabs a snapshot of all the processes on the system.<br /><code>Process32First</code> grabs the first process in the snapshot.<br /><code>Process32Next</code> will grab the next process in the snapshot.<br /><br />Process info is stored in a <code>PROCESSENTRY32</code> struct.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;TlHelp32.h&gt;<br /><br />BOOL&nbsp;ListProcesses(void)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_snapshot&nbsp;=&nbsp;NULL;<br />	PROCESSENTRY32&nbsp;process&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	process.dwSize&nbsp;=&nbsp;sizeof(PROCESSENTRY32);<br /><br />	//&nbsp;get&nbsp;snapshot&nbsp;of&nbsp;processes<br />	h_snapshot&nbsp;=&nbsp;CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,&nbsp;0);<br />	if&nbsp;(h_snapshot&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;get&nbsp;snapshot&nbsp;of&nbsp;processes:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	<br />	//&nbsp;grab&nbsp;first&nbsp;process<br />	b_ret&nbsp;=&nbsp;Process32First(h_snapshot,&nbsp;&amp;process);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;grab&nbsp;first&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;loop&nbsp;through&nbsp;processes<br />	do<br />	{<br />		printf(&quot;\n[pid]&nbsp;%d&nbsp;&quot;,&nbsp;process.th32ProcessID);<br />		printf(&quot;\t&nbsp;[parent]&nbsp;%5d&nbsp;&quot;,&nbsp;process.th32ParentProcessID);<br />		printf(&quot;\t&nbsp;%ws&nbsp;&quot;,&nbsp;process.szExeFile);<br />	}&nbsp;while&nbsp;(Process32Next(h_snapshot,&nbsp;&amp;process)&nbsp;==&nbsp;TRUE);<br /><br />cleanup:<br />	if&nbsp;(h_snapshot)&nbsp;CloseHandle(h_snapshot);<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;list&nbsp;processes&nbsp;by&nbsp;snapshot&nbsp;\n&quot;);<br />	ListProcesses();<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1570-1.png" alt="images/1570-1.png" /></a><br /><br /><strong><h2>## psapi.h EnumProcesses</h2></strong><br />PSAPI - Process Status API - provides a set of functions for retrieving process information.<br />• <a href="https://docs.microsoft.com/en-us/windows/win32/psapi/about-psapi">https://docs.microsoft.com/en-us/windows/win32/psapi/about-psapi</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses">https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/psapi/enumerating-all-processes">https://docs.microsoft.com/en-us/windows/win32/psapi/enumerating-all-processes</a> - MSDN example<br /><br /><code>EnumProcesses</code> gets an array of process IDs.<br />Use the PID to open a handle to process with <code>OpenProcess</code><br /><code>EnumProcessModules</code> retreives a handle for each module (DLL) in the process.<br /><code>GetModuleBaseName</code> gets the process name via the module.<br /><br />Best to run this as Admin because it makes use of OpenProcess.<br />32bit proceses can&#39;t access 64bit processes with OpenProcess, so aren&#39;t listed if running as 32bit.<br />64bit version of this code also fails to find some 32bit processes.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;Psapi.h&gt;<br /><br />/*<br />List&nbsp;processes&nbsp;using&nbsp;the&nbsp;PSAPI.<br />Can&#39;t&nbsp;retrieve&nbsp;parent&nbsp;process&nbsp;ID&nbsp;(defaults&nbsp;to&nbsp;0).<br />Run&nbsp;as&nbsp;Admin&nbsp;so&nbsp;that&nbsp;OpenProcess&nbsp;doesn&#39;t&nbsp;get&nbsp;ACCESS_DENIED&nbsp;to&nbsp;things.<br />Even&nbsp;as&nbsp;Admin&nbsp;you&nbsp;get&nbsp;denied&nbsp;a&nbsp;handle&nbsp;to&nbsp;processes&nbsp;owned&nbsp;by&nbsp;SYSTEM.<br />Probaly&nbsp;wise&nbsp;to&nbsp;enable&nbsp;SeDebugPrivilege&nbsp;too.<br /><br />32bit&nbsp;proceses&nbsp;can&#39;t&nbsp;access&nbsp;64bit&nbsp;processes&nbsp;with&nbsp;OpenProcess.<br />64bit&nbsp;version&nbsp;of&nbsp;this&nbsp;code&nbsp;also&nbsp;fails&nbsp;to&nbsp;find&nbsp;some&nbsp;32bit&nbsp;processes.<br />No&nbsp;idea.<br />*/<br />BOOL&nbsp;ListProcesses(void)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	DWORD&nbsp;i_ret&nbsp;=&nbsp;0;<br />	DWORD&nbsp;process_ids[1024]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	DWORD&nbsp;bytes_returned&nbsp;=&nbsp;0;<br />	DWORD&nbsp;total_processes&nbsp;=&nbsp;0;<br />	<br />	HANDLE&nbsp;h_process&nbsp;=&nbsp;NULL;<br />	HMODULE&nbsp;h_module&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;bytes_needed&nbsp;=&nbsp;0;<br />	char&nbsp;process_name[1024]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	//&nbsp;get&nbsp;array&nbsp;of&nbsp;process&nbsp;IDs<br />	b_ret&nbsp;=&nbsp;EnumProcesses((DWORD*)&amp;process_ids,&nbsp;sizeof(process_ids),&nbsp;&amp;bytes_returned);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;enum&nbsp;processes:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	total_processes&nbsp;=&nbsp;bytes_returned&nbsp;/&nbsp;sizeof(DWORD);<br />	printf(&quot;[*]&nbsp;process&nbsp;count:&nbsp;%d&nbsp;\n&quot;,&nbsp;total_processes);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;process&nbsp;IDs<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;total_processes;&nbsp;i++)<br />	{<br />		printf(&quot;[pid]&nbsp;%5d&nbsp;&quot;,&nbsp;process_ids[i]);<br />		<br />		h_process&nbsp;=&nbsp;OpenProcess(PROCESS_QUERY_INFORMATION&nbsp;|&nbsp;PROCESS_VM_READ,&nbsp;FALSE,&nbsp;process_ids[i]);<br />		if&nbsp;(h_process&nbsp;==&nbsp;NULL)<br />		{<br />			printf(&quot;\t&nbsp;(failed:&nbsp;%d)&nbsp;\n&quot;,&nbsp;GetLastError());<br />			continue;<br />		}<br />		<br />		b_ret&nbsp;=&nbsp;EnumProcessModulesEx(h_process,&nbsp;&amp;h_module,&nbsp;sizeof(h_module),&nbsp;&amp;bytes_needed,&nbsp;LIST_MODULES_ALL);<br />		i_ret&nbsp;=&nbsp;GetModuleBaseNameA(h_process,&nbsp;h_module,&nbsp;process_name,&nbsp;1024);<br /><br />		printf(&quot;\t&nbsp;%s&nbsp;\n&quot;,&nbsp;process_name);<br />	}<br /><br />	if&nbsp;(h_process)&nbsp;CloseHandle(h_process);<br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;list&nbsp;processes&nbsp;by&nbsp;psapi&nbsp;\n\n&quot;);<br />	ListProcesses();<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1570-2.png" alt="images/1570-2.png" /></a><br /><br /><strong><h2>## WTSEnumerateProcesses</h2></strong><br />The WTS functions are RDP functions, but you can use them locally too.<br /><br /><code>WTSEnumerateProcessesEx</code> with <code>WTS_CURRENT_SERVER_HANDLE</code> to enum processes on the local host.<br /><code>ConvertSidToStringSidA</code> to grab the sid<br /><code>LookupAccountSidA</code> to grab the username from the SID<br /><br /><code>LookupAccountSidA</code> is irritating to use.<br /><br />Recommend to run as Administrator with SeDebugPrivilege enabled.<br />You can query more SIDs that way.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;WtsApi32.h&gt;<br />#include&nbsp;&lt;lmcons.h&gt;<br />#include&nbsp;&lt;sddl.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Wtsapi32.lib&quot;)<br /><br />BOOL&nbsp;EnablePrivilege(char*&nbsp;privilege)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_token&nbsp;=&nbsp;NULL;<br />	LUID&nbsp;luid&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	TOKEN_PRIVILEGES&nbsp;token_privs&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	printf(&quot;[*]&nbsp;enabling:&nbsp;%s&nbsp;\n&quot;,&nbsp;privilege);<br /><br />	//&nbsp;get&nbsp;access&nbsp;token&nbsp;of&nbsp;current&nbsp;process&nbsp;(which&nbsp;we&#39;ll&nbsp;adjust&nbsp;privileges&nbsp;of)<br />	b_ret&nbsp;=&nbsp;OpenProcessToken(GetCurrentProcess(),&nbsp;TOKEN_ADJUST_PRIVILEGES&nbsp;|&nbsp;TOKEN_QUERY,&nbsp;&amp;h_token);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;process&nbsp;token:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;grab&nbsp;LUID&nbsp;of&nbsp;requested&nbsp;privilege<br />	b_ret&nbsp;=&nbsp;LookupPrivilegeValueA(NULL,&nbsp;privilege,&nbsp;&amp;luid);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;failed&nbsp;to&nbsp;grab&nbsp;LUID&nbsp;of&nbsp;requested&nbsp;privilege:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;enable&nbsp;the&nbsp;privilege<br />	token_privs.PrivilegeCount&nbsp;=&nbsp;1;<br />	token_privs.Privileges[0].Luid&nbsp;=&nbsp;luid;<br />	token_privs.Privileges[0].Attributes&nbsp;=&nbsp;SE_PRIVILEGE_ENABLED;<br /><br />	b_ret&nbsp;=&nbsp;AdjustTokenPrivileges(h_token,&nbsp;FALSE,&nbsp;&amp;token_privs,&nbsp;sizeof(token_privs),&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[-]&nbsp;failed&nbsp;to&nbsp;enable&nbsp;privilege:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	printf(&quot;[+]&nbsp;%s&nbsp;enabled!&nbsp;\n&quot;,&nbsp;privilege);<br /><br />cleanup:<br />	if&nbsp;(h_token)&nbsp;CloseHandle(h_token);<br /><br />	return&nbsp;okay;<br />}<br /><br />BOOL&nbsp;ListProcesses(void)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br /><br />	PWTS_PROCESS_INFOA&nbsp;process&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;total_processes&nbsp;=&nbsp;0;<br /><br />	char&nbsp;username[UNLEN&nbsp;+&nbsp;1]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	char&nbsp;domain_name[DNLEN&nbsp;+&nbsp;1]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	DWORD&nbsp;username_len&nbsp;=&nbsp;UNLEN&nbsp;+&nbsp;1;<br />	DWORD&nbsp;domain_name_len&nbsp;=&nbsp;DNLEN&nbsp;+&nbsp;1;<br />	SID_NAME_USE&nbsp;account_type&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	char*&nbsp;sid_string&nbsp;=&nbsp;NULL;<br /><br />	b_ret&nbsp;=&nbsp;WTSEnumerateProcessesA(WTS_CURRENT_SERVER_HANDLE,&nbsp;0,&nbsp;1,&nbsp;&amp;process,&nbsp;&amp;total_processes);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;enum&nbsp;processes:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br /><br />	printf(&quot;[*]&nbsp;total&nbsp;processes:&nbsp;%d&nbsp;\n&quot;,&nbsp;total_processes);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;processes<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;total_processes;&nbsp;i++)<br />	{<br />		//&nbsp;grab&nbsp;process&nbsp;ID<br />		printf(&quot;[pid]&nbsp;%5d&nbsp;&quot;,&nbsp;process[i].ProcessId);<br />		<br />		//&nbsp;grab&nbsp;SID<br />		printf(&quot;[sid]&nbsp;&quot;);<br />		b_ret&nbsp;=&nbsp;ConvertSidToStringSidA(process[i].pUserSid,&nbsp;&amp;sid_string);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;%30s(failed:&nbsp;%d)&nbsp;&quot;,&nbsp;&quot;&quot;,&nbsp;GetLastError());<br />		}<br />		else<br />		{<br />			printf(&quot;%42s&nbsp;&quot;,&nbsp;sid_string);<br />			LocalFree(sid_string);<br />		}<br />		<br />		//&nbsp;grab&nbsp;username<br />		/*&nbsp;<br />		With&nbsp;LookupAccountSid&nbsp;it&#39;s&nbsp;best&nbsp;to&nbsp;call&nbsp;it&nbsp;twice:<br />		-&nbsp;1st&nbsp;time&nbsp;to&nbsp;get&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;returned&nbsp;username&nbsp;and&nbsp;domain&nbsp;name,&nbsp;and&nbsp;then&nbsp;allocate&nbsp;buffers&nbsp;for&nbsp;them<br />		-&nbsp;2nd&nbsp;time&nbsp;to&nbsp;get&nbsp;the&nbsp;username&nbsp;and&nbsp;domain&nbsp;name<br />		Here&nbsp;I&#39;m&nbsp;doing&nbsp;it&nbsp;wrong&nbsp;and&nbsp;just&nbsp;resetting&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;username&nbsp;and&nbsp;domain_name&nbsp;strings&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;loop<br />		*/<br />		printf(&quot;[usr]&nbsp;&quot;);<br />		b_ret&nbsp;=&nbsp;LookupAccountSidA(NULL,&nbsp;process[i].pUserSid,&nbsp;username,&nbsp;&amp;username_len,&nbsp;domain_name,&nbsp;&amp;domain_name_len,&nbsp;&amp;account_type);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />			printf(&quot;%3s(failed:&nbsp;%d)&nbsp;&quot;,&nbsp;&quot;&quot;,&nbsp;GetLastError());<br />		else<br />			printf(&quot;%15s&nbsp;&quot;,&nbsp;username);<br />		<br />		//&nbsp;grab&nbsp;process&nbsp;name<br />		printf(&quot;\t&nbsp;%s&nbsp;\n&quot;,&nbsp;process[i].pProcessName);<br /><br />		username_len&nbsp;=&nbsp;UNLEN&nbsp;+&nbsp;1;<br />		domain_name_len&nbsp;=&nbsp;DNLEN&nbsp;+&nbsp;1;<br />	}<br /><br />cleanup:<br />	if&nbsp;(process)&nbsp;WTSFreeMemory(process);<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;list&nbsp;processes&nbsp;via&nbsp;WTS&nbsp;\n\n&quot;);<br />	<br />	EnablePrivilege(&quot;SeDebugPrivilege&quot;);<br />	ListProcesses();<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1570-3.png" alt="images/1570-3.png" /></a><br /><br /><strong><h2>## Brute force open PIDs</h2></strong><br />If you can open a handle to the process, you can assume that process exists.<br />• <a href="https://github.com/umerov1999/metasploit-payloads/blob/e48f3432ff5b673c5b6bf1893c2cccf2974f084d/c/meterpreter/source/extensions/stdapi/server/sys/process/ps.c#L550">https://github.com/umerov1999/metasploit-payloads/blob/e48f3432ff5b673c5b6bf1893c2cccf2974f084d/c/meterpreter/source/extensions/stdapi/server/sys/process/ps.c#L550</a><br /><br /><strong><h2>## Ignore process list structure and query them all the returned values as unsigned ints to query all the process IDs</h2></strong><br />• <a href="https://youtu.be/a0KozcRhotM?t=2226">https://youtu.be/a0KozcRhotM?t=2226</a><br /><br />Windows has some &quot;security&quot; processes that remove themselves from the EPROCESS list so that you can&#39;t grab their process ID.<br />Open all the valid process IDs on the system and see which ones give you <code>ACCESS_DENIED</code> and <code>INVALID_PARAMTER</code>.<br /><code>ACCESS_DENIED</code> processes are the ones that are valid processes but that you&#39;re not allowed to see.<br /><br /><h2>## NtQuerySystemInformation with SystemProcessInformation</h2><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Ntdll.lib&quot;)<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	SYSTEM_PROCESS_INFORMATION*&nbsp;info&nbsp;=&nbsp;NULL;<br />	ULONG&nbsp;size_needed&nbsp;=&nbsp;0;<br />	NTSTATUS&nbsp;status&nbsp;=&nbsp;NtQuerySystemInformation(SystemProcessInformation,&nbsp;NULL,&nbsp;0,&nbsp;&amp;size_needed);<br />	if&nbsp;(status&nbsp;==&nbsp;(NTSTATUS)0xC0000004L)	//&nbsp;STATUS_INFO_LENGTH_MISMATCH<br />	{<br />		printf(&quot;*&nbsp;Size&nbsp;needed:&nbsp;%d&nbsp;\n&quot;,&nbsp;size_needed);<br />		info&nbsp;=&nbsp;malloc(size_needed);<br />	}<br />	else&nbsp;if&nbsp;(!NT_SUCCESS(status))&nbsp;{<br />		printf(&quot;-&nbsp;Failed&nbsp;to&nbsp;NtQuerySystemInformation:&nbsp;0x%lx&nbsp;(%d)&nbsp;\n&quot;,&nbsp;status,&nbsp;size_needed);<br />		return&nbsp;0;<br />	}<br /><br />	status&nbsp;=&nbsp;NtQuerySystemInformation(SystemProcessInformation,&nbsp;info,&nbsp;size_needed,&nbsp;&amp;size_needed);<br />	if&nbsp;(!NT_SUCCESS(status))&nbsp;{<br />		printf(&quot;-&nbsp;Failed&nbsp;to&nbsp;NtQuerySystemInformation:&nbsp;0x%lx&nbsp;(%d)&nbsp;\n&quot;,&nbsp;status,&nbsp;size_needed);<br />		return&nbsp;0;<br />	}<br /><br />	SYSTEM_PROCESS_INFORMATION*&nbsp;process&nbsp;=&nbsp;(SYSTEM_PROCESS_INFORMATION*)((size_t)info&nbsp;+&nbsp;info-&gt;NextEntryOffset);<br />	do&nbsp;<br />	{<br />		printf(&quot;%ws&nbsp;\n&quot;,&nbsp;process-&gt;ImageName.Buffer);<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;process<br />		//&nbsp;For&nbsp;the&nbsp;last&nbsp;item&nbsp;in&nbsp;the&nbsp;array,&nbsp;NextEntryOffset&nbsp;is&nbsp;0<br />		process&nbsp;=&nbsp;(SYSTEM_PROCESS_INFORMATION*)((size_t)process&nbsp;+&nbsp;process-&gt;NextEntryOffset);<br />	}&nbsp;while&nbsp;(process-&gt;NextEntryOffset&nbsp;!=&nbsp;0);<br /><br />	free(info);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /></div>
</body>
</html>
