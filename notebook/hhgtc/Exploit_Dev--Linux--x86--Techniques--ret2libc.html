<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ret2libc</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Exploit Development - Linux - x86 - ret2libc</h1></strong><br /><a href="https://www.youtube.com/watch?v=eFzYISSiheM">https://www.youtube.com/watch?v=eFzYISSiheM</a><br /><a href="http://phrack.org/issues/58/4.html">http://phrack.org/issues/58/4.html</a> - advanced ret2libc<br /><br />A ret2libc attack is where you overwrite the return address on the stack to point to a function in <code>libc</code>, like <code>system()</code>. <br /><br />ret2libc is a way of bypassing a Non-eXecutable - <code>NX</code> - stack.<br /><br /><strong><h2>## What is libc?</h2></strong><br /><code>libc</code> is the C standard library - <a href="https://en.wikipedia.org/wiki/C_standard_library">https://en.wikipedia.org/wiki/C_standard_library</a> - which provides a multitude of functions for basic tasks like handling strings, interacting with the OS, memory management etc. <br />Functions include:<br /><code>printf()</code> - to print text to stdout<br /><code>system()</code> - to execute system commands<br /><br /><code>libc</code> is included in (basically) every C program. You&#39;d be reinventing the wheel if you didn&#39;t use it.<br />A program that inlcudes <code>libc</code>, when it starts executing, will load the contents of <code>libc</code> into memory.<br /><br /><strong><h2>## ret2libc</h2></strong><br />In the context of exploit development, if for some reason we can&#39;t execute shellcode that we&#39;ve dropped onto the stack (NX/DEP protection, for example), we can instead overwrite EIP and tell it to jump to a function in the <code>libc</code> library and execute it. This is called a <em>ret2libc</em> attack.<br /><br />The easiest/most effective function to jump to in <code>libc</code> is <code>system()</code> - which executes system commands.<br />If we run <code>system(&quot;/bin/sh&quot;)</code>, we can spawn a shell.<br /><br />So, instead of writing and dropping shellcode onto the stack, we can simply jump to the address of <code>system()</code> in <code>libc</code>, write the argument of <code>/bin/sh</code> onto the stack, and spawn a shell. The genius of ret2libc is that we&#39;re re-using code that already exists within <code>libc</code> for our own exploitative purposes, not writing anything new.<br /><br />When you overflow the buffer with the right values, here is how the ret2libc system() attack will look on the stack:<br /><a href=""><img src="images/635-1.png" alt="images/635-1.png" /></a><br /><br /><strong><h2>## The libc exit address</h2></strong><br /><code>libc</code> assumes that it&#39;s been called by a function/a caller.<br />This means that, when <code>system()</code> exits, it will look for a return address on the stack and attempt to return to the function/caller that called it.<br />	<br />	- If you don&#39;t care about the program crashing upon exit, you can put any 4 random bytes (AAAA) as the return address<br />	- If you want the program to exit cleanly after being exploited/system() has run, then you should enter a valid address that the program can return to<br /><br /><strong><h2>## What binary protections can be bypassed using ret2libc?</h2></strong><br />ret2libc can be used to bypass:<br />• NX (non-executable stack) &amp; DEP (data execution prevention)<br />• A restricted return address<br />• and probably lots more <code>things</code><br /><br /></div>
</body>
</html>
