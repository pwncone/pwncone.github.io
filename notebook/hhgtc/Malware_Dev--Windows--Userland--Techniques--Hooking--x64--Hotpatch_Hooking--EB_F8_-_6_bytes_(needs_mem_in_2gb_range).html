<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>EB F8 - 6 bytes (needs mem in 2gb range)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x64 Hotpatch Hook - EB F8 to jump 6 bytes back</h1></strong><br />Apparently Microsoft says that you only need 6 bytes of free space on x64 for hotpatching.<br />(according to here at the <em>x64 Function Patching</em> heading, can&#39;t find their source for this:) <br /><a href="https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx">https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx</a><br /><br />There&#39;s a good explanation in the comments about how to do this:<br /><a href="https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx">https://www.codeproject.com/Articles/1043089/HotPatching-VERY-Deep-Inside?msg=5164819#xx5164819xx</a><br />And this article explains the concept too:<br /><a href="https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for">https://docs.microsoft.com/en-gb/archive/blogs/freik/what-does-hot-patchability-mean-and-what-is-it-for</a><br /><br />However, <br />this technique relies on being able to find free memory within a 2gb range of the function you&#39;re patching.<br />(because FF 25 requries a 32bit value)<br />You:<br />• find free memory within a 2gb range of your target function<br />• write the 64bit address of your hook code there<br />• overwrite the first 6 bytes of hotpatch space with FF 25 &lt;addr of memory in 2gb range&gt;<br />• overwrite the first 2 bytes of the target function with jmp $-6 (jump 6 bytes back)<br /><br />Now whenever the target function is called it will:<br />• jump 6 bytes back (into the hotpatch space)<br />• run FF 25 and read the 64bit address from the free memory<br />• jump to the 64bit address (which will be your trampoline)<br /><br /><strong><h2>## MessageBoxA Demo</h2></strong><br />Here&#39;s MessageBoxA before it&#39;s been hooked.<br />It&#39;s got 6 bytes of hotpatch space before it (actually it&#39;s ~14, but we only need 6)<br /><a href=""><img src="images/1687-1.png" alt="images/1687-1.png" /></a><br /><br />Here&#39;s MessageBoxA after it&#39;s been hooked.<br />We&#39;ve overwritten the first 2 bytes with an EB F8 to jump 6 bytes back - to <code>0x00007FFE3F41AC2A</code><br />At <code>0x00007FFE3F41AC2A</code> is an indirect jump.<br />It will grab the 64bit address at <code>0x7FFE3F080000</code> and jump there.<br /><a href=""><img src="images/1687-2.png" alt="images/1687-2.png" /></a><br /><br />Here&#39;s the address at <code>0x7FFE3F080000</code> - <code>0x000002b1a8db0014</code><br />This is the address of the jump to our hook code in the trampoline.<br /><a href=""><img src="images/1687-3.png" alt="images/1687-3.png" /></a><br /><br />Here&#39;s <code>0x000002b1a8db0014</code> - the jump to our hook code inside of the trampoline.<br /><a href=""><img src="images/1687-4.png" alt="images/1687-4.png" /></a><br /><br />And here&#39;s the complete trampoline.<br />• At the start, you can see the 4 bytes we overwrote in MessageBoxA.<br />• Following that is a push rax; ret to reach the original function.<br />• And following that is a push rax; ret to reach my hook code - hook_MessageBoxA()<br /><a href=""><img src="images/1687-5.png" alt="images/1687-5.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br />In this code I&#39;ve also used a disassembler to grab the length of the instructions I&#39;m overwriting<br />and fill out any extra instructions with NOPs.<br /><br />I&#39;ve used HDE - which can be found in Minhook&#39;s source:<br /><a href="https://github.com/TsudaKageyu/minhook/tree/master/src/hde">https://github.com/TsudaKageyu/minhook/tree/master/src/hde</a><br /><br /><div class="codebox"><div class="codebox">/*<br />x64&nbsp;hotpatch&nbsp;hooking<br />using&nbsp;an&nbsp;EB&nbsp;F8&nbsp;to&nbsp;jump&nbsp;6&nbsp;bytes&nbsp;back.<br />6&nbsp;bytes&nbsp;back,&nbsp;in&nbsp;the&nbsp;hotpatch&nbsp;space,&nbsp;is&nbsp;an&nbsp;indirect&nbsp;jump&nbsp;-&nbsp;FF&nbsp;25&nbsp;&lt;memory&nbsp;within&nbsp;2gb&nbsp;range&gt;<br />Stored&nbsp;at&nbsp;the&nbsp;memory&nbsp;within&nbsp;a&nbsp;2gb&nbsp;range&nbsp;is&nbsp;the&nbsp;64bit&nbsp;address&nbsp;of&nbsp;our&nbsp;trampoline.<br />The&nbsp;FF&nbsp;25&nbsp;will&nbsp;jump&nbsp;to&nbsp;the&nbsp;trampoline,&nbsp;and&nbsp;the&nbsp;trampoline&nbsp;will&nbsp;jump&nbsp;to&nbsp;our&nbsp;hook.<br /><br />Overwrites&nbsp;2&nbsp;bytes&nbsp;at&nbsp;the&nbsp;start&nbsp;function&nbsp;(EB&nbsp;F0).<br />Requires:<br />-&nbsp;6&nbsp;bytes&nbsp;of&nbsp;hotpatch&nbsp;space&nbsp;before&nbsp;the&nbsp;function&nbsp;(for&nbsp;FF&nbsp;25&nbsp;00&nbsp;00&nbsp;00&nbsp;00).<br />-&nbsp;8&nbsp;bytes&nbsp;of&nbsp;free&nbsp;memory&nbsp;within&nbsp;a&nbsp;2gb&nbsp;range&nbsp;of&nbsp;the&nbsp;target&nbsp;function&nbsp;(to&nbsp;store&nbsp;the&nbsp;64bit&nbsp;address&nbsp;of&nbsp;the&nbsp;trampoline)<br />*/<br /><br />#define&nbsp;_CRT_SECURE_NO_WARNING<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&quot;hde/hde64.h&quot;<br /><br />int(__stdcall*&nbsp;orig_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hook_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxA&nbsp;intercepted!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;text:&nbsp;%s&nbsp;\n\t&nbsp;caption:&nbsp;%s&nbsp;\n\t&nbsp;type:&nbsp;%d&nbsp;\n&quot;,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br /><br />	return&nbsp;orig_MessageBoxA(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />void*&nbsp;FindMemoryWithin2GBRange(void*&nbsp;base)<br />{<br />	SYSTEM_INFO&nbsp;sys_info&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	MEMORY_BASIC_INFORMATION&nbsp;mbi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	size_t&nbsp;ret&nbsp;=&nbsp;0;<br /><br />	UINT_PTR&nbsp;mem_address&nbsp;=&nbsp;(UINT_PTR)base;<br />	UINT_PTR&nbsp;min_addr&nbsp;=&nbsp;mem_address&nbsp;-&nbsp;0x7FFFFFFF;		//&nbsp;+&nbsp;2gb<br />	UINT_PTR&nbsp;max_addr&nbsp;=&nbsp;mem_address&nbsp;+&nbsp;0x7FFFFFFF;		//&nbsp;-&nbsp;2gb<br /><br />	/*<br />	Grab&nbsp;allocation&nbsp;granularity&nbsp;(boundary&nbsp;on&nbsp;which&nbsp;memory&nbsp;aligns,&nbsp;usually&nbsp;0x10000&nbsp;-&nbsp;65kb)<br />	and&nbsp;calculate&nbsp;start&nbsp;address&nbsp;to&nbsp;search&nbsp;from&nbsp;by&nbsp;rounding&nbsp;down&nbsp;to&nbsp;the&nbsp;nearest&nbsp;allocation&nbsp;granularity.<br />	*/<br />	GetSystemInfo(&amp;sys_info);<br />	mem_address&nbsp;-=&nbsp;mem_address&nbsp;%&nbsp;sys_info.dwAllocationGranularity;<br /><br />	//&nbsp;Search&nbsp;for&nbsp;memory&nbsp;below<br />	do<br />	{<br />		ret&nbsp;=&nbsp;VirtualQuery((void*)mem_address,&nbsp;&amp;mbi,&nbsp;sizeof(mbi));<br />		if&nbsp;(ret&nbsp;==&nbsp;0)	//&nbsp;if&nbsp;VirtualQuery&nbsp;failed<br />			break;<br /><br />		if&nbsp;(mbi.State&nbsp;==&nbsp;MEM_FREE)<br />			return&nbsp;(void*)mem_address;<br /><br />		/*<br />		AllocationBase&nbsp;points&nbsp;to&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;the&nbsp;range&nbsp;of&nbsp;pages&nbsp;queried&nbsp;by&nbsp;VirtualAlloc.<br />		e.g.<br />			You&nbsp;VirtualQuery&nbsp;an&nbsp;address&nbsp;in&nbsp;the&nbsp;middle&nbsp;of&nbsp;User32.dll&nbsp;-&nbsp;0x7ffecbcfacf0<br />			mbi.AllocationBase&nbsp;will&nbsp;be&nbsp;0x7ffecbc80000&nbsp;(the&nbsp;address&nbsp;of&nbsp;User32.dll)<br />		Subtract&nbsp;the&nbsp;dwAllocationGranulairty&nbsp;to&nbsp;find&nbsp;the&nbsp;next&nbsp;memory&nbsp;page&nbsp;to&nbsp;query.<br />		*/<br />		mem_address&nbsp;=&nbsp;(UINT_PTR)mbi.AllocationBase&nbsp;-&nbsp;sys_info.dwAllocationGranularity;<br />	}&nbsp;while&nbsp;(mem_address&nbsp;&gt;=&nbsp;min_addr);<br /><br />	//&nbsp;Search&nbsp;for&nbsp;memory&nbsp;above<br />	mem_address&nbsp;-=&nbsp;mem_address&nbsp;%&nbsp;sys_info.dwAllocationGranularity;		//&nbsp;Reset&nbsp;start&nbsp;address<br />	do<br />	{<br />		ret&nbsp;=&nbsp;VirtualQuery((void*)mem_address,&nbsp;&amp;mbi,&nbsp;sizeof(mbi));<br />		if&nbsp;(ret&nbsp;==&nbsp;0)	//&nbsp;if&nbsp;VirtualQuery&nbsp;failed<br />			break;<br /><br />		if&nbsp;(mbi.State&nbsp;==&nbsp;MEM_FREE)<br />			return&nbsp;(void*)mem_address;<br /><br />		//&nbsp;Calculate&nbsp;end&nbsp;of&nbsp;queried&nbsp;memory&nbsp;region<br />		mem_address&nbsp;=&nbsp;(UINT_PTR)mbi.BaseAddress&nbsp;+&nbsp;mbi.RegionSize;<br />		//&nbsp;Add&nbsp;allocation&nbsp;granularity&nbsp;(-1&nbsp;in&nbsp;case&nbsp;memory&nbsp;regions&nbsp;are&nbsp;spaced&nbsp;0x10000&nbsp;bytes&nbsp;(size&nbsp;of&nbsp;dwAllocationGranularity)&nbsp;between&nbsp;eachother)<br />		mem_address&nbsp;+=&nbsp;sys_info.dwAllocationGranularity&nbsp;-&nbsp;1;<br />		//&nbsp;Round&nbsp;down&nbsp;to&nbsp;allocation&nbsp;granularity<br />		mem_address&nbsp;-=&nbsp;mem_address&nbsp;%&nbsp;sys_info.dwAllocationGranularity;<br /><br />	}&nbsp;while&nbsp;(mem_address&nbsp;&gt;=&nbsp;min_addr);<br /><br />	return&nbsp;NULL;<br />}<br /><br />/*<br />Hook&nbsp;a&nbsp;function&nbsp;using&nbsp;hotpatch&nbsp;space.<br />Requires&nbsp;14&nbsp;bytes&nbsp;of&nbsp;space&nbsp;before&nbsp;the&nbsp;function.<br />Parameters:<br />	char*&nbsp;function&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;function&nbsp;to&nbsp;hook<br />	char*&nbsp;dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;DLL&nbsp;where&nbsp;the&nbsp;function&nbsp;resides<br />	void*&nbsp;detour&nbsp;&nbsp;&nbsp;-&nbsp;the&nbsp;function&nbsp;to&nbsp;detour&nbsp;to<br />	void**&nbsp;p_orig&nbsp;&nbsp;-&nbsp;address&nbsp;of&nbsp;the&nbsp;pointer&nbsp;to&nbsp;the&nbsp;original&nbsp;function<br />Return:<br />	Number&nbsp;of&nbsp;bytes&nbsp;overwritten&nbsp;in&nbsp;original&nbsp;function.&nbsp;Use&nbsp;this&nbsp;value&nbsp;for&nbsp;Unhook().<br />*/<br />int&nbsp;HotpatchHook64(char*&nbsp;function,&nbsp;char*&nbsp;dll,&nbsp;void*&nbsp;detour,&nbsp;void**&nbsp;p_orig)<br />{<br />	//&nbsp;Grab&nbsp;address&nbsp;of&nbsp;target&nbsp;function<br />	void*&nbsp;orig_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(dll),&nbsp;function);<br />	void*&nbsp;free_memory&nbsp;=&nbsp;FindMemoryWithin2GBRange(orig_func);<br />	if&nbsp;(free_memory&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;find&nbsp;free&nbsp;memory&nbsp;within&nbsp;a&nbsp;2gb&nbsp;range&nbsp;of:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;orig_func);<br />		return&nbsp;0;<br />	}<br /><br />	<br />	//&nbsp;Disassemble&nbsp;instructions&nbsp;@&nbsp;function&nbsp;until&nbsp;we&nbsp;have&nbsp;enough&nbsp;space&nbsp;for&nbsp;hook.<br />	BOOL&nbsp;disassemble&nbsp;=&nbsp;TRUE;<br />	void*&nbsp;instruction&nbsp;=&nbsp;orig_func;<br />	int&nbsp;bytes_disassembled&nbsp;=&nbsp;0;<br />	int&nbsp;bytes_requried&nbsp;=&nbsp;2;<br />	do<br />	{<br />		hde64s&nbsp;hs&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />		unsigned&nbsp;int&nbsp;instruction_size&nbsp;=&nbsp;hde64_disasm(instruction,&nbsp;&amp;hs);<br />		if&nbsp;(hs.flags&nbsp;&amp;&nbsp;F_ERROR)		//&nbsp;Failed&nbsp;to&nbsp;disassemble<br />			return&nbsp;0;<br /><br />		//&nbsp;Quit&nbsp;if&nbsp;we&#39;ve&nbsp;disassembled&nbsp;enough&nbsp;instructions&nbsp;for&nbsp;our&nbsp;hook<br />		bytes_disassembled&nbsp;+=&nbsp;instruction_size;<br />		if&nbsp;(bytes_disassembled&nbsp;&gt;=&nbsp;bytes_requried)<br />			break;<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;instruction<br />		(UINT_PTR)instruction&nbsp;+=&nbsp;instruction_size;<br />	}&nbsp;while&nbsp;(disassemble&nbsp;==&nbsp;TRUE);<br /><br />	/*<br />	Allocate&nbsp;trampoline&nbsp;space<br />	Trampoline&nbsp;size&nbsp;needs&nbsp;32&nbsp;extra&nbsp;bytes&nbsp;after&nbsp;prologue&nbsp;code:<br />	-&nbsp;16&nbsp;for&nbsp;jump&nbsp;to&nbsp;original&nbsp;function<br />	-&nbsp;16&nbsp;for&nbsp;jump&nbsp;to&nbsp;hook&nbsp;function<br />	*/<br />	int&nbsp;trampoline_size&nbsp;=&nbsp;bytes_disassembled&nbsp;+&nbsp;32;<br />	void*&nbsp;trampoline&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;trampoline_size,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br /><br />	/*<br />	Allocate&nbsp;8&nbsp;bytes&nbsp;of&nbsp;space&nbsp;within&nbsp;2gb&nbsp;range&nbsp;of&nbsp;original&nbsp;function.<br />	Write&nbsp;64bit&nbsp;address&nbsp;there&nbsp;(address&nbsp;in&nbsp;trampoline&nbsp;that&nbsp;contains&nbsp;the&nbsp;jump&nbsp;to&nbsp;our&nbsp;detour&nbsp;function).<br />	*/<br />	void*&nbsp;relay&nbsp;=&nbsp;VirtualAlloc(free_memory,&nbsp;8,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	DWORD64&nbsp;jmp_detour&nbsp;=&nbsp;(DWORD64)trampoline&nbsp;+&nbsp;bytes_disassembled&nbsp;+&nbsp;16;<br />	memset(relay,&nbsp;0xCC,&nbsp;8);<br />	memcpy(relay,&nbsp;&amp;jmp_detour,&nbsp;8);<br /><br />	/*<br />	Construct&nbsp;trampoline.<br />	*/<br />	unsigned&nbsp;char&nbsp;trampoline_jumps[32]&nbsp;=&nbsp;{<br />		0x50,<br />		0x48,&nbsp;0xB8,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,<br />		0x48,&nbsp;0x87,&nbsp;0x04,&nbsp;0x24,<br />		0xC3,<br />		0x50,<br />		0x48,&nbsp;0xB8,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,&nbsp;0x00,<br />		0x48,&nbsp;0x87,&nbsp;0x04,&nbsp;0x24,<br />		0xC3<br />	};<br />	DWORD64&nbsp;jmp_origfunction&nbsp;=&nbsp;(DWORD64)orig_func&nbsp;+&nbsp;bytes_disassembled;<br />	memcpy(trampoline_jumps&nbsp;+&nbsp;3,&nbsp;&amp;jmp_origfunction,&nbsp;8);<br />	memcpy(trampoline_jumps&nbsp;+&nbsp;19,&nbsp;&amp;detour,&nbsp;8);<br /><br />	//&nbsp;Write&nbsp;data&nbsp;to&nbsp;trampoline<br />	memcpy(trampoline,&nbsp;orig_func,&nbsp;bytes_disassembled);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Prologue&nbsp;from&nbsp;original&nbsp;function<br />	memcpy((void*)((DWORD64)trampoline&nbsp;+&nbsp;bytes_disassembled),&nbsp;trampoline_jumps,&nbsp;32);	&nbsp;&nbsp;//&nbsp;Jumps&nbsp;to&nbsp;original&nbsp;function&nbsp;and&nbsp;detour&nbsp;function<br /><br />	/*<br />	Construct&nbsp;hook.&nbsp;8&nbsp;bytes&nbsp;long.<br />	Remaining&nbsp;bytes&nbsp;filled&nbsp;with&nbsp;NOPs.<br />	0&nbsp;&nbsp;&nbsp;FF&nbsp;25&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;qword&nbsp;ptr&nbsp;&lt;memory&nbsp;within&nbsp;2gb&nbsp;range&gt;<br />	6&nbsp;&nbsp;&nbsp;EB&nbsp;F8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;jump&nbsp;6&nbsp;bytes&nbsp;back<br />	*/<br />	DWORD64&nbsp;jmp_relay&nbsp;=&nbsp;(DWORD)((DWORD64)relay&nbsp;-&nbsp;(DWORD64)orig_func);<br />	int&nbsp;hook_size&nbsp;=&nbsp;6&nbsp;+&nbsp;bytes_disassembled;<br />	<br />	unsigned&nbsp;char*&nbsp;hook&nbsp;=&nbsp;malloc(hook_size);<br />	memset(hook,&nbsp;0xCC,&nbsp;hook_size);<br />	memcpy(hook,&nbsp;&quot;\xFF\x25&quot;,&nbsp;2);<br />	memcpy(hook&nbsp;+&nbsp;2,&nbsp;&amp;jmp_relay,&nbsp;4);<br />	memcpy(hook&nbsp;+&nbsp;6,&nbsp;&quot;\xEB\xF8&quot;,&nbsp;2);<br /><br />	//&nbsp;Install&nbsp;hook&nbsp;at&nbsp;function<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	void*&nbsp;patch_addr&nbsp;=&nbsp;(void*)((DWORD64)orig_func&nbsp;-&nbsp;6);<br />	VirtualProtect(patch_addr,&nbsp;hook_size,&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />	memcpy(patch_addr,&nbsp;hook,&nbsp;hook_size);<br />	VirtualProtect(patch_addr,&nbsp;hook_size,&nbsp;old_protect,&nbsp;&amp;old_protect);<br /><br />	/*<br />	Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;function&nbsp;+&nbsp;bytes_disassembled.<br />	This&nbsp;dodges&nbsp;the&nbsp;EB&nbsp;F2&nbsp;at&nbsp;the&nbsp;start&nbsp;which&nbsp;jumps&nbsp;into&nbsp;hotpatch&nbsp;space<br />	and&nbsp;instead&nbsp;executes&nbsp;the&nbsp;original&nbsp;function.<br />	*/<br />	*p_orig&nbsp;=&nbsp;trampoline;<br /><br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;patch_addr,&nbsp;hook_size);<br />	return&nbsp;bytes_disassembled;<br />}<br /><br />/*<br />Unhook&nbsp;a&nbsp;function&nbsp;installed&nbsp;in&nbsp;hotpatch&nbsp;space.<br />Parameters:<br />	char*&nbsp;function&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;function&nbsp;to&nbsp;unhook<br />	char*&nbsp;dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name&nbsp;of&nbsp;the&nbsp;DLL&nbsp;where&nbsp;the&nbsp;function&nbsp;resides<br />	int&nbsp;bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;overwritten&nbsp;in&nbsp;the&nbsp;function<br />	void*&nbsp;trampoline&nbsp;&nbsp;-&nbsp;pointer&nbsp;to&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;trampoline&nbsp;space<br />*/<br />BOOL&nbsp;HotpatchUnhook64(char*&nbsp;function,&nbsp;char*&nbsp;dll,&nbsp;int&nbsp;bytes,&nbsp;void*&nbsp;trampoline)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;FALSE;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	/*<br />	Grab&nbsp;address&nbsp;of&nbsp;original&nbsp;function,<br />	make&nbsp;it&nbsp;writable,<br />	restore&nbsp;hotpatch&nbsp;space&nbsp;with&nbsp;6&nbsp;0xCC,<br />	and&nbsp;restore&nbsp;the&nbsp;function&#39;s&nbsp;overwritten&nbsp;instructions&nbsp;using&nbsp;those&nbsp;in&nbsp;the&nbsp;trampoline.<br />	*/<br />	void*&nbsp;orig_func&nbsp;=&nbsp;GetProcAddress(LoadLibraryA(dll),&nbsp;function);<br />	void*&nbsp;patch_addr&nbsp;=&nbsp;(void*)((DWORD64)orig_func&nbsp;-&nbsp;6);<br />	int&nbsp;patch_size&nbsp;=&nbsp;14&nbsp;+&nbsp;bytes;<br />	<br />	VirtualProtect(patch_addr,&nbsp;patch_size,&nbsp;PAGE_READWRITE,&nbsp;&amp;old_protect);<br />	memcpy(patch_addr,&nbsp;&quot;\xCC\xCC\xCC\xCC\xCC\xCC&quot;,&nbsp;6);<br />	memcpy((BYTE*)patch_addr&nbsp;+&nbsp;6,&nbsp;trampoline,&nbsp;bytes);<br />	VirtualProtect(patch_addr,&nbsp;patch_size,&nbsp;old_protect,&nbsp;&amp;old_protect);<br /><br />	/*<br />	Free&nbsp;trampoline&nbsp;space<br />	and&nbsp;flush&nbsp;instruction&nbsp;cache&nbsp;at&nbsp;original&nbsp;function.<br />	*/<br />	VirtualFree(trampoline,&nbsp;0,&nbsp;MEM_RELEASE);<br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;patch_addr,&nbsp;patch_size);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;I&nbsp;think&nbsp;I&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;Hmm...&quot;,&nbsp;MB_OK);<br /><br />	int&nbsp;bytes&nbsp;=&nbsp;HotpatchHook64(&quot;MessageBoxA&quot;,&nbsp;&quot;User32.dll&quot;,&nbsp;&amp;hook_MessageBoxA,&nbsp;(void*)&amp;orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&quot;,&nbsp;&quot;Hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;Hello&nbsp;good&nbsp;sir!&quot;,&nbsp;&quot;Hi&nbsp;#2&quot;,&nbsp;MB_OK);<br /><br />	HotpatchUnhook64(&quot;MessageBoxA&quot;,&nbsp;&quot;User32.dll&quot;,&nbsp;bytes,&nbsp;(void*)orig_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;Did&nbsp;he&nbsp;hear&nbsp;me&nbsp;ok?&quot;,&nbsp;&quot;Hmm...&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
