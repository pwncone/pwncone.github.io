<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>MmUnloadedDrivers</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1># MmUnloadedDrivers</h1><br />• <a href="https://github.com/dx9hk/MmUnloadedDrivers">https://github.com/dx9hk/MmUnloadedDrivers</a> - Source which walks loaded module list. Doesn&#39;t need this driver&#39;s DriverObject, just any<br />• <a href="https://github.com/vectless/kernelmode-driver/blob/0ab324dd7dcf519697472cb56a5c23f0602abc6e/kernelmode/clear.cpp#L283">https://github.com/vectless/kernelmode-driver/blob/0ab324dd7dcf519697472cb56a5c23f0602abc6e/kernelmode/clear.cpp#L283</a> - Source (a janky one at that)<br />• <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/231400-clearing-mmunloadeddrivers-mmlastunloadeddriver.html">https://www.unknowncheats.me/forum/anti-cheat-bypass/231400-clearing-mmunloadeddrivers-mmlastunloadeddriver.html</a> - Useful thread<br />• <a href="https://github.com/BadPlayer555/TraceCleaner">https://github.com/BadPlayer555/TraceCleaner</a> - Source<br />• <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/302508-deleting-entry-mmunloadeddrivers-cleaning.html">https://www.unknowncheats.me/forum/anti-cheat-bypass/302508-deleting-entry-mmunloadeddrivers-cleaning.html</a> - More comprehensive full example. Should look at this really.<br /><br />MmUnloadedDrivers stores a list of unloaded drivers.<br />MiRememberUnloadedDriver is the function which remembers drivers.<br /><br />This list of unloaded drivers can be a detection mechanism which reveals your driver&#39;s existence.<br /><a href=""><img src="images/1831-1.png" alt="images/1831-1.png" /></a><br /><br />Because of how <code>MiRememberUnloadedDriver</code> is written,<br />your driver won&#39;t be added to the list if the driver name&#39;s length is 0.<br />• <a href="https://www.unknowncheats.me/forum/2210153-post35.html">https://www.unknowncheats.me/forum/2210153-post35.html</a><br />• <a href="https://github.com/scdeny/os-design/blob/e47d942602a0d7c56d269481d859fecf267a565a/ntos/mm/sysload.c#L2771">https://github.com/scdeny/os-design/blob/e47d942602a0d7c56d269481d859fecf267a565a/ntos/mm/sysload.c#L2771</a><br /><a href=""><img src="images/1831-2.png" alt="images/1831-2.png" /></a><br /><br /><h2>## Locating MmUnloadedDrivers struct</h2><br />The signature for MmUnloadedDrivers is <br /><code>4C 8B ? ? ? ? ? 4C 8B C9 4D 85 ? 74</code><br /><br />As of Windows 10 x64 2004, <br />a RIP relative address to the struct can be be found in MmLocatedUnloadedDriver in ntoskrnl.exe:<br /><a href=""><img src="images/1831-3.png" alt="images/1831-3.png" /></a><br /><br /><h2>## Recon Demo</h2><br /><h3>### Demo</h3><br />Installed the driver with OSR Driver Loader and ran DebugView to capture the output.<br /><a href=""><img src="images/1831-4.png" alt="images/1831-4.png" /></a><br /><br /><h3>### Code</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;ntddk.h&gt;<br />#include&nbsp;&lt;windef.h&gt;<br />#include&nbsp;&lt;ntimage.h&gt;<br /><br />#include&nbsp;&quot;nt.h&quot;<br />//#include&nbsp;&lt;ntifs.h&gt;<br /><br />#define&nbsp;Dbg(...)&nbsp;DbgPrintEx(&nbsp;DPFLTR_SYSTEM_ID,&nbsp;DPFLTR_ERROR_LEVEL,&nbsp;&quot;[recon]&nbsp;&quot;&nbsp;__VA_ARGS__&nbsp;)<br /><br />#define&nbsp;MI_UNLOADED_DRIVERS&nbsp;50<br /><br />typedef&nbsp;struct&nbsp;_UNLOADED_DRIVERS&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING&nbsp;Name;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;StartAddress;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;EndAddress;<br />&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER&nbsp;CurrentTime;<br />}&nbsp;UNLOADED_DRIVERS,&nbsp;*PUNLOADED_DRIVERS;<br /><br />//&nbsp;---------------------------------------------------------<br />//&nbsp;Util<br />//&nbsp;---------------------------------------------------------<br />PVOID&nbsp;FindModuleBase(char*&nbsp;module_name)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;module_base&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;buffer_size&nbsp;=&nbsp;8;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;info_buffer&nbsp;=&nbsp;ExAllocatePool2(POOL_FLAG_NON_PAGED,&nbsp;buffer_size,&nbsp;&#39;1luL&#39;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Enumerate&nbsp;the&nbsp;loaded&nbsp;modules&nbsp;on&nbsp;the&nbsp;system<br />&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;return_len&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;status&nbsp;=&nbsp;ZwQuerySystemInformation(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemModuleInformation,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info_buffer,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;return_len<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(status&nbsp;==&nbsp;STATUS_INFO_LENGTH_MISMATCH)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Resize&nbsp;buffer&nbsp;to&nbsp;store&nbsp;returned&nbsp;information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;try&nbsp;again<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool(info_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size&nbsp;=&nbsp;return_len;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info_buffer&nbsp;=&nbsp;ExAllocatePool2(POOL_FLAG_NON_PAGED,&nbsp;buffer_size,&nbsp;&#39;2luL&#39;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;ZwQuerySystemInformation(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SystemModuleInformation,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info_buffer,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;return_len<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!NT_SUCCESS(status))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool(info_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Loop&nbsp;through&nbsp;modules&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;PRTL_PROCESS_MODULES&nbsp;modules&nbsp;=&nbsp;(PRTL_PROCESS_MODULES)info_buffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(ULONG&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;modules-&gt;NumberOfModules;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;name&nbsp;=&nbsp;(char*)modules-&gt;Modules[i].FullPathName&nbsp;+&nbsp;modules-&gt;Modules[i].OffsetToFileName;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(name,&nbsp;module_name)&nbsp;==&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&#39;ve&nbsp;found&nbsp;the&nbsp;desired&nbsp;module,&nbsp;save&nbsp;its&nbsp;base&nbsp;address<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module_base&nbsp;=&nbsp;modules-&gt;Modules[i].ImageBase;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool(info_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;module_base;<br />}<br /><br />BOOL&nbsp;CheckMask(PCHAR&nbsp;base,&nbsp;PCHAR&nbsp;pattern,&nbsp;PCHAR&nbsp;mask)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*mask&nbsp;!=&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*mask&nbsp;==&nbsp;&#39;x&#39;&nbsp;&amp;&amp;&nbsp;*base&nbsp;!=&nbsp;*pattern)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++base;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++pattern;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++mask;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br />}<br /><br />PVOID&nbsp;FindPattern(PCHAR&nbsp;base,&nbsp;DWORD&nbsp;length,&nbsp;PCHAR&nbsp;pattern,&nbsp;PCHAR&nbsp;mask)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;-=&nbsp;(DWORD)strlen(mask);<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;length;&nbsp;++i)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;addr&nbsp;=&nbsp;&amp;base[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(CheckMask(addr,&nbsp;pattern,&nbsp;mask)&nbsp;==&nbsp;TRUE)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;addr;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br />}<br /><br />PVOID&nbsp;FindPatternInModule(PCHAR&nbsp;module_base,&nbsp;PCHAR&nbsp;pattern,&nbsp;PCHAR&nbsp;mask)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pattern_addr&nbsp;=&nbsp;NULL;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Grab&nbsp;sections&nbsp;in&nbsp;module&nbsp;and&nbsp;loop&nbsp;through<br />&nbsp;&nbsp;&nbsp;&nbsp;PIMAGE_NT_HEADERS&nbsp;nt_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)(module_base&nbsp;+&nbsp;((PIMAGE_DOS_HEADER)module_base)-&gt;e_lfanew);<br />&nbsp;&nbsp;&nbsp;&nbsp;PIMAGE_SECTION_HEADER&nbsp;section&nbsp;=&nbsp;IMAGE_FIRST_SECTION(nt_header);<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nt_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*(PINT)section-&gt;Name&nbsp;==&nbsp;&#39;EGAP&#39;&nbsp;||&nbsp;memcmp(section-&gt;Name,&nbsp;&quot;.text&quot;,&nbsp;5)&nbsp;==&nbsp;0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&#39;ve&nbsp;found&nbsp;the&nbsp;.text&nbsp;section,&nbsp;search&nbsp;for&nbsp;our&nbsp;pattern<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern_addr&nbsp;=&nbsp;FindPattern(module_base&nbsp;+&nbsp;section-&gt;VirtualAddress,&nbsp;section-&gt;Misc.VirtualSize,&nbsp;pattern,&nbsp;mask);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pattern_addr&nbsp;!=&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;section<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;section&nbsp;+=&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pattern_addr;<br />}<br /><br />/*<br />A&nbsp;RIP&nbsp;relative&nbsp;address&nbsp;is&nbsp;@&nbsp;RIP&nbsp;+&nbsp;relative_address.<br />RIP&nbsp;points&nbsp;to&nbsp;the&nbsp;next&nbsp;instruction,&nbsp;so&nbsp;do<br />current_address&nbsp;+&nbsp;current_instruction_size&nbsp;to&nbsp;find&nbsp;RIP,&nbsp;and&nbsp;then&nbsp;add&nbsp;the&nbsp;relative&nbsp;address.<br /><br />Params:<br />&nbsp;&nbsp;&nbsp;&nbsp;base_addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Start&nbsp;of&nbsp;the&nbsp;instruction&nbsp;in&nbsp;which&nbsp;the&nbsp;relative&nbsp;address&nbsp;is<br />&nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Offset&nbsp;to&nbsp;the&nbsp;relative&nbsp;address&nbsp;from&nbsp;the&nbsp;base_addr<br />&nbsp;&nbsp;&nbsp;&nbsp;instruction_size&nbsp;-&nbsp;Size&nbsp;of&nbsp;the&nbsp;instruction&nbsp;@&nbsp;base_addr.&nbsp;Grab&nbsp;with&nbsp;IDA/x64dbg/etc.<br />*/<br />PVOID&nbsp;ResolveRelativeAddress(DWORD64&nbsp;base_addr,&nbsp;int&nbsp;offset,&nbsp;int&nbsp;instruction_size)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD64&nbsp;rip&nbsp;=&nbsp;base_addr&nbsp;+&nbsp;instruction_size;<br />&nbsp;&nbsp;&nbsp;&nbsp;DWORD32&nbsp;relative_addr&nbsp;=&nbsp;*(PDWORD32)(base_addr&nbsp;+&nbsp;offset);<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;absolute_addr&nbsp;=&nbsp;(PVOID)(rip&nbsp;+&nbsp;relative_addr);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;absolute_addr;<br />}<br /><br />//&nbsp;---------------------------------------------------------<br />//&nbsp;Main<br />//&nbsp;---------------------------------------------------------<br />void&nbsp;DriverUnload(PDRIVER_OBJECT&nbsp;DriverObject)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Nothing&nbsp;to&nbsp;delete<br />&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER(DriverObject);<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;Unloaded&nbsp;driver&nbsp;\n&quot;);<br />}<br /><br />NTSTATUS&nbsp;DriverEntry(PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER(RegistryPath);<br />&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;status&nbsp;=&nbsp;STATUS_SUCCESS;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Not&nbsp;creating&nbsp;an&nbsp;io&nbsp;device&nbsp;and&nbsp;symbolic&nbsp;link<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;because&nbsp;don&#39;t&nbsp;need&nbsp;to&nbsp;access&nbsp;from&nbsp;userland<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Set&nbsp;callback&nbsp;functions<br />&nbsp;&nbsp;&nbsp;&nbsp;DriverObject-&gt;DriverUnload&nbsp;=&nbsp;DriverUnload;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;There&#39;s&nbsp;a&nbsp;relative&nbsp;address&nbsp;to&nbsp;MmUnloadeDrivers&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;at&nbsp;the&nbsp;start&nbsp;of&nbsp;MmLocateUnloadedDriver()&nbsp;func<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;ntoskrnl_base&nbsp;=&nbsp;FindModuleBase(&quot;ntoskrnl.exe&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;ntoskrnl.exe&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ntoskrnl_base);<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;MmLocateUnloadedDriver_addr&nbsp;=&nbsp;FindPatternInModule(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ntoskrnl_base,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\x4C\x8B\x00\x00\x00\x00\x00\x4C\x8B\xC9\x4D\x85\x00\x74&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;xx?????xxxxx?x&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//PVOID&nbsp;MmUnloadedDrivers_addr&nbsp;=&nbsp;(PVOID)((DWORD64)ntoskrnl_base&nbsp;+&nbsp;0xC2A658);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;For&nbsp;Windows&nbsp;10&nbsp;x64&nbsp;20H2&nbsp;19042.1052&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;MmUnloadedDrivers_addr&nbsp;=&nbsp;ResolveRelativeAddress((DWORD64)MmLocateUnloadedDriver_addr,&nbsp;3,&nbsp;7);<br />&nbsp;&nbsp;&nbsp;&nbsp;PUNLOADED_DRIVERS&nbsp;MmUnloadedDrivers&nbsp;=&nbsp;*(PUNLOADED_DRIVERS*)MmUnloadedDrivers_addr;<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(MmUnloadedDrivers&nbsp;==&nbsp;NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0x0;<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;MmUnloadedDrivers&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;MmUnloadedDrivers_addr);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Loop&nbsp;through&nbsp;list&nbsp;and&nbsp;print<br />&nbsp;&nbsp;&nbsp;&nbsp;PUNLOADED_DRIVERS&nbsp;driver&nbsp;=&nbsp;NULL;<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MI_UNLOADED_DRIVERS;&nbsp;i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver&nbsp;=&nbsp;&amp;MmUnloadedDrivers[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;[MmUnloadedDrivers]&nbsp;%d&nbsp;[len]&nbsp;%d&nbsp;[name]&nbsp;%wZ&nbsp;\n&quot;,&nbsp;i,&nbsp;driver-&gt;Name.Length,&nbsp;driver-&gt;Name);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;status;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><h2>## Evasion Demo</h2><br /><h3>### Demo</h3><br />I first run load my evasion driver and unload it. <br />You can see that it dodges the MmUnloadedDrivers list on unload.<br /><a href=""><img src="images/1831-5.png" alt="images/1831-5.png" /></a><br /><br />I then run my recon driver from above to list unloaded drivers.<br />It evasion was unsuccessful, my evasion driver will appear in the list.<br />As you can see, it doesn&#39;t.<br /><a href=""><img src="images/1831-6.png" alt="images/1831-6.png" /></a><br /><br /><h3>### Code</h3><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;ntddk.h&gt;<br />#include&nbsp;&lt;windef.h&gt;<br />#include&nbsp;&lt;ntimage.h&gt;<br /><br />#define&nbsp;Dbg(...)&nbsp;DbgPrintEx(&nbsp;DPFLTR_SYSTEM_ID,&nbsp;DPFLTR_ERROR_LEVEL,&nbsp;&quot;[dodge]&nbsp;&quot;&nbsp;__VA_ARGS__&nbsp;)<br /><br />typedef&nbsp;struct&nbsp;_KLDR_DATA_TABLE_ENTRY&nbsp;{<br />	LIST_ENTRY&nbsp;InLoadOrderLinks;<br />	PVOID&nbsp;ExceptionTable;<br />	ULONG&nbsp;ExceptionTableSize;<br />	PVOID&nbsp;GpValue;<br />	PVOID&nbsp;NonPagedDebugInfo;<br />	PVOID&nbsp;DllBase;<br />	PVOID&nbsp;EntryPoint;<br />	ULONG&nbsp;SizeOfImage;<br />	UNICODE_STRING&nbsp;FullDllName;<br />	UNICODE_STRING&nbsp;BaseDllName;<br />	ULONG&nbsp;Flags;<br />	USHORT&nbsp;LoadCount;<br />	USHORT&nbsp;__Unused;<br />	PVOID&nbsp;SectionPointer;<br />	ULONG&nbsp;CheckSum;<br />	PVOID&nbsp;LoadedImports;<br />	PVOID&nbsp;PatchInformation;<br />}&nbsp;KLDR_DATA_TABLE_ENTRY,&nbsp;*&nbsp;PKLDR_DATA_TABLE_ENTRY;<br /><br />/*<br />By&nbsp;setting&nbsp;your&nbsp;driver&nbsp;name&#39;s&nbsp;length&nbsp;to&nbsp;0,&nbsp;<br />MmRememberUnloadedDriver&nbsp;won&#39;t&nbsp;add&nbsp;your&nbsp;driver&nbsp;into&nbsp;the&nbsp;MmUnloadedDrivers&nbsp;list.<br />https://github.com/scdeny/os-design/blob/e47d942602a0d7c56d269481d859fecf267a565a/ntos/mm/sysload.c#L2771<br /><br />Call&nbsp;this&nbsp;function&nbsp;in&nbsp;your&nbsp;unload&nbsp;routine.<br />*/<br />void&nbsp;DodgeMmUnloadedDrivers(PKLDR_DATA_TABLE_ENTRY&nbsp;DriverSection)<br />{<br />	/*<br />	The&nbsp;only&nbsp;necessary&nbsp;part&nbsp;is&nbsp;`DriverSection-&gt;BaseDllName.Length&nbsp;=&nbsp;0;`<br />	but&nbsp;emptying&nbsp;the&nbsp;name&nbsp;and&nbsp;setting&nbsp;the&nbsp;max&nbsp;length&nbsp;is&nbsp;no&nbsp;extra&nbsp;hassle.<br />	*/<br />	Dbg(&quot;*&nbsp;Dodging&nbsp;MmUnloadedDrivers&nbsp;list&nbsp;for:&nbsp;%wZ&nbsp;\n&quot;,&nbsp;DriverSection-&gt;BaseDllName);<br />	RtlZeroMemory(DriverSection-&gt;BaseDllName.Buffer,&nbsp;DriverSection-&gt;BaseDllName.Length);<br />&nbsp;&nbsp;&nbsp;&nbsp;DriverSection-&gt;BaseDllName.Length&nbsp;=&nbsp;0;<br />	DriverSection-&gt;BaseDllName.MaximumLength&nbsp;=&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />void&nbsp;DriverUnload(PDRIVER_OBJECT&nbsp;DriverObject)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;DodgeMmUnloadedDrivers(DriverObject-&gt;DriverSection);<br />&nbsp;&nbsp;&nbsp;&nbsp;Dbg(&quot;*&nbsp;Unloaded&nbsp;driver&nbsp;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br />}<br /><br />NTSTATUS&nbsp;DriverEntry(PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER(RegistryPath);<br />&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;status&nbsp;=&nbsp;STATUS_SUCCESS;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Not&nbsp;creating&nbsp;an&nbsp;io&nbsp;device&nbsp;and&nbsp;symbolic&nbsp;link<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;because&nbsp;don&#39;t&nbsp;need&nbsp;to&nbsp;access&nbsp;from&nbsp;userland<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Set&nbsp;callback&nbsp;functions<br />&nbsp;&nbsp;&nbsp;&nbsp;DriverObject-&gt;DriverUnload&nbsp;=&nbsp;DriverUnload;<br /><br />	Dbg(&quot;+&nbsp;Loaded&nbsp;driver!&nbsp;\n&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;status;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
