<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Registers</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x86 Registers</h1></strong><br />Processor registers are small sections of data storage that sit close to the CPU.<br />Their contents can be accessed more quickly than RAM or cache, so are useful during arithmetic operations as temporary data storage.<br /><br />On a 32bit processor, the main registers are 32bits in size.<br /><br />On x86, registers can divided into 4 categories:<br />• <em>General registers</em> - used by the CPU during exeuction<br />• <em>Segment registers</em>  - used to track sections of memory<br />• <em>Status register</em> - used to make decisions<br />• <em>Instruction pointers</em> - keep track of the next instruction to execute (just EIP)<br /><br />Here&#39;s a table of all the x86 registers:<br /><a href=""><img src="images/567-1.png" alt="images/567-1.png" /></a><br /><br />And here is how the registers look in a OllyDbg:<br /><a href=""><img src="images/567-2.png" alt="images/567-2.png" /></a><br /><br /><strong><h2>## General Purpose Registers</h2></strong><br />On a 32bit x86 processor there are 9 general registers.<br />The E stands for Extended.<br /><br />• <code>EAX</code> - Accumulator Register - used for arithmetic operations<br />• <code>EBX</code> - Base Register - used as a pointer to data<br />• <code>ECX</code> - Counter Register - used in shift/rotate instructions &amp; loops<br />• <code>EDX</code> - Data Register - used in arithmetic and I/O operations<br />• <code>ESI</code> - Source Index - used as a pointer to a source in stream operations<br />• <code>EDI</code> - Destination Index - used as a pointer to a destination in stream operations<br />• <code>EBP</code> - Stack Base Pointer - points to the base of the stack<br />• <code>ESP</code> - Stack Pointer - points to the top of the stack<br />• <code>EIP</code> - Instruction Pointer - points to the next instruction to execute<br /><br /><a href=""><img src="images/567-3.png" alt="images/567-3.png" /></a><br /><br />General registers store data or memory addresses.<br />All general registers are 32 bits in size (or 4 bytes). They can hold data from 0x0 to 0xFFFFFFFF.<br /><br />Originally, registers were for specific things (as mentioned above).<br />Nowadays they&#39;re all used interchangeably, except for<em><strong> </strong></em><code>EBP</code>, <code>ESP</code> and <code>EIP</code>.<br /><br /><code>EBP</code> points to the base of the stack.<br /><code>ESP</code> points to the top of the stack.<br />And <code>EIP</code> points to the next instruction to be executed.<br /><br /><strong><h3>### EIP - The instruction pointer</h3></strong><br />The EIP is the instruction pointer register, and contains the address of the next instruction to execute.<br />Its only purpose is to tell the processor what to do next.<br /><br />If you control EIP, you control what the CPU executes.<br />This means as an attacker you will want to gain control of the EIP.<br /><br />In a buffer overflow attack,<br />an attacker will write attack code (shellcode) into memory, take control of EIP, and then modify the address of EIP to point to their attack code in memory. At this point they have succesfully taken control of the system, and their attack code is running.<br /><br /><strong><h3>### EAX, EBX, ECX, and EDX - Accessing their lower bits</h3></strong><br />For the first 4 registers - EAX, EBX, ECX and EDX - you can also reference the 8bit and 16bit portions of their register.<br /><br />• <code>EAX</code> is the whole 32bit register<br />• <code>AX</code> is the 16bit portion of the register <br />• <code>AH</code> (higher) is the higher 8 bits of the 16bit AX register<br />• <code>AL</code> (lower) is the lower 8 bits of the 16bit AX register<br /><br /><a href=""><img src="images/567-4.png" alt="images/567-4.png" /></a><br />    <br />For example, EAX contains the value <code>0xA9DC81F5</code>.<br />When programming you could reference:<br />• <code>EAX</code> (4 bytes) - <code>0xA9DC81F5</code><br />• <code>AX</code> (2 bytes) -  <code>0x81F5</code><br />• <code>AH</code> (1 byte) - <code>0x81</code><br />• <code>AL</code> (1 byte) - <code>0xF5</code><br /><br /><strong><h3>### General Purpose Registers and Instructions</h3></strong><br />Some x86 instructions use specific registers by definition.<br />e.g. multiplication and division instructions always use EAX and EDX<br /><br />General registers might also be used in a consistent manner throughout a program.<br />This is called <em>convention</em>.<br /><br />For example, compilers will use certain registers in a specific way.<br />Knowledge of how different compilers use registers can help you analyse code more quickly.<br />(because you&#39;re not wasting time figuring out how a register is being used).<br /><br />For most x86 programs, <code>EAX</code> typically contains the return value of function calls.<br />If you see the EAX register used immediately after a function call, you&#39;re probably looking at the return value of that function.<br /><br /><strong><h2>## Segment Registers</h2></strong><br />Segment registers point to sections of your program in memory.<br /><br />• <code>CS</code> - Code Segment - points to the code section<br />• <code>SS</code> - Stack Segment - points to the stack section<br />• <code>DS</code> - Data Segment - points to the data section<br />• <code>ES</code> - Extra Segment - points to extra data<br />• <code>FS</code> - F Segment - points to more extra data (F comes after E)<br />• <code>GS</code> - G Segment - points to still more extra data (F comes after F)<br /><br />Nowadays, segment registers typically all point to the same place because on modern operating systems memory paging is used instead.<br />The exception to this rule are the <code>FS</code> and <code>GS</code> registers, which point to thread specific data.<br /><br /><a href=""><img src="images/567-5.png" alt="images/567-5.png" /></a><br /><br /><strong><h2>## EFLAGS / Status Register</h2></strong><br />The EFLAGS / Status register is a 32bit register that&#39;s used as a collection of boolean value bits to the store statuses for the processor.<br /><br /><a href=""><img src="images/567-6.png" alt="images/567-6.png" /></a><br /><br /><strong><h3>### Useful flags</h3></strong><br />Some of the more useful flags are detailed here.<br /><br /><strong><code>ZF</code></strong><strong> - Zero Flag</strong><br />• Set if the result an arithmetic operation is equal to 0<br /><br /><strong><code>CF</code></strong><strong> - Carry Flag</strong><br />• Set when the result of an operation is too large or too small exceeds the maximum bits to be contained in a register<br /><br /><strong><code>OF</code></strong><strong> - Overflow Flag</strong><br />• Set when signed arithmetic operations result in a value too large for the register to contain<br /><br /><strong><code>SF</code></strong><strong> - Sign Flag</strong><br />• Set if the result of an operation is negative<br /><br /><strong><code>TF</code></strong><strong> - Trap Flag</strong><br />• Set if step by step debugging is enabled (execute 1 instruction at a time)<br /></div>
</body>
</html>
