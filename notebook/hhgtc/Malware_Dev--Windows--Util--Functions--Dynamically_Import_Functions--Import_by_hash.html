<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Import by hash</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Import by hash</h1></strong><br />• Example with lots of ASM (don&#39;t understand end of CallAPI function)<br />   ◇ uses hashes of functions instead of encrypted strings<br />   ◇ <a href="https://github.com/aeshes/exe_crypter/blob/master/stub/noimport.c">https://github.com/aeshes/exe_crypter/blob/master/stub/noimport.c</a><br />• <a href="https://github.com/LloydLabs/Windows-API-Hashing">https://github.com/LloydLabs/Windows-API-Hashing</a><br />   ◇ Can obviously write &amp; understands code but code written isn&#39;t very clear imo<br /><br />A popular technique so that the strings of the functions you&#39;re dynamically importing - &quot;MessageBoxA&quot;, &quot;Beep&quot;, &quot;NtUnmapViewOfSection&quot; - don&#39;t appear in your compiled binary (which defeats your efforts to hide your imports) is to import by hash.<br /><br />i.e. <br />You store a hashed version of the function name in your code:<br /><code>1310994705l</code> instead of <code>Beep</code><br /><br />And then, when you walk the exports of a DLL, you hash the name of the export you&#39;re inspecting.<br />If the hashed export matches the hashed function name you want to import, you&#39;ve found your function.<br />e.g. <br />• You&#39;re walking <code>Kernel32.dll</code><br />• You&#39;ve hashed one its exports. It&#39;s <code>1310994705l</code><br />• You want to import <code>Beep</code>. Your hashed version of &quot;Beep&quot; is <code>1310994705l</code><br />Congrats. You&#39;ve found <code>Beep</code><br /><br />The key part of the code is this:<br /><div class="codebox"><div class="codebox">if&nbsp;(hash(function_name)&nbsp;==&nbsp;hashed_requested_function)<br />	<span style="color:#000000;font-weight:400">{</span><br />		function_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_functions[export_dir_ordinals[i]]);<br />		break;<br />	<span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />//&nbsp;hashed&nbsp;functions<br />#define&nbsp;hashed_Beep&nbsp;1310994705l<br /><br />//&nbsp;function&nbsp;typedefs<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_Beep)(DWORD&nbsp;dwFreq,&nbsp;DWORD&nbsp;dwDuration);<br /><br />/*<br />djb2&nbsp;hash&nbsp;algorithm&nbsp;by&nbsp;Dan&nbsp;Bernstein.<br />Hash&nbsp;length&nbsp;is&nbsp;longer&nbsp;for&nbsp;longer&nbsp;strings.<br />*/<br />ULONG&nbsp;hash(char*&nbsp;str)<br />{<br />	ULONG&nbsp;hash&nbsp;=&nbsp;4725;		//&nbsp;original&nbsp;from&nbsp;djb2&nbsp;code&nbsp;is&nbsp;5381<br />	int&nbsp;c;<br /><br />	while&nbsp;(c&nbsp;=&nbsp;*str++)<br />		hash&nbsp;=&nbsp;((hash&nbsp;&lt;&lt;&nbsp;5)&nbsp;+&nbsp;hash)&nbsp;+&nbsp;c;		//&nbsp;hash&nbsp;*&nbsp;33&nbsp;+&nbsp;c<br /><br />	return&nbsp;hash;<br />}<br /><br />/*<br />Grabs&nbsp;PEB,<br />grabs&nbsp;PED_LDR_DATA&nbsp;from&nbsp;PEB&nbsp;to&nbsp;get&nbsp;info&nbsp;about&nbsp;loaded&nbsp;DLLs,<br />and&nbsp;loops&nbsp;through&nbsp;the&nbsp;loaded&nbsp;DLLs&nbsp;to&nbsp;find&nbsp;the&nbsp;DLL&nbsp;we&nbsp;want&nbsp;and&nbsp;grabs&nbsp;its&nbsp;base&nbsp;address.<br /><br />Be&nbsp;careful.&nbsp;The&nbsp;DLL&nbsp;name&nbsp;has&nbsp;to&nbsp;be&nbsp;exact&nbsp;(could&nbsp;use&nbsp;something&nbsp;else&nbsp;than&nbsp;strcmp&nbsp;tbf)<br />e.g:&nbsp;&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;&nbsp;vs&nbsp;&quot;C:\\WINDOWS\\System32\\KERNEL32.DLL&quot;<br /><br />Return:<br />NULL&nbsp;on&nbsp;error.<br />*/<br />LPVOID&nbsp;FindLoadedDLLBaseAddress(const&nbsp;wchar_t*&nbsp;dll_name)<br />{<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_list&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_entry&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;dll_base&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;PEB<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br /><br />	//&nbsp;grab&nbsp;list&nbsp;of&nbsp;loaded&nbsp;DLLs<br />	dll_list&nbsp;=&nbsp;(PLIST_ENTRY)&amp;p_peb-&gt;Ldr-&gt;InMemoryOrderModuleList;<br />	//&nbsp;grab&nbsp;first&nbsp;DLL&nbsp;in&nbsp;list&nbsp;of&nbsp;DLLs<br />	dll_entry&nbsp;=&nbsp;dll_list-&gt;Flink;<br /><br />	printf(&quot;peb&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_peb);<br />	printf(&quot;dll&nbsp;list&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_list);<br />	printf(&quot;dll&nbsp;entry&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_entry);<br /><br />	printf(&quot;[*]&nbsp;looping&nbsp;through&nbsp;loaded&nbsp;DLLs...&nbsp;\n&quot;);<br />	//&nbsp;loop&nbsp;through&nbsp;loaded&nbsp;DLLs<br />	while&nbsp;(dll_list&nbsp;!=&nbsp;dll_entry)<br />	{<br />		//&nbsp;grab&nbsp;DLL<br />		PLDR_DATA_TABLE_ENTRY&nbsp;module&nbsp;=&nbsp;CONTAINING_RECORD(dll_entry,&nbsp;LDR_DATA_TABLE_ENTRY,&nbsp;InMemoryOrderLinks);<br /><br />		printf(&quot;\t&nbsp;%ws&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;module-&gt;FullDllName.Buffer,&nbsp;module-&gt;DllBase);<br /><br />		//&nbsp;if&nbsp;DLL&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />		if&nbsp;(wcscmp(dll_name,&nbsp;module-&gt;FullDllName.Buffer)&nbsp;==&nbsp;0)<br />		{<br />			dll_base&nbsp;=&nbsp;module-&gt;DllBase;<br />			break;<br />		}<br /><br />		//&nbsp;increment&nbsp;to&nbsp;next&nbsp;DLL<br />		dll_entry&nbsp;=&nbsp;dll_entry-&gt;Flink;<br />	}<br /><br />	return&nbsp;dll_base;<br />}<br /><br />/*<br />Find&nbsp;the&nbsp;address&nbsp;of&nbsp;an&nbsp;exported&nbsp;function&nbsp;from&nbsp;a&nbsp;DLL.<br />Only&nbsp;tested&nbsp;with&nbsp;a&nbsp;DLL&nbsp;already&nbsp;loaded&nbsp;in&nbsp;memory.<br />*/<br />LPVOID&nbsp;FindExportedDLLFunctionAddress(LPVOID&nbsp;dll_base_address,&nbsp;ULONG&nbsp;hashed_requested_function)<br />{<br />	LPVOID&nbsp;function_address&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_directory&nbsp;=&nbsp;NULL;<br /><br />	DWORD*&nbsp;export_dir_names&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;export_dir_ordinals&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_dir_functions&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;export&nbsp;directory&nbsp;from&nbsp;DLL<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_base_address;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	export_directory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br /><br />	printf(&quot;\t&nbsp;exports&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;export_directory);<br /><br />	export_dir_names&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNames);<br />	export_dir_ordinals&nbsp;=&nbsp;(WORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNameOrdinals);<br />	export_dir_functions&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfFunctions);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;exports<br />	//&nbsp;if&nbsp;requested&nbsp;function&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;export_directory-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		//&nbsp;grab&nbsp;function&nbsp;name<br />		char*&nbsp;function_name&nbsp;=&nbsp;(char*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_names[i]);<br />		printf(&quot;\t\t&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />		//&nbsp;compare&nbsp;hashed&nbsp;function&nbsp;name&nbsp;to&nbsp;hashed&nbsp;requested&nbsp;function.&nbsp;if&nbsp;correct,&nbsp;save&nbsp;address&nbsp;and&nbsp;exit<br />		if&nbsp;(hash(function_name)&nbsp;==&nbsp;hashed_requested_function)<br />		{<br />			function_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_functions[export_dir_ordinals[i]]);<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;function_address;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	LPVOID&nbsp;kernel32_base_address&nbsp;=&nbsp;NULL;<br /><br />	kernel32_base_address&nbsp;=&nbsp;FindLoadedDLLBaseAddress(L&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;);<br />	t_Beep&nbsp;d_Beep&nbsp;=&nbsp;(t_Beep)FindExportedDLLFunctionAddress(kernel32_base_address,&nbsp;hashed_Beep);<br /><br />	d_Beep(1000,&nbsp;2000);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
