<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>MSDN Client Example - receive data until server closes connection</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'>I wrote this to learn Winsock.<br />I followed the MSDN documentation here:<br /><a href="https://docs.microsoft.com/en-us/windows/win32/winsock/creating-a-basic-winsock-application">https://docs.microsoft.com/en-us/windows/win32/winsock/creating-a-basic-winsock-application</a><br /><br />Actual MSDN example here:<br /><a href="https://docs.microsoft.com/en-us/windows/win32/winsock/complete-client-code">https://docs.microsoft.com/en-us/windows/win32/winsock/complete-client-code</a><br /><br />IMO the problem with this, like on Unix, is that you can skip the <code>GetAddrInfo</code> function and just create a <code>struct sockaddr_in remoteHost;</code> containing the IP, port, etc. of the server you want to connect to. Much easier in my opinion.<br /><br />BUT, this is a good example of MSDN documented way of connecting to a server.<br /><div class="codebox"><div class="codebox">/*<br />Connect&nbsp;to&nbsp;a&nbsp;server,&nbsp;send&nbsp;a&nbsp;&quot;hey&nbsp;smile&nbsp;:)&quot;,&nbsp;and&nbsp;receive&nbsp;data&nbsp;until&nbsp;the&nbsp;server&nbsp;closes&nbsp;the&nbsp;connection.<br />Written&nbsp;following&nbsp;MSDN&nbsp;to&nbsp;learn&nbsp;about&nbsp;Winsock.<br />Start&nbsp;here:<br />https://docs.microsoft.com/en-us/windows/win32/winsock/creating-a-basic-winsock-application<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;WinSock2.h&gt;<br />#include&nbsp;&lt;WS2tcpip.h&gt;		//&nbsp;newer&nbsp;functions/structs&nbsp;to&nbsp;retrieve&nbsp;IP&nbsp;addresses<br /><br />#pragma&nbsp;comment(lib,&nbsp;&quot;Ws2_32.lib&quot;)<br /><br />#define&nbsp;RECV_LEN&nbsp;1024<br /><br />int&nbsp;wmain(int&nbsp;argc,&nbsp;wchar_t*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;initialise&nbsp;Winsock<br />	printf(&quot;[*]&nbsp;initialising&nbsp;winsock&nbsp;\n&quot;);<br />	WSADATA&nbsp;wsaData;<br />	if&nbsp;(WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;wsaData)&nbsp;!=&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;initialise&nbsp;winsock&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;get&nbsp;remote&nbsp;address&nbsp;info<br />	printf(&quot;[*]&nbsp;querying&nbsp;server&nbsp;for&nbsp;info&nbsp;\n&quot;);<br />	struct&nbsp;addrinfoW&nbsp;hints;					//&nbsp;stores&nbsp;info&nbsp;about&nbsp;type&nbsp;of&nbsp;socket&nbsp;caller&nbsp;supports<br />	struct&nbsp;addrinfoW&nbsp;*remoteHost;			//&nbsp;contains&nbsp;info&nbsp;about&nbsp;remoote&nbsp;host&nbsp;received&nbsp;from&nbsp;GetAddrInfoW<br />	ZeroMemory(&amp;hints,&nbsp;sizeof(hints));<br /><br />	hints.ai_family&nbsp;=&nbsp;AF_INET;				//&nbsp;ipv4<br />	hints.ai_socktype&nbsp;=&nbsp;SOCK_STREAM;		//&nbsp;TCP<br />	hints.ai_protocol&nbsp;=&nbsp;IPPROTO_TCP;		//&nbsp;TCP&nbsp;protocol<br /><br />	wchar_t&nbsp;serverIP[]&nbsp;=&nbsp;L&quot;192.168.58.142&quot;;<br />	wchar_t&nbsp;serverPort[]&nbsp;=&nbsp;L&quot;443&quot;;<br />	if&nbsp;(GetAddrInfoW(serverIP,&nbsp;serverPort,&nbsp;&amp;hints,&nbsp;&amp;remoteHost)&nbsp;!=&nbsp;0)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;retrieve&nbsp;remote&nbsp;server&nbsp;info:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;create&nbsp;socket<br />	printf(&quot;[*]&nbsp;creating&nbsp;socket&nbsp;\n&quot;);<br />	SOCKET&nbsp;muhSocket&nbsp;=&nbsp;socket(remoteHost-&gt;ai_family,&nbsp;remoteHost-&gt;ai_socktype,&nbsp;remoteHost-&gt;ai_protocol);<br />	if&nbsp;(muhSocket&nbsp;==&nbsp;INVALID_SOCKET)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;create&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		FreeAddrInfoW(remoteHost);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;connect&nbsp;to&nbsp;server<br />	printf(&quot;[*]&nbsp;connecting&nbsp;to&nbsp;server&nbsp;\n&quot;);<br />	if&nbsp;(connect(muhSocket,&nbsp;remoteHost-&gt;ai_addr,&nbsp;remoteHost-&gt;ai_addrlen)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;unable&nbsp;to&nbsp;connect&nbsp;to&nbsp;server:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		FreeAddrInfoW(remoteHost);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;send&nbsp;data<br />	printf(&quot;[*]&nbsp;sending&nbsp;message&nbsp;to&nbsp;server&nbsp;\n&quot;);<br />	const&nbsp;char&nbsp;*msg&nbsp;=&nbsp;&quot;hey&nbsp;smile&nbsp;:)&nbsp;\n&quot;;<br />	if&nbsp;(send(muhSocket,&nbsp;msg,&nbsp;strlen(msg),&nbsp;0)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;send&nbsp;data:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		FreeAddrInfoW(remoteHost);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br />	//&nbsp;shutdown&nbsp;connection&nbsp;for&nbsp;sending&nbsp;data<br />	if&nbsp;(shutdown(muhSocket,&nbsp;SD_SEND)&nbsp;==&nbsp;SOCKET_ERROR)<br />	{<br />		fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;shutdown&nbsp;socket:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />		closesocket(muhSocket);<br />		FreeAddrInfoW(remoteHost);<br />		WSACleanup();<br />		return&nbsp;1;<br />	}<br /><br /><br />	//&nbsp;receive&nbsp;data<br />	printf(&quot;[*]&nbsp;receiving&nbsp;data...&nbsp;\n&quot;);<br />	char&nbsp;recv_buf[RECV_LEN];			//&nbsp;store&nbsp;received&nbsp;data&nbsp;(if&nbsp;more&nbsp;than&nbsp;1024&nbsp;bytes&nbsp;received,&nbsp;weird&nbsp;stuff&nbsp;will&nbsp;happen)<br />	int&nbsp;recv_len;						//&nbsp;store&nbsp;number&nbsp;of&nbsp;bytes&nbsp;received<br />	do&nbsp;<br />	{<br />		recv_len&nbsp;=&nbsp;recv(muhSocket,&nbsp;recv_buf,&nbsp;RECV_LEN,&nbsp;0);<br />		if&nbsp;(recv_len&nbsp;&gt;&nbsp;0)<br />		{<br />			//printf(&quot;bytes&nbsp;received:&nbsp;%d&nbsp;\n&quot;,&nbsp;recv_len);<br />			//&nbsp;without&nbsp;printing&nbsp;N&nbsp;numbers&nbsp;of&nbsp;received&nbsp;data,&nbsp;it&nbsp;will&nbsp;print&nbsp;received&nbsp;data&nbsp;+&nbsp;junk&nbsp;to&nbsp;reach&nbsp;RECV_LEN<br />			printf(&quot;%.*s&quot;,&nbsp;recv_len,&nbsp;recv_buf);<br />		}<br />		else&nbsp;if(recv_len&nbsp;==&nbsp;0)<br />		{<br />			printf(&quot;[!]&nbsp;connection&nbsp;closed&nbsp;by&nbsp;server&nbsp;\n&quot;);<br />		}<br />		else<br />		{<br />			fprintf(stderr,&nbsp;&quot;[error]&nbsp;failed&nbsp;to&nbsp;receive&nbsp;datas:&nbsp;%d&nbsp;\n&quot;,&nbsp;WSAGetLastError());<br />			closesocket(muhSocket);<br />			FreeAddrInfoW(remoteHost);<br />			WSACleanup();<br />			return&nbsp;1;<br />		}<br />	}&nbsp;while&nbsp;(recv_len&nbsp;&gt;&nbsp;0);<br /><br />	//&nbsp;clean&nbsp;up&nbsp;&amp;&nbsp;exit<br />	printf(&quot;[*]&nbsp;cleaning&nbsp;up&nbsp;\n&quot;);<br />	closesocket(muhSocket);<br />	FreeAddrInfoW(remoteHost);<br />	WSACleanup();<br /><br />	printf(&quot;[*]&nbsp;exiting&nbsp;\n&quot;);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
