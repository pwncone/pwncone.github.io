<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Disassemblers</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Disassemblers</h1></strong><br />• BeaEngine<br />• Udis - <a href="http://udis86.sourceforge.net/">http://udis86.sourceforge.net/</a><br />• Capstone<br />• HDE (hacker disassembler engine) - <a href="https://github.com/TsudaKageyu/minhook/tree/master/src/hde">https://github.com/TsudaKageyu/minhook/tree/master/src/hde</a><br />   ◇ Manual - <a href="http://svn.saurik.com/repos/menes/branches/mobilesubstrate-3.1/hde64c/doc/en/manual.txt">http://svn.saurik.com/repos/menes/branches/mobilesubstrate-3.1/hde64c/doc/en/manual.txt</a><br /><br />Disassemblers are used so you can analyse the instructions you&#39;re overwriting in your hooks.<br />This can help you fix relative addresses, grab the length of instructions, etc.<br /><br /><a href="http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html">http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html</a><br />&quot;we’re not only going to copy these instruction bytes, we’re also  going to replace them with 1 byte NOPs in the target function. That way  won’t wind up with any partial instructions when we install the hook  jump.<br />To make sure we steal whole instructions, we need to use a disassembly library.&quot;<br /><br /><strong><h2>## Fill leftover bytes with NOPs</h2></strong><br />The classic use-case within hooking is to use a disassembler to grab the length of the instructions <br />you&#39;re overwriting. <br />If your hook is 5 bytes long, <br />but there are 4 instructions that total 6 bytes, <br />you&#39;ll be left with junk instruction because that 1 byte that won&#39;t be overwritten.<br /><br />Here&#39;s a good example from PolyHook on CodeProject:<br /><div class="codebox"><div class="codebox">//Before&nbsp;our&nbsp;hook<br />0x50&nbsp;&nbsp;&nbsp;push&nbsp;eax<br />0xFFD0&nbsp;call&nbsp;eax<br />0x51&nbsp;&nbsp;&nbsp;push&nbsp;ecx<br />0xFFD1&nbsp;call&nbsp;ecx<br /><br />//After&nbsp;our&nbsp;hook<br />0xE9DEADBEEF&nbsp;JMP&nbsp;0xDEADBEF4<br />0xD1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;JUNK&nbsp;INSTRUCTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div><br /><br />The 0xD1 is a junk byte that will be interpretted as an instruction.<br />Using a disassembler we can grab the length of the all the instructions we need to overwrite - 6<br />subtract our hook size - 5<br />and NOP out any remaining bytes - 1 - so we don&#39;t split the instructions and leave junk code.<br /><div class="codebox"><div class="codebox">0xE9&nbsp;DE&nbsp;AD&nbsp;BE&nbsp;EF&nbsp;&nbsp;&nbsp;JMP&nbsp;0xDEADBEF4<br />0x90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOP</div></div><br /><br /><strong><h2>## Tips</h2></strong><br />If you try to disassemble a function that you have breakpoints set in, <br />stuff breaks apparently.</div>
</body>
</html>
