<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PAGE_GUARD</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># VEH Hooking - PAGE_GUARD</h1></strong><br /><code>PAGE_GUARD</code> is a memory protection constant.<br />Whenever a memory page is accessed that has the PAGE_GUARD flag set, it causes a <code>STATUS_GUARD_PAGE_VIOLATION</code>.<br /><a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants">https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants</a><br /><br />To hook a function, you can set the PAGE_GUARD flag on the memory page in which your target function resides - e.g. MessageBoxA.<br /><br />Now whenever MessageBoxA is called, it will cause a <code>STATUS_GUARD_PAGE_VIOLATION</code> error and you can use your custom error handler to handle it and pass execution to your hook code.<br /><br /><strong><h2>## The problem with memory pages</h2></strong><br />A memory page is typically 4KiB in size.<br />Therefore, the page on which you set the PAGE_GUARD flag will contain other functions and code than just your <code>MessageBoxA</code> target. As a result, you need to step through the entire memory page in order to reach the address that you want.<br /><br /><a href="https://miro.medium.com/max/640/1*jt20HwjKxzBkNEu_wEFeww.png"><img src="images/1694-1.png" alt="images/1694-1.png" /></a><br /><br />For example, pretend that <code>MessageBoxA</code> is at <code>0x08048fb7</code>.<br />The memory page starts at <code>0x08048f93</code>.<br />Therfore, when the <code>STATUS_GUARD_PAGE_VIOLATION</code> error occurs we&#39;ll be at the start of the memory page - <code>0x08048f93</code> - and have to step through it until we reach our target function (so that we don&#39;t hook any other functions) - MessageBoxA at <code>0x08048fb7</code>.<br /><br />To step through the memory page, within our custom exception handler we can:<br />• set the EFLAGS register to <code>SINGLE_STEP</code> to next instruction<br />• continue execution<br />• our custom exception handler will catch the single step<br />• check if our current address is the address of MessageBoxA<br />   ◇ no? set <code>SINGLE_STEP</code> in the EFLAGS register again and continue on<br />   ◇ yes? nice. we&#39;ve found the address of MessageBoxA and can jump to our hook code<br /><br /><strong><h2>## Pros &amp; Cons</h2></strong><br />+ Stealthy (used to be?)<br />- Execution is <em>very</em> slow because of single-stepping through instructions<br />   → recommended for hooking functions which are infrequently called<br /><br /><strong><h2>## Demo</h2></strong><br />I&#39;m hooking MessageBoxA.<br />Here are my calls:<br />• call MessageBoxA<br />• Hook MessageBoxA<br />• call MessageBoxA (will be hooked)<br />• call MessageBoxA (will be hooked)<br />• Unhook MessageBoxA<br />• call MessageBoxA (will NOT be hooked)<br /><br /><div class="codebox"><div class="codebox">MessageBoxA(NULL,&nbsp;&quot;i&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />PageGuardHook(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;&amp;hooked_MessageBoxA,&nbsp;&amp;memprotect_MessageBoxA);<br />MessageBoxA(NULL,&nbsp;&quot;hello&quot;,&nbsp;&quot;hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />MessageBoxA(NULL,&nbsp;&quot;hello&nbsp;good&nbsp;sir&quot;,&nbsp;&quot;hi&nbsp;#2&quot;,&nbsp;MB_OK);<br /><br />PageGuardUnhook(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;memprotect_MessageBoxA);<br />MessageBoxA(NULL,&nbsp;&quot;was&nbsp;he&nbsp;listening?&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);</div></div><br /><br />The first call to MessageBoxA isn&#39;t hooked.<br /><a href=""><img src="images/1694-2.png" alt="images/1694-2.png" /></a><br /><br />Next the hook is inserted.<br />The next 2 calls to MessageBoxA get hooked, the hook is then removed, and we see our last MessageBoxA.<br /><a href=""><img src="images/1694-3.png" alt="images/1694-3.png" /></a><br /><br /><a href=""><img src="images/1694-4.png" alt="images/1694-4.png" /></a><br /><br /><a href=""><img src="images/1694-5.png" alt="images/1694-5.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br />32bit version.<br />Tested on Windows 10 x64 2004.<br />Compiled as x86 debug.<br /><br /><div class="codebox"><div class="codebox">/*<br />Hooks&nbsp;functions&nbsp;by&nbsp;creating&nbsp;a&nbsp;STATUS_GUARD_PAGE_VIOLATION&nbsp;exception&nbsp;and&nbsp;using&nbsp;a&nbsp;custom&nbsp;exception&nbsp;handler&nbsp;to&nbsp;handle&nbsp;it<br />(which&nbsp;will&nbsp;single&nbsp;step&nbsp;until&nbsp;it&nbsp;reaches&nbsp;your&nbsp;target&nbsp;function&nbsp;and&nbsp;modify&nbsp;the&nbsp;Instruction&nbsp;Pointer&nbsp;to&nbsp;point&nbsp;to&nbsp;your&nbsp;hook&nbsp;code)<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;(__stdcall*&nbsp;orig_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br />int&nbsp;__stdcall&nbsp;hooked_MessageBoxA(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType)<br />{<br />	printf(&quot;MessageBoxA&nbsp;hooked!&nbsp;\n&quot;);<br />	printf(&quot;\t&nbsp;lpText:&nbsp;%s&nbsp;\n&quot;,&nbsp;lpText);<br />	printf(&quot;\t&nbsp;lpCaption:&nbsp;%s&nbsp;\n&quot;,&nbsp;lpCaption);<br /><br />	return&nbsp;orig_MessageBoxA(hWnd,&nbsp;lpText,&nbsp;lpCaption,&nbsp;uType);<br />}<br /><br />/*<br />Custom&nbsp;exception&nbsp;handler&nbsp;for&nbsp;catching&nbsp;STATUS_GUARD_PAGE_VIOLATION&nbsp;and&nbsp;hooking&nbsp;functions.<br />First&nbsp;it&nbsp;catches&nbsp;access&nbsp;of&nbsp;PAGE_GUARD&nbsp;regions&nbsp;memory&nbsp;and&nbsp;sets&nbsp;the&nbsp;EFLAGS&nbsp;register&nbsp;to&nbsp;SINGLE_STEP.<br />It&nbsp;then&nbsp;catches&nbsp;SINGLE_STEP&nbsp;exceptions&nbsp;until&nbsp;we&nbsp;reach&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;function&nbsp;we&nbsp;want&nbsp;to&nbsp;hook,<br />and&nbsp;modifies&nbsp;the&nbsp;IP&nbsp;-&nbsp;Instruction&nbsp;Pointer&nbsp;-&nbsp;to&nbsp;point&nbsp;to&nbsp;our&nbsp;hooked&nbsp;function&nbsp;instead&nbsp;of&nbsp;the&nbsp;original&nbsp;function.<br />*/<br />long&nbsp;CustomExceptionHandler(PEXCEPTION_POINTERS&nbsp;info)<br />{<br />	DWORD&nbsp;exception&nbsp;=&nbsp;0;<br />	DWORD&nbsp;current_address&nbsp;=&nbsp;0;<br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	exception&nbsp;=&nbsp;info-&gt;ExceptionRecord-&gt;ExceptionCode;<br /><br />	switch&nbsp;(exception)<br />	{<br />	case&nbsp;STATUS_GUARD_PAGE_VIOLATION:<br />		current_address&nbsp;=&nbsp;info-&gt;ContextRecord-&gt;Eip;<br /><br />		//&nbsp;if&nbsp;our&nbsp;current&nbsp;address&nbsp;is&nbsp;the&nbsp;function&nbsp;we&nbsp;want&nbsp;to&nbsp;hook,&nbsp;modify&nbsp;EIP&nbsp;to&nbsp;point&nbsp;to&nbsp;our&nbsp;hooked&nbsp;function&nbsp;instead<br />		if&nbsp;(current_address&nbsp;==&nbsp;(DWORD)&amp;MessageBoxA)<br />			info-&gt;ContextRecord-&gt;Eip&nbsp;=&nbsp;(DWORD)&amp;hooked_MessageBoxA;<br /><br />		info-&gt;ContextRecord-&gt;EFlags&nbsp;|=&nbsp;0x100;		//&nbsp;enable&nbsp;a&nbsp;STATUS_SINGLE_STEP&nbsp;exception&nbsp;on&nbsp;the&nbsp;next&nbsp;instruction<br />		return&nbsp;EXCEPTION_CONTINUE_EXECUTION;		//&nbsp;continue&nbsp;executing<br />	<br />	case&nbsp;STATUS_SINGLE_STEP:<br />		//&nbsp;set&nbsp;PAGE_GUARD&nbsp;flag&nbsp;again&nbsp;(because&nbsp;hitting&nbsp;a&nbsp;PAGE_GUARD&nbsp;exception&nbsp;removes&nbsp;it)&nbsp;and&nbsp;continue&nbsp;executing<br />		VirtualProtect((LPVOID)&amp;MessageBoxA,&nbsp;1,&nbsp;PAGE_EXECUTE_READ&nbsp;|&nbsp;PAGE_GUARD,&nbsp;&amp;old_protect);<br />		return&nbsp;EXCEPTION_CONTINUE_EXECUTION;<br /><br />	default:<br />		break;<br />	}<br /><br />	return&nbsp;EXCEPTION_CONTINUE_SEARCH;<br />}<br /><br />/*<br />Locates&nbsp;your&nbsp;target&nbsp;function&nbsp;and&nbsp;sets&nbsp;the&nbsp;PAGE_GUARD&nbsp;flag&nbsp;on&nbsp;the&nbsp;memory&nbsp;page&nbsp;in&nbsp;which&nbsp;your&nbsp;function&nbsp;resides.<br />Whenever&nbsp;the&nbsp;function&nbsp;is&nbsp;accessed,&nbsp;it&nbsp;will&nbsp;cause&nbsp;STATUS_GUARD_PAGE_VIOLATION.<br /><br />With&nbsp;a&nbsp;custom&nbsp;exception&nbsp;handler&nbsp;set&nbsp;up,&nbsp;you&nbsp;can&nbsp;catch&nbsp;the&nbsp;STATUS_GUARD_PAGE_VIOLATION,&nbsp;single&nbsp;step&nbsp;until&nbsp;you&nbsp;find&nbsp;the&nbsp;address&nbsp;of&nbsp;your&nbsp;target&nbsp;function,<br />and&nbsp;then&nbsp;modify&nbsp;EIP&nbsp;to&nbsp;point&nbsp;to&nbsp;your&nbsp;hook&nbsp;code.<br />*/<br />BOOL&nbsp;PageGuardHook(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function,&nbsp;OUT&nbsp;DWORD*&nbsp;old_protect)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br /><br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;orig_function&nbsp;=&nbsp;NULL;<br /><br />	MEMORY_BASIC_INFORMATION&nbsp;mbi_orig&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	MEMORY_BASIC_INFORMATION&nbsp;mbi_hooked&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	printf(&quot;[+]&nbsp;hooking&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />	//&nbsp;grab&nbsp;address&nbsp;of&nbsp;function&nbsp;to&nbsp;hook<br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />	orig_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(orig_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;find&nbsp;%s&nbsp;address:&nbsp;%d&nbsp;\n&quot;,&nbsp;function_name,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;check&nbsp;if&nbsp;target&nbsp;function&nbsp;and&nbsp;hook&nbsp;code&nbsp;are&nbsp;in&nbsp;same&nbsp;page<br />	//&nbsp;you&nbsp;can&#39;t&nbsp;hook&nbsp;two&nbsp;functions&nbsp;in&nbsp;the&nbsp;same&nbsp;page&nbsp;because&nbsp;it&nbsp;will&nbsp;cause&nbsp;an&nbsp;infinite&nbsp;callback<br />	VirtualQuery(orig_function,&nbsp;&amp;mbi_orig,&nbsp;sizeof(mbi_orig));<br />	VirtualQuery(hooked_function,&nbsp;&amp;mbi_hooked,&nbsp;sizeof(mbi_hooked));<br />	if&nbsp;(mbi_orig.BaseAddress&nbsp;==&nbsp;mbi_hooked.BaseAddress)<br />	{<br />		printf(&quot;\t&nbsp;this&nbsp;hook&nbsp;will&nbsp;cause&nbsp;an&nbsp;infinite&nbsp;loop.&nbsp;exiting&nbsp;\n&quot;);<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;set&nbsp;PAGE_GUARD&nbsp;flag&nbsp;on&nbsp;memory&nbsp;page<br />	b_ret&nbsp;=&nbsp;VirtualProtect(orig_function,&nbsp;1,&nbsp;PAGE_EXECUTE_READ&nbsp;|&nbsp;PAGE_GUARD,&nbsp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;set&nbsp;PAGE_GUARD&nbsp;flag&nbsp;at&nbsp;0x%p:&nbsp;%d&nbsp;\n&quot;,&nbsp;orig_function,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;start&nbsp;address&nbsp;of&nbsp;target&nbsp;function&nbsp;+&nbsp;2&nbsp;(this&nbsp;will&nbsp;dodge&nbsp;hook&nbsp;redirection&nbsp;in&nbsp;exception&nbsp;handler&nbsp;and&nbsp;execute&nbsp;the&nbsp;original&nbsp;function)<br />	*p_orig_function&nbsp;=&nbsp;(LPVOID)((DWORD)orig_function&nbsp;+&nbsp;2);<br /><br />	return&nbsp;okay;<br />}<br /><br />/*<br />Unhooks&nbsp;specific&nbsp;function&nbsp;by&nbsp;removing&nbsp;PAGE_GUARD&nbsp;flag&nbsp;from&nbsp;the&nbsp;memory&nbsp;page&nbsp;in&nbsp;which&nbsp;its&nbsp;contained.<br />*/<br />BOOL&nbsp;PageGuardUnhook(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;DWORD&nbsp;old_protect)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;orig_function&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;page_guard_protect&nbsp;=&nbsp;0;<br /><br />	printf(&quot;[+]&nbsp;unhooking&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />	//&nbsp;grab&nbsp;address&nbsp;of&nbsp;function&nbsp;to&nbsp;hook<br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />	orig_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(orig_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;find&nbsp;%s&nbsp;address:&nbsp;%d&nbsp;\n&quot;,&nbsp;function_name,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;restore&nbsp;original&nbsp;protection&nbsp;on&nbsp;memory&nbsp;page&nbsp;(remove&nbsp;PAGE_GUARD&nbsp;flag)<br />	b_ret&nbsp;=&nbsp;VirtualProtect(orig_function,&nbsp;1,&nbsp;old_protect,&nbsp;&amp;page_guard_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;restore&nbsp;original&nbsp;memory&nbsp;protection&nbsp;at&nbsp;0x%p:&nbsp;%d&nbsp;\n&quot;,&nbsp;orig_function,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	PVOID&nbsp;h_exception&nbsp;=&nbsp;NULL;<br />	ULONG&nbsp;u_ret&nbsp;=&nbsp;0;<br />	DWORD&nbsp;memprotect_MessageBoxA&nbsp;=&nbsp;0;				//&nbsp;original&nbsp;memory&nbsp;protection&nbsp;on&nbsp;MessageBoxA&nbsp;page.&nbsp;value&nbsp;set&nbsp;by&nbsp;PageGuardHook().&nbsp;used&nbsp;for&nbsp;PageGuardUnhook()<br /><br />	//&nbsp;Set&nbsp;custom&nbsp;exception&nbsp;handler&nbsp;(for&nbsp;hooking)<br />	h_exception&nbsp;=&nbsp;AddVectoredExceptionHandler(1,&nbsp;(PVECTORED_EXCEPTION_HANDLER)CustomExceptionHandler);<br />	if&nbsp;(h_exception&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;set&nbsp;custom&nbsp;exception&nbsp;handler&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	MessageBoxA(NULL,&nbsp;&quot;i&nbsp;should&nbsp;greet&nbsp;myself&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	PageGuardHook(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;&amp;hooked_MessageBoxA,&nbsp;(LPVOID)&amp;orig_MessageBoxA,&nbsp;&amp;memprotect_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&quot;,&nbsp;&quot;hi&nbsp;#1&quot;,&nbsp;MB_OK);<br />	MessageBoxA(NULL,&nbsp;&quot;hello&nbsp;good&nbsp;sir&quot;,&nbsp;&quot;hi&nbsp;#2&quot;,&nbsp;MB_OK);<br /><br />	PageGuardUnhook(&quot;User32.dll&quot;,&nbsp;&quot;MessageBoxA&quot;,&nbsp;memprotect_MessageBoxA);<br />	MessageBoxA(NULL,&nbsp;&quot;was&nbsp;he&nbsp;listening?&quot;,&nbsp;&quot;hmm...&quot;,&nbsp;MB_OK);<br /><br />	//&nbsp;Remove&nbsp;custom&nbsp;exception&nbsp;handler<br />	u_ret&nbsp;=&nbsp;RemoveVectoredExceptionHandler(h_exception);<br />	if&nbsp;(u_ret&nbsp;==&nbsp;0)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;remove&nbsp;custom&nbsp;exception&nbsp;handler&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /></div>
</body>
</html>
