<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>GUI Applications</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># GUI Applications</h1></strong><br />• <a href="http://winprog.org/tutorial/simple_window.html">http://winprog.org/tutorial/simple_window.html</a><br />• <a href="https://zetcode.com/gui/winapi/window/">https://zetcode.com/gui/winapi/window/</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/winmain--the-application-entry-point">https://docs.microsoft.com/en-us/windows/win32/learnwin32/winmain--the-application-entry-point</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/your-first-windows-program">https://docs.microsoft.com/en-us/windows/win32/learnwin32/your-first-windows-program</a> - Good &amp; simple by Microsoft<br /><br /><strong><h2>## Creating Windows</h2></strong><br /><strong>Window Class</strong> - stores information about a window design<br /><strong>Window Procedure</strong> - controls the window, its icons, background colour, etc.<br /><br />You can create 1 Window Class (and set its colour, icons, etc.)<br />and then create multiple Windows from that class without having to specificy the attributes again.<br /><br />Windows are communicated to using messages:<br />a user moves the mouse, presses a key, clicks on your window, etc.<br />these are all sent as messages to your Window and enter a queue.<br />To request the next item in the queue, you use GetMessage().<br />DispatchMessage() sends the message to the intended window.<br /><br />The Window Procedure - WndProc - is where the messages sent to our window get processed.<br />The window procedure gets called for each message.<br /><br />1. Register a Window class<br />	Here you specify the Window&#39;s attributes<br />2. Create a Window<br />	Specify the Window style, x/y co-ordinates, size, etc.<br />3. Create the Message loop<br />	The heart that gets messages from the queue and dispatches them to your window<br />4. Create the Window Procedure<br />	The brain that handles the messages the window gets sent and handles them<br /><br /><div class="codebox"><div class="codebox">/*<br />#&nbsp;A&nbsp;Simple&nbsp;Window&nbsp;(in&nbsp;Win32)<br />Following&nbsp;this:<br />http://winprog.org/tutorial/simple_window.html<br /><br />Compilation&nbsp;settings:<br />-&nbsp;Advanced&nbsp;&gt;&nbsp;Character&nbsp;set&nbsp;&gt;&nbsp;Use&nbsp;multi-byte<br />-&nbsp;Linker&nbsp;&gt;&nbsp;System&nbsp;&gt;&nbsp;SubSystem&nbsp;&gt;&nbsp;Windows<br />*/<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />const&nbsp;char&nbsp;windowclass_name1[]&nbsp;=&nbsp;&quot;FirstWindow&quot;;<br /><br />//&nbsp;Step&nbsp;4.&nbsp;Window&nbsp;Procedure<br />LRESULT&nbsp;CALLBACK&nbsp;WndProc(HWND&nbsp;hwnd,&nbsp;UINT&nbsp;msg,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)<br />{<br />	switch&nbsp;(msg)<br />	{<br />	case&nbsp;WM_CLOSE:		//&nbsp;e.g.&nbsp;User&nbsp;presses&nbsp;X&nbsp;button&nbsp;to&nbsp;close<br />		//&nbsp;Here&nbsp;you&nbsp;could&nbsp;prompt&nbsp;user&nbsp;to&nbsp;save&nbsp;files&nbsp;/&nbsp;perform&nbsp;cleanup<br />		DestroyWindow(hwnd);		//&nbsp;Destroys&nbsp;window&nbsp;and&nbsp;LL&nbsp;child&nbsp;windows&nbsp;and&nbsp;removes&nbsp;window&nbsp;from&nbsp;system<br />		break;<br />	case&nbsp;WM_DESTROY:<br />		PostQuitMessage(0);		//&nbsp;Sends&nbsp;WM_QUIT&nbsp;to&nbsp;message&nbsp;loop&nbsp;to&nbsp;quit<br />		break;<br />	default:<br />		return&nbsp;DefWindowProcA(hwnd,&nbsp;msg,&nbsp;wParam,&nbsp;lParam);<br />	}<br /><br />	return&nbsp;0;<br />}<br /><br />int&nbsp;WINAPI&nbsp;WinMain(HINSTANCE&nbsp;hInstance,&nbsp;HINSTANCE&nbsp;hPrevInstance,&nbsp;PSTR&nbsp;pCmdLine,&nbsp;int&nbsp;nCmdShow)<br /><span style="color:#000000;font-weight:400">{</span><br />	WNDCLASSEXA&nbsp;wc&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	HWND&nbsp;hwnd&nbsp;=&nbsp;NULL;<br />	MSG&nbsp;msg&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	//&nbsp;Step&nbsp;1.&nbsp;Register&nbsp;a&nbsp;Window&nbsp;class<br />	wc.cbSize&nbsp;=&nbsp;sizeof(WNDCLASSEXA);<br />	wc.style&nbsp;=&nbsp;0;<br />	wc.lpfnWndProc&nbsp;=&nbsp;WndProc;<br />	wc.cbClsExtra&nbsp;=&nbsp;0;<br />	wc.cbWndExtra&nbsp;=&nbsp;0;<br />	wc.hInstance&nbsp;=&nbsp;hInstance;<br />	wc.hIcon&nbsp;=&nbsp;LoadIconA(NULL,&nbsp;IDI_APPLICATION);<br />	wc.hCursor&nbsp;=&nbsp;LoadCursorA(NULL,&nbsp;IDC_ARROW);<br />	wc.hbrBackground&nbsp;=&nbsp;(HBRUSH)(COLOR_WINDOW&nbsp;+&nbsp;1);<br />	wc.lpszMenuName&nbsp;=&nbsp;NULL;<br />	wc.lpszClassName&nbsp;=&nbsp;windowclass_name1;<br />	wc.hIconSm&nbsp;=&nbsp;LoadIconA(NULL,&nbsp;IDI_APPLICATION);<br /><br />	if&nbsp;(!RegisterClassExA(&amp;wc))<br />	{<br />		MessageBoxA(NULL,&nbsp;&quot;Failed&nbsp;to&nbsp;register&nbsp;window&nbsp;:/&quot;,&nbsp;&quot;Error&quot;,&nbsp;MB_ICONEXCLAMATION&nbsp;|&nbsp;MB_OK);<br />		return&nbsp;-1;<br />	}<br /><br />	//&nbsp;Step&nbsp;2.&nbsp;Create&nbsp;a&nbsp;Window<br />	hwnd&nbsp;=&nbsp;CreateWindowExA(WS_EX_CLIENTEDGE,&nbsp;windowclass_name1,&nbsp;&quot;My&nbsp;window&nbsp;title&quot;,&nbsp;WS_OVERLAPPEDWINDOW,&nbsp;CW_USEDEFAULT,&nbsp;CW_USEDEFAULT,&nbsp;240,&nbsp;120,&nbsp;NULL,&nbsp;NULL,&nbsp;hInstance,&nbsp;NULL);<br />	if&nbsp;(hwnd&nbsp;==&nbsp;NULL)<br />	{<br />		MessageBoxA(NULL,&nbsp;&quot;Failed&nbsp;to&nbsp;create&nbsp;window&nbsp;:/&quot;,&nbsp;&quot;Error&quot;,&nbsp;MB_ICONEXCLAMATION&nbsp;|&nbsp;MB_OK);<br />		return&nbsp;-1;<br />	}<br /><br />	//&nbsp;Show&nbsp;Window&nbsp;and&nbsp;update&nbsp;it&nbsp;to&nbsp;ensure&nbsp;it&#39;s&nbsp;drawn&nbsp;correctly<br />	ShowWindow(hwnd,&nbsp;nCmdShow);<br />	UpdateWindow(hwnd);<br />	<br />	//&nbsp;Step&nbsp;3.&nbsp;Message&nbsp;Loop<br />	while&nbsp;(GetMessageA(&amp;msg,&nbsp;NULL,&nbsp;0,&nbsp;0)&nbsp;&gt;&nbsp;0)<br />	{<br />		TranslateMessage(&amp;msg);<br />		DispatchMessageA(&amp;msg);<br />	}<br /><br />	return&nbsp;msg.wParam;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
