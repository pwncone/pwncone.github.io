<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Hook LdrLoadDll</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Hook LdrLoadDll</h1></strong><br /><code>LdrLoadDll</code> is an undocumenented function from Ntdll.dll that loads DLLs into the process.<br />It gets called by <code>LoadLibrary</code>.<br /><a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FLdrLoadDll.html">http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FLdrLoadDll.html</a><br /><br />By hooking LdrLoadDll, you can monitor what DLLs are being loaded into your process and block or allow them based on a list.<br />You coud choose to blacklist items - i.e. block <code>aimbot.dll</code> - or whitelist items - i.e. allow <code>Kernel32.dll</code>.<br />I would recommend a whitelist as this allows you to control exactly what is allowed.<br /><br />ALL CREDIT GOES HERE:<br />â€¢ <a href="https://gist.github.com/bats3c/59932dfa1f5bb23dd36071119b91af0f">https://gist.github.com/bats3c/59932dfa1f5bb23dd36071119b91af0f</a><br /><br />NOTE:<br />This will only block DLLs being loaded into your process AFTER your process has initialised. <br />This is because we can only install our hook on LdrLoadDll after our process has initialised.<br />(I&#39;m not sure if this blocks AppInit_DLLs or not)<br /><br /><strong><h2>## Code</h2></strong><br />Compiled as Release x86 on Windows 10 x64 2004.<br /><br />This code is x86 only because the inline hook function is for x86, <br />but with an x64 hooking technique this code would still work. <br /><br />You can ignore the HookFunction code, the relavant part is the LdrLoadDll hook code.<br /><div class="codebox"><div class="codebox">/*<br />Hook&nbsp;ntdll!LdrLoadDll&nbsp;and&nbsp;compare&nbsp;the&nbsp;DLL&nbsp;being&nbsp;loaded&nbsp;to&nbsp;those&nbsp;in&nbsp;the&nbsp;whitelist.<br />If&nbsp;not&nbsp;present,&nbsp;block&nbsp;the&nbsp;DLL&nbsp;from&nbsp;being&nbsp;loaded.<br />This&nbsp;will&nbsp;only&nbsp;block&nbsp;DLLs&nbsp;being&nbsp;loaded&nbsp;after&nbsp;the&nbsp;process&nbsp;is&nbsp;initialised&nbsp;(so&nbsp;I&#39;m&nbsp;not&nbsp;sure&nbsp;if&nbsp;it&nbsp;blocks&nbsp;AppInit_DLLs&nbsp;or&nbsp;not).<br />This&nbsp;code&nbsp;is&nbsp;x86&nbsp;only&nbsp;because&nbsp;the&nbsp;hooking&nbsp;method&nbsp;is&nbsp;x86.<br />*/<br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />wchar_t&nbsp;dll_whitelist[2][32]&nbsp;=<br />{<br />	L&quot;Ntdll.dll&quot;,<br />	L&quot;Kernel32.dll&quot;<br />};<br />int&nbsp;dll_whitelist_size&nbsp;=&nbsp;sizeof(dll_whitelist)&nbsp;/&nbsp;sizeof(dll_whitelist[0]);<br /><br />NTSTATUS&nbsp;(NTAPI*&nbsp;orig_LdrLoadDll)(IN&nbsp;PWCHAR&nbsp;PathToFile&nbsp;OPTIONAL,&nbsp;IN&nbsp;ULONG&nbsp;Flags&nbsp;OPTIONAL,&nbsp;IN&nbsp;PUNICODE_STRING&nbsp;ModuleFileName,&nbsp;OUT&nbsp;PHANDLE&nbsp;ModuleHandle);<br />NTSTATUS&nbsp;NTAPI&nbsp;hooked_LdrLoadDll(IN&nbsp;PWCHAR&nbsp;PathToFile&nbsp;OPTIONAL,&nbsp;IN&nbsp;ULONG&nbsp;Flags&nbsp;OPTIONAL,&nbsp;IN&nbsp;PUNICODE_STRING&nbsp;ModuleFileName,&nbsp;OUT&nbsp;PHANDLE&nbsp;ModuleHandle)<br />{<br />	wchar_t*&nbsp;p_valid_dll&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;dll_allowed&nbsp;=&nbsp;FALSE;<br />	printf(&quot;*&nbsp;LdrLoadDll:&nbsp;%ws&nbsp;&quot;,&nbsp;ModuleFileName-&gt;Buffer);<br />	<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;dll_whitelist_size;&nbsp;i++)<br />	{<br />		p_valid_dll&nbsp;=&nbsp;wcsstr(ModuleFileName-&gt;Buffer,&nbsp;dll_whitelist[i]);<br />		if&nbsp;(p_valid_dll&nbsp;!=&nbsp;NULL)<br />		{<br />			dll_allowed&nbsp;=&nbsp;TRUE;<br />			break;<br />		}<br />	}<br /><br />	if&nbsp;(dll_allowed&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;&nbsp;&lt;--&nbsp;BLOCKED&nbsp;\n&quot;);<br />		return&nbsp;STATUS_DLL_NOT_FOUND;<br />	}<br /><br />	printf(&quot;&nbsp;&lt;--&nbsp;OK&nbsp;\n&quot;);<br />	return&nbsp;orig_LdrLoadDll(PathToFile,&nbsp;Flags,&nbsp;ModuleFileName,&nbsp;ModuleHandle);<br />}<br /><br />BOOL&nbsp;HookFunction(char*&nbsp;dll_name,&nbsp;char*&nbsp;function_name,&nbsp;void*&nbsp;hooked_function,&nbsp;void**&nbsp;p_orig_function)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;FALSE;<br /><br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;original_function&nbsp;=&nbsp;NULL;<br /><br />	LPVOID&nbsp;trampoline_addr&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;jmp_originalfunction&nbsp;=&nbsp;0;<br />	DWORD&nbsp;jmp_trampoline&nbsp;=&nbsp;0;<br />	DWORD&nbsp;jmp_hook&nbsp;=&nbsp;0;<br /><br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br /><br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />	original_function&nbsp;=&nbsp;GetProcAddress(hmod_dll,&nbsp;function_name);<br />	if&nbsp;(original_function&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;grab&nbsp;address&nbsp;of&nbsp;%s:&nbsp;%d&nbsp;\n&quot;,&nbsp;function_name,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	/*<br />	Allocate&nbsp;trampoline&nbsp;space<br />	Will&nbsp;contain:<br />		-&nbsp;(5&nbsp;bytes)&nbsp;jmp&nbsp;hook_function<br />		-&nbsp;(5&nbsp;bytes)&nbsp;5&nbsp;bytes&nbsp;from&nbsp;original&nbsp;function<br />		-&nbsp;(5&nbsp;bytes)&nbsp;jmp&nbsp;original_function&nbsp;+&nbsp;1<br />	*/<br />	trampoline_addr&nbsp;=&nbsp;VirtualAlloc(NULL,&nbsp;15,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(trampoline_addr&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;gatecode&nbsp;space:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Calculate&nbsp;jumps<br />	jmp_trampoline&nbsp;=&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;5)&nbsp;-&nbsp;(DWORD)original_function;				//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;original&nbsp;function&nbsp;+&nbsp;0&nbsp;to&nbsp;trampoline&nbsp;+&nbsp;10<br />	jmp_originalfunction&nbsp;=&nbsp;((DWORD)original_function)&nbsp;-&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;5);		//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;trampoline&nbsp;+&nbsp;5&nbsp;to&nbsp;original&nbsp;function<br />	jmp_hook&nbsp;=&nbsp;(DWORD)hooked_function&nbsp;-&nbsp;((DWORD)trampoline_addr&nbsp;+&nbsp;10)&nbsp;-&nbsp;5;					//&nbsp;relative&nbsp;jump&nbsp;from&nbsp;trampoline&nbsp;+&nbsp;10&nbsp;to&nbsp;hooked&nbsp;code<br /><br />	//&nbsp;Construct&nbsp;trampoline<br />	memcpy_s((BYTE*)trampoline_addr,&nbsp;5,&nbsp;original_function,&nbsp;5);					//&nbsp;Copy&nbsp;first&nbsp;5&nbsp;bytes&nbsp;from&nbsp;original&nbsp;function&nbsp;to&nbsp;trampoline&nbsp;space<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;5,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);							//&nbsp;Jump&nbsp;to&nbsp;original&nbsp;function&nbsp;+&nbsp;5&nbsp;(bypasses&nbsp;the&nbsp;hook)<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;6,&nbsp;4,&nbsp;&amp;jmp_originalfunction,&nbsp;4);<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;10,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);						//&nbsp;Jump&nbsp;to&nbsp;hook&nbsp;code<br />	memcpy_s((BYTE*)trampoline_addr&nbsp;+&nbsp;11,&nbsp;4,&nbsp;&amp;jmp_hook,&nbsp;4);<br /><br />	//&nbsp;Make&nbsp;original&nbsp;function&nbsp;writable<br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;make&nbsp;memory&nbsp;writable:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Overwrite&nbsp;first&nbsp;5&nbsp;bytes&nbsp;of&nbsp;original&nbsp;function&nbsp;with&nbsp;jump&nbsp;to&nbsp;trampoline<br />	memcpy_s(original_function,&nbsp;1,&nbsp;&quot;\xE9&quot;,&nbsp;1);<br />	memcpy_s((BYTE*)original_function&nbsp;+&nbsp;1,&nbsp;4,&nbsp;&amp;jmp_trampoline,&nbsp;4);<br /><br />	b_ret&nbsp;=&nbsp;VirtualProtect(original_function,&nbsp;5,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;restore&nbsp;original&nbsp;memory&nbsp;protection:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		okay&nbsp;=&nbsp;FALSE;<br />		return&nbsp;okay;<br />	}<br /><br />	//&nbsp;Set&nbsp;pointer&nbsp;to&nbsp;original&nbsp;function&nbsp;to&nbsp;start&nbsp;of&nbsp;trampoline&nbsp;(trampoline&nbsp;will&nbsp;run&nbsp;function&nbsp;prologue&nbsp;and&nbsp;then&nbsp;jump&nbsp;to&nbsp;original&nbsp;function)<br />	*p_orig_function&nbsp;=&nbsp;trampoline_addr;<br /><br />	FlushInstructionCache(GetCurrentProcess(),&nbsp;original_function,&nbsp;5);		//&nbsp;Not&nbsp;sure&nbsp;if&nbsp;necessarily&nbsp;needed<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	HookFunction(&quot;Ntdll.dll&quot;,&nbsp;&quot;LdrLoadDll&quot;,&nbsp;&amp;hooked_LdrLoadDll,&nbsp;(void*)&amp;orig_LdrLoadDll);<br /><br />	HMODULE&nbsp;hmod_dll&nbsp;=&nbsp;NULL;<br /><br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(&quot;Ntdll.dll&quot;);<br />	if&nbsp;(hmod_dll&nbsp;==&nbsp;NULL)<br />		printf(&quot;\t&nbsp;Ntdll.dll&nbsp;failed:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	<br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(&quot;Kernel32.dll&quot;);<br />	if&nbsp;(hmod_dll&nbsp;==&nbsp;NULL)<br />		printf(&quot;\t&nbsp;Kernel32.dll&nbsp;failed:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	<br />	hmod_dll&nbsp;=&nbsp;LoadLibraryA(&quot;IMM32.DLL&quot;);<br />	if&nbsp;(hmod_dll&nbsp;==&nbsp;NULL)<br />		printf(&quot;\t&nbsp;IMM32.dll&nbsp;failed:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Demo</h2></strong><br />In my whitelist is <code>Ntdll.dll</code> and <code>Kernel32.dll</code>.<br /><a href=""><img src="images/1749-1.png" alt="images/1749-1.png" /></a><br /><br />In my program I try to load <code>Ntdll.dll</code>, <code>Kernel32.dll</code>, and <code>IMM32.dll</code><br /><a href=""><img src="images/1749-2.png" alt="images/1749-2.png" /></a><br /><br />When I run my program, we see that <code>Ntdll.dll</code> and <code>Kernel32.dll</code> are OK,<br />but that <code>IMM32.dll</code> gets BLOCKED because it&#39;s not in my whitelist.<br /><a href=""><img src="images/1749-3.png" alt="images/1749-3.png" /></a></div>
</body>
</html>
