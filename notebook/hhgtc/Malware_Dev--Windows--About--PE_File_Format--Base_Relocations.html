<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Base Relocations</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Base Relocations</h1></strong><br />Base relocations can be a pain.<br /><br />• <a href="https://reverseengineering.stackexchange.com/questions/15080/how-reloc-section-is-used-in-pe-file">https://reverseengineering.stackexchange.com/questions/15080/how-reloc-section-is-used-in-pe-file</a> - good explanation<br />• <a href="https://stackoverflow.com/questions/17436668/how-are-pe-base-relocations-build-up">https://stackoverflow.com/questions/17436668/how-are-pe-base-relocations-build-up</a> - sample code<br />• <a href="https://www.unknowncheats.me/forum/c-and-c-/231635-image-relocation.html">https://www.unknowncheats.me/forum/c-and-c-/231635-image-relocation.html</a> - 32bit sample code<br />• <a href="https://github.com/huangqiheng/andpack/blob/6c53f92b7bf949723c99a35465e3f75b0a98bda9/msghooker/dll_loader.c#L212">https://github.com/huangqiheng/andpack/blob/6c53f92b7bf949723c99a35465e3f75b0a98bda9/msghooker/dll_loader.c#L212</a> - sample code<br />• <a href="https://github.com/Zer0Mem0ry/ManualMap/blob/master/ManualInjector/ManualInjector.cpp">https://github.com/Zer0Mem0ry/ManualMap/blob/master/ManualInjector/ManualInjector.cpp</a> - sample code<br />• <a href="https://web.archive.org/web/20141105094409/http://gate.upm.ro/os/LABs/Windows_OS_Internals_Curriculum_Resource_Kit-ACADEMIC/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/rtl/ldrreloc.c">https://web.archive.org/web/20141105094409/http://gate.upm.ro/os/LABs/Windows_OS_Internals_Curriculum_Resource_Kit-ACADEMIC/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/rtl/ldrreloc.c</a> - windows internal file? about relocs<br />• <a href="https://medium.com/@cyjien/pe-injection-trick-d044977f4791">https://medium.com/@cyjien/pe-injection-trick-d044977f4791</a> - potential tutorial<br />• check hasherezade&#39;s PE Bear source code on github<br />• A <code>RebaseMappedImage</code> function can be found in the leaked Windows XP source code:<br />   ◇ in <code>NT\base\mspatch\api\pestuff.c</code> line 415<br />• <a href="https://github.com/polycone/pe-loader/blob/1f7b8b4913af44fe9619cec6979a7ea3b8772631/loader/src/loader/relocations.cpp#L45">https://github.com/polycone/pe-loader/blob/1f7b8b4913af44fe9619cec6979a7ea3b8772631/loader/src/loader/relocations.cpp#L45</a> - Base relocations from PE loader<br /><br />Base Relocations are stored in the <code>.reloc</code> section.<br />Chapter 6.6 in the PE specification:<br /><a href="http://www.skyfree.org/linux/references/coff.pdf">http://www.skyfree.org/linux/references/coff.pdf</a><br /><br /><strong>Tip</strong><br />Can use <code>ImageDirectoryEntryToData</code> to grab the relocation directory<br /><a href="https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagedirectoryentrytodata">https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-imagedirectoryentrytodata</a><br />Use FALSE for Raw Address, TRUE for Virtual Address.<br />Inspiration from here (search for <code>RtlImageDirectoryToData</code> function):<br /><a href="https://web.archive.org/web/20141105094409/http://gate.upm.ro/os/LABs/Windows_OS_Internals_Curriculum_Resource_Kit-ACADEMIC/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/rtl/ldrreloc.c">https://web.archive.org/web/20141105094409/http://gate.upm.ro/os/LABs/Windows_OS_Internals_Curriculum_Resource_Kit-ACADEMIC/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/rtl/ldrreloc.c</a><br /><br /><strong><h2>## Why base relocations?</h2></strong><br />Base Relocations exist for when a PE can&#39;t be loaded at its preferred base address.<br />e.g. <br />• A 32bit PE prefers to be loaded at <code>0x00400000</code><br />• Therefore, its functions will exist near this range e.g. <code>0x00401ca0</code> <code>0x0040f632</code> etc.<br /><br />When this PE can&#39;t be loaded at <code>0x00400000</code>, its functions: <code>0x00401ca0</code> <code>0x0040f632</code> need to be relocated to the new base address where the PE is loaded<br />e.g.<br />• The PE is loaded at <code>0x00600000</code> (instead of <code>0x00400000</code>)<br />• The difference between the 2 base addresses - the delta - is <code>0x00200000</code><br />• Therefore, the PE&#39;s functions can be relocated by adding the delta - <code>0x00200000</code> - to the original value<br />   ◇ <code>0x00401ca0</code> + <code>0x00200000</code> = function is relocated to <code>0x00601ca0</code><br />   ◇ <code>0x0040f632</code> + <code>0x00200000</code> = function is relocated to <code>0x0060f632</code><br />   ◇ etc.<br /><br /><strong><h2>## The Base Relocation Table - what it looks like</h2></strong><br />The Base Relocation Table looks like this:<br /><a href=""><img src="images/1529-1.png" alt="images/1529-1.png" /></a><br /><br />The relocation table contains a series of blocks.<br />Each block contains:<br />• <code>VirtualAddress</code> - an RVA from the image base. image base + this VirtualAddress + offset (below) is location of the address that needs to be fixed<br />• <code>SizeOfBlock</code> - indicates the size of the block<br /><br />Within the block, immediately following the <code>SizeOfBlock</code> value, will be a number of 16bit values.<br />These 16 bit values are relocation entries.<br /><br />Each relocation entry contains: <br />• the <code>offset</code> at where to perform the relocation<br />• the <code>type</code> of relocation to perform<br /><br />• The <code>offset</code> is stored in the first 12 bits of the entry<br />• The <code>type</code> is stored in the last 4 bits of the entry<br /><br /><strong><h3>### Relocation Type</h3></strong><br />The relocation type describes how many bits of the delta to add to the function address to relocate it.<br /><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#base-relocation-types">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#base-relocation-types</a><br /><br />Here are the common ones:<br />• <code>IMAGE_REL_BASED_ABSOLUTE</code> - the address is absolute / points directly. no relocation needed.<br />• <code>IMAGE_REL_BASED_HIGH</code> - add the high 16 bits of the delta to the high 16 bits of the 32bits @ relocation offset<br />• <code>IMAGE_REL_BASED_LOW</code> - add the low 16 bits of the delta to the low 16 bits of the 32bits @ relocation offset<br />• <code>IMAGE_REL_BASED_HIGHLOW</code> - add the entire delta (32bit value) to the 32bits @ relocation offset - common in 32 bit PEs<br />• <code>IMAGE_REL_BASED_DIR64</code> - add the entire delta to the 64bits @ relocation offset - common in 64bit PEs<br /><br /><strong><h3>### Relocation Offset</h3></strong><br />The:<br /><code>image_base + reloc_block-&gt;VirtualAddress + reloc_entry-&gt;Offset</code><br />is the address which stores a pointer to function to relocate.<br /><br />e.g. <br /><code>image_base + reloc_block-&gt;VirtualAddress + reloc_entry-&gt;Offset = 0x70562234</code><br />Memory address <code>0x70562234</code> stores the value <code>0x00401ca0</code><br /><code>0x00401ca0</code> is what we need to add to our delta to relocate the function.<br /><br /><strong><h2>## Looping through the Relocation Table</h2></strong><br />This is more difficult than it should be because the base relocation Blocks and Entries aren&#39;t stored in structs.<br />You calculate their sizes and move through them yourself.<br />It&#39;s been made clear in the example code.<br /><br /><strong><h2>## Code</h2></strong><br /><strong><h3>### About the confusing typecasts at line 138 onwards</h3></strong><br /><code>reloc_addr</code> points to the address of the relocation.<br />At <code>reloc_addr</code> there might the the value <code>0x00421507</code>.<br />In memory, because x86 is little endian, the value will look like this:<br /><code>07 15 42 00</code><br /><br />In the number <code>0x00421507</code>, <br />• the high order / most significant 16 bits are <code>00 42</code><br />• the low order / least significant 16 bits are <code>15 07</code><br /><br />Because of the little endian storage seen above, you can see these are reversed.<br />The low order bytes - <code>07 15</code> - are first<br />and the high order bytes - <code>00 42</code> - are last.<br /><br />Therefore, to grab the high order bytes we need to read at address <code>reloc_addr + 0x2</code>.<br /><code>*(WORD*)((size_t)reloc_addr + 0x2)</code><br />• <code>(size_t)reloc_addr + 0x2</code> - calculate reloc_addr + 2<br />• <code>(WORD*)()</code> - typecast value @ (reloc_addr + 2) as a pointer to a WORD (pointer to 16 bits)<br />• <code>*</code> - grab data pointed to WORD pointer<br /><br />(NOTE: on x64 it should actually be <code>reloc_addr + 0x4</code> to grab the higher 16 bytes)<br /><br />And to grab the low order bytes we can simply grab the first 2 bytes at <code>reloc_addr</code>.<br /><code>*(WORD*)reloc_addr</code><br />• <code>(WORD*)reloc_addr</code> - typescasts reloc_addr as a pointer to a WORD (pointer to 16 bits)<br />• <code>*</code> - grab data pointed to by WORD pointer<br /><br /><strong><h3>### Code</h3></strong><br /><div class="codebox"><div class="codebox">/*<br />Peform&nbsp;some&nbsp;base&nbsp;relocations.<br />USES&nbsp;RAW&nbsp;ADDRESSES.&nbsp;DO&nbsp;CHANGE&nbsp;IF&nbsp;USING&nbsp;A&nbsp;MEMORY&nbsp;MAPPED&nbsp;PE.<br />target_base&nbsp;IN&nbsp;MAIN&nbsp;IS&nbsp;FOR&nbsp;64BIT&nbsp;PEs.&nbsp;MODIFY&nbsp;IF&nbsp;WORKING&nbsp;WITH&nbsp;32BIT&nbsp;PE.<br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;If&nbsp;the&nbsp;provided&nbsp;VA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />/*<br />Loop&nbsp;through&nbsp;relocation&nbsp;table&nbsp;and&nbsp;perform&nbsp;base&nbsp;relocations.<br />Uses&nbsp;raw&nbsp;addresses!<br />If&nbsp;statements&nbsp;are&nbsp;used&nbsp;to&nbsp;make&nbsp;the&nbsp;code&nbsp;position&nbsp;independent&nbsp;<br />(using&nbsp;a&nbsp;switch&nbsp;statement&nbsp;assembles&nbsp;to&nbsp;jmp&nbsp;instructions,&nbsp;which&nbsp;<br />prevents&nbsp;the&nbsp;code&nbsp;from&nbsp;being&nbsp;position&nbsp;independent)<br />*/<br />BOOL&nbsp;RelocatePE(LPVOID&nbsp;pe_buffer,&nbsp;LPVOID&nbsp;new_base)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_buffer;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((SIZE_T)dos_header&nbsp;+&nbsp;(SIZE_T)dos_header-&gt;e_lfanew);<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_table&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)pe_buffer&nbsp;+&nbsp;va2raw(pe_buffer,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress));<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_block&nbsp;=&nbsp;reloc_table;<br />	DWORD&nbsp;table_size&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br /><br />	size_t&nbsp;delta&nbsp;=&nbsp;(size_t)new_base&nbsp;-&nbsp;(size_t)pe_header-&gt;OptionalHeader.ImageBase;<br />	if&nbsp;(delta&nbsp;==&nbsp;0)<br />		return&nbsp;ok;<br /><br />	printf(&quot;[*]&nbsp;original&nbsp;base:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)pe_header-&gt;OptionalHeader.ImageBase);<br />	printf(&quot;[*]&nbsp;target&nbsp;base:&nbsp;&nbsp;&nbsp;0x%p&nbsp;\n&quot;,&nbsp;new_base);<br />	printf(&quot;[*]&nbsp;delta:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x%p&nbsp;\n\n&quot;,&nbsp;(void*)delta);<br /><br />	DWORD&nbsp;block_number&nbsp;=&nbsp;1;<br />	DWORD&nbsp;entries_in_block&nbsp;=&nbsp;0;<br />	DWORD&nbsp;table_position&nbsp;=&nbsp;0;<br />	PBASE_RELOCATION_ENTRY&nbsp;reloc_entry&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;blocks&nbsp;in&nbsp;relocation&nbsp;table<br />	while&nbsp;(table_position&nbsp;&lt;&nbsp;table_size)<br />	{<br />		entries_in_block&nbsp;=&nbsp;(reloc_block-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br />		reloc_entry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(reloc_block&nbsp;+&nbsp;1);<br /><br />		printf(&quot;\nBLOCK&nbsp;#%d&nbsp;\n&quot;,&nbsp;block_number);<br />		printf(&quot;size:&nbsp;0x%x&nbsp;\t&nbsp;entries:&nbsp;%d&nbsp;\n\n&quot;,&nbsp;reloc_block-&gt;SizeOfBlock,&nbsp;entries_in_block);<br /><br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;entries_in_block;&nbsp;i++)<br />		{<br />			void*&nbsp;reloc_addr&nbsp;=&nbsp;(void*)((size_t)pe_buffer&nbsp;+&nbsp;va2raw(pe_buffer,&nbsp;reloc_block-&gt;VirtualAddress)&nbsp;+&nbsp;reloc_entry-&gt;Offset);<br /><br />			printf(&quot;reloc&nbsp;#%d&nbsp;\t&nbsp;[reloc_addr]&nbsp;0x%p&nbsp;&quot;,&nbsp;i,&nbsp;reloc_addr);<br /><br />			if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_ABSOLUTE)<br />			{<br />				printf(&quot;\t&nbsp;[type]&nbsp;ABSOLUTE&nbsp;(no&nbsp;relocation&nbsp;needed)&nbsp;\n&quot;);<br />			}<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGH)<br />			{<br />				printf(&quot;\t&nbsp;[type]&nbsp;HIGH&nbsp;\t&nbsp;[value]&nbsp;0x%x&nbsp;&quot;,&nbsp;HIWORD(*(DWORD*)reloc_addr));<br />				*(WORD*)((size_t)reloc_addr&nbsp;+&nbsp;0x2)&nbsp;+=&nbsp;HIWORD(delta);	//&nbsp;add&nbsp;higher&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;higher&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />				printf(&quot;\t&nbsp;[modified]&nbsp;0x%x&nbsp;\n&quot;,&nbsp;*(DWORD*)reloc_addr);<br />			}<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_LOW)<br />			{<br />				printf(&quot;\t&nbsp;[type]&nbsp;LOW&nbsp;\t&nbsp;[value]&nbsp;0x%x&nbsp;&quot;,&nbsp;LOWORD(*(DWORD*)reloc_addr));<br />				*(WORD*)reloc_addr&nbsp;+=&nbsp;LOWORD(delta);					//&nbsp;add&nbsp;lower&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;lower&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />				printf(&quot;\t&nbsp;[modified]&nbsp;0x%x&nbsp;\n&quot;,&nbsp;*(DWORD*)reloc_addr);<br />			}<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGHLOW)<br />			{<br />				printf(&quot;\t&nbsp;[type]&nbsp;HIGHLOW&nbsp;\t&nbsp;[value]&nbsp;0x%x&nbsp;&quot;,&nbsp;*(DWORD*)reloc_addr);<br />				*(DWORD*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;32bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;32bits&nbsp;at&nbsp;relocation&nbsp;address<br />				printf(&quot;\t&nbsp;[modified]&nbsp;0x%x&nbsp;\n&quot;,&nbsp;*(DWORD*)reloc_addr);<br />			}<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_DIR64)<br />			{<br />				printf(&quot;\t&nbsp;[type]&nbsp;DIR64&nbsp;\t&nbsp;[value]&nbsp;0x%x&nbsp;&quot;,&nbsp;*(DWORD*)reloc_addr);<br />				*(DWORD64*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;64bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;64bits&nbsp;at&nbsp;relocation&nbsp;address<br />				printf(&quot;\t&nbsp;[modified]&nbsp;0x%llx&nbsp;\n&quot;,&nbsp;*(DWORD64*)reloc_addr);<br />			}<br />			<br />			reloc_entry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;block<br />		block_number++;<br />		table_position&nbsp;+=&nbsp;reloc_block-&gt;SizeOfBlock;<br />		reloc_block&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)reloc_block&nbsp;+&nbsp;reloc_block-&gt;SizeOfBlock);<br />	}<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;relocate&nbsp;PE&nbsp;\n\n&quot;);<br /><br />	//&nbsp;arguments&nbsp;setup<br />	if&nbsp;(argc&nbsp;!=&nbsp;2)<br />	{<br />		printf(&quot;[-]&nbsp;1&nbsp;argument&nbsp;required&nbsp;:/&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	char*&nbsp;arg1_filename&nbsp;=&nbsp;argv[1];<br /><br />	//&nbsp;main<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	file_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(arg1_filename,&nbsp;&amp;file_size);<br />	if&nbsp;(file_buffer&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	printf(&quot;[*]&nbsp;target:&nbsp;%s&nbsp;\n&quot;,&nbsp;arg1_filename);<br />	printf(&quot;[+]&nbsp;PE&nbsp;file&nbsp;loaded&nbsp;@&nbsp;0x%p&nbsp;\n\n&quot;,&nbsp;file_buffer);<br /><br />	LPVOID&nbsp;target_base&nbsp;=&nbsp;NULL;<br />#ifdef&nbsp;_WIN64<br />	target_base&nbsp;=&nbsp;(LPVOID)0x0000000360000000;<br />#else<br />	target_base&nbsp;=&nbsp;(LPVOID)0x00360000;<br />#endif<br />	RelocatePE(file_buffer,&nbsp;target_base);<br /><br />	free(file_buffer);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><a href=""><img src="images/1529-2.png" alt="images/1529-2.png" /></a><br /><br /><br /></div>
</body>
</html>
