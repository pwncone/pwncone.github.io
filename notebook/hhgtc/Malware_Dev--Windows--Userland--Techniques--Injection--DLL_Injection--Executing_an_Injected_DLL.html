<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Executing an Injected DLL</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><h1># Executing an Injected DLL</h1><br />There&#39;s lots of ways to execute an injected DLL.<br />Most of them are about redirecting execution flow, which there is also lots of ways of and if creative you can think of new ones.<br /><br /><h2>## Thread Hijacking</h2><br />(I haven&#39;t figured out how to do this without having ruining a thread)<br /><br />You hijack an existing thread to load your DLL,<br />simple enough,<br />and ideally you restore the thread back to its original state after your DLL has loaded<br />(otherwise the thread you&#39;ve hijacked is totally ruined and never to execute its original code path again. could be bad)<br /><br /><h3>### Thread Hijacking and LoadLibrary</h3><br />• <a href="https://www.rohitab.com/discuss/topic/40579-dll-injection-via-thread-hijacking/">https://www.rohitab.com/discuss/topic/40579-dll-injection-via-thread-hijacking/</a> - Good basic example<br />• <a href="https://www.unknowncheats.me/forum/general-programming-and-reversing/289609-thread-hijack-dll-loader-win10-x64.html">https://www.unknowncheats.me/forum/general-programming-and-reversing/289609-thread-hijack-dll-loader-win10-x64.html</a> - Also good example<br /><br />With LoadLibrary you can restore the hijacked thread back to its original execution just fine.<br />You hijack a thread, call LoadLibrary, and because LoadLibrary returns it means you can then restore the thread context.<br /><br />Here&#39;s some demo shellcode (from links above. credit goes there.)<br /><div class="codebox"><div class="codebox">unsigned&nbsp;char&nbsp;shellcode[]&nbsp;=&nbsp;<br />{<br />	0x48,&nbsp;0xB9,	0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;	//&nbsp;movabs&nbsp;rcx,&nbsp;ptr_dll_path<br />	0x48,&nbsp;0xB8,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;	//&nbsp;movabs&nbsp;rax,&nbsp;Loadlibrary_address<br />	0x48,&nbsp;0x83,&nbsp;0xEC,&nbsp;0x40,&nbsp;													//&nbsp;(shadow&nbsp;registers)<br />	0x48,&nbsp;0x83,&nbsp;0xE4,&nbsp;0xF7,&nbsp;													//&nbsp;(align&nbsp;16&nbsp;bytes)<br />	0xFF,&nbsp;0xD0,&nbsp;																	//&nbsp;call&nbsp;rax			;&nbsp;Call&nbsp;LoadLibrary(dll_path)<br />	0x48,&nbsp;0xB9,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;	//&nbsp;movabs&nbsp;rcx,&nbsp;ptr_thread_context<br />	0x48,&nbsp;0xB8,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;0xCC,&nbsp;	//&nbsp;movabs&nbsp;rax,&nbsp;RtlRestoreContext_address<br />	0x48,&nbsp;0x31,&nbsp;0xd2,&nbsp;															//&nbsp;xor&nbsp;rdx,&nbsp;rdx<br />	0xFF,&nbsp;0xD0&nbsp;																	//&nbsp;call&nbsp;rax			;&nbsp;Call&nbsp;RtlRestoreContext(thread_context)<br />};</div></div><br /><br />As you can see,<br />after LoadLibrary returns we call RtlRestoreContext to restore the context of the hijacked thread<br />and let it continue executing.<br /><br />All good.<br />(But LoadLibrary isn&#39;t exactly a stealthy injection method)<br /><br /><h3>### Thread Hijacking and a Manually Mapped DLL</h3><br />The problem here is that DllMain() we call of our injected DLL never returns.<br />This means we can&#39;t restore the hijacked thread and we potentially break something in the target process.<br /><br />In your DllMain, you CreateThread to execute the contents of your DllMain.<br />This would allow your DllMain function to return, and you could restore the stack,<br />but creating a thread within your injected DLL completely defeats the point of doing thread hijacking in the first place.<br />We don&#39;t want to create new threads in the process.<br /><br />Examples:<br />• <a href="https://github.com/D4stiny/ThreadJect">https://github.com/D4stiny/ThreadJect</a> - Basic<br />• <a href="https://github.com/vmcall/nt-mapper">https://github.com/vmcall/nt-mapper</a> - Overly complex c++ code but decent. Has shadow stack alignment.<br />   ◇ Searches for an Idle thread and hijacks that<br />      ▪ To follow the c++ madness:<br />         1. main.cpp - mapper.call(injected_ctx, injection::executors::create{});<br />         2. executors.cpp - bool injection::executors::hijack::handle_dllmain<br />         3. shellcode.cpp - shellcode::hijack_dllmain_size&gt; shellcode::hijack_dllmain<br />         4. <br /><br />Neither of the examples above restore the hijacked thread.<br />vmcall&#39;s nt-mapper supports restoring the stack their DLL&#39;s DllMain has been called,<br />but the only way I can imagine his DllMain returning is if they CreateThread inside of their DllMain.<br />I can&#39;t see what DLLs they&#39;ve used for testing.<br /><br /><h2>## QueueUserAPC</h2><br />You can queue a thread to execute code at an address.<br />The problem is that your request sits in a queue, and you have to wait for<br />the thread on which you&#39;ve queued your APC to execute your code.<br /><br />A thread will execute queued code when it&#39;s in an alertable state.<br /><br />Typically QueueUserAPC is run in local processes because you can call NtTestAlert<br />to force your thread into an alterable state which will then execute your queued code.<br /><br />In a remote processes, you can&#39;t do that<br />(unless you create a thread, execute NtTestAlert, etc. but that defeats the point - we don&#39;t want to create threads).<br /><br /><h3>### QueueUserAPC and Spam all the Threads</h3><br />One solution is run QueueUserAPC on all threads in the target process.<br />That way, hopefully, your queued code will run at some point<br />(one thread must become status: alterable at some point right??)<br /><br />Code here:<br /><a href="https://github.com/pwncone/towel/tree/main/tools/dll_injectors/manual_map/mmap_APCspam">https://github.com/pwncone/towel/tree/main/tools/dll_injectors/manual_map/mmap_APCspam</a><br /><br />But I can&#39;t get a thread to execute the code reliably.<br /><br /><h2>## Hook a random function in the target</h2><br />This is a pretty effective way at redirecting execution.<br />Pick a function that gets executed often:<br />- PeakMessageW in GUI programs,<br />- HeapAlloc in Console programs<br />and hook it.<br /><br />These functions get called pretty often, <br />so by hooking it and pointing to your Dll or loader shellcode<br />your injected DllMain will run and then you can restore function after.<br /><br />• <a href="https://www.unknowncheats.me/forum/2019041-post6.html">https://www.unknowncheats.me/forum/2019041-post6.html</a> - Mentioned<br />• <a href="https://github.com/btbd/smap/blob/28ab8fd1b4ae1c9419a84666d285ed48ed4d4afe/smap/hijack.cpp#L155">https://github.com/btbd/smap/blob/28ab8fd1b4ae1c9419a84666d285ed48ed4d4afe/smap/hijack.cpp#L155</a> - Example<br /><br /><h2>## IAT Hook</h2><br />Exactly like above but instead of writing bytes the function<br />you modify its address in the Import Address Table.<br />Now whenever the process calls PeakMessage, it will see the address of the your DllMain or loader shellcode<br />in the Import Address Table and execute that instead.<br />Once executed, restore the IAT.<br /><br /><strong>Links</strong><br />• <a href="https://www.unknowncheats.me/forum/2020905-post10.html">https://www.unknowncheats.me/forum/2020905-post10.html</a> - Mentioned here<br />• <a href="https://github.com/btbd/smap/blob/28ab8fd1b4ae1c9419a84666d285ed48ed4d4afe/smap/hijack.cpp#L63">https://github.com/btbd/smap/blob/28ab8fd1b4ae1c9419a84666d285ed48ed4d4afe/smap/hijack.cpp#L63</a> - Example</div>
</body>
</html>
