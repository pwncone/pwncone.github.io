<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Complete (with imports)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Manually Map DLL - Complete version with imports</h1></strong><br />• <a href="https://github.com/Zer0Mem0ry/ManualMap/blob/master/ManualInjector/ManualInjector.cpp">https://github.com/Zer0Mem0ry/ManualMap/blob/master/ManualInjector/ManualInjector.cpp</a><br />• <a href="https://github.com/hrt/ThreadJect-x64/blob/master/ThreadJect/main.cpp">https://github.com/hrt/ThreadJect-x64/blob/master/ThreadJect/main.cpp</a><br /><br />This is a more complete version of a DLL manual mapper.<br />It:<br />• loads the DLL into a local buffer<br />• allocates memory in the target process for the DLL<br />• memory maps the DLL into the target<br />• allocates memory in the target process for a <code>Loader()</code> function<br />• writes the <code>Loader()</code> function and the data it needs into the target<br />• starts execution at the <code>Loader()</code> function in the target using <code>CreateRemoteThread</code><br /><br />The Loader() function then:<br />• fixes the DLL&#39;s imports (and imports extra modules our DLL needs)<br />• performs base relocations<br />• and jumps to our injected DLL&#39;s <code>DllMain</code> function (at which point our injected DLL executes)<br /><br /><a href=""><img src="images/1648-1.png" alt="images/1648-1.png" /></a><br /><br /><strong><h2>## Demo</h2></strong><br />Here&#39;s the DLL I&#39;m injecting:<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved)<br /><span style="color:#000000;font-weight:400">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(fdwReason)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBoxA(NULL,&nbsp;&quot;hey!&nbsp;i&#39;m&nbsp;a&nbsp;DLL.&nbsp;i&#39;ve&nbsp;been&nbsp;attached&nbsp;:)&quot;,&nbsp;&quot;smile&quot;,&nbsp;MB_OK);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_ATTACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_THREAD_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DLL_PROCESS_DETACH:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />I&#39;m injecting into <code>Notepad</code> - which has a PID of 15204<br /><a href=""><img src="images/1648-2.png" alt="images/1648-2.png" /></a><br /><br />I&#39;ve run the injector from an Administrator PowerShell prompt.<br />We see our injected DLL&#39;s window saying hello!<br /><a href=""><img src="images/1648-3.png" alt="images/1648-3.png" /></a><br /><br /><strong><h2>## Code</h2></strong><br /><strong><h3>### Compiling</h3></strong><br />• Disable optimizations! It breaks the assembly code of the <code>Loader()</code> function that&#39;s injected into the target process<br />   ◇ In Visual Studio go to <code>Project -&gt; Properties -&gt; C/C++ -&gt; Optimization</code><br />   ◇ Set <code>Optimization</code> to <code>Disabled</code> and <code>Whole Program Optimization</code> to <code>No</code><br /><br /><strong><h3>### Problems</h3></strong><br />• This 32bit code doesn&#39;t work, the target program crashes. I haven&#39;t debugged why<br /><br /><strong><h3>### What you can inject</h3></strong><br />All architectures must match:<br />•  Use 64bit injector with 64bit DLL to inject into 64bit process<br /><br /><div class="codebox"><div class="codebox">/*<br />A&nbsp;DLL&nbsp;manual&nbsp;mapper.<br /><br />#&nbsp;About<br />This&nbsp;mapper&nbsp;writes&nbsp;the&nbsp;DLL&nbsp;to&nbsp;inject,&nbsp;a&nbsp;Loader()&nbsp;function,&nbsp;and&nbsp;data&nbsp;for&nbsp;the&nbsp;Loader()&nbsp;function&nbsp;into&nbsp;the&nbsp;target&nbsp;process.<br />Execution&nbsp;is&nbsp;then&nbsp;passed&nbsp;to&nbsp;the&nbsp;Loader()&nbsp;function&nbsp;using&nbsp;CreateRemoteThread().<br /><br />The&nbsp;Loader()&nbsp;function&nbsp;then&nbsp;runs&nbsp;in&nbsp;the&nbsp;target&nbsp;process,&nbsp;fixing&nbsp;our&nbsp;injected&nbsp;DLL&#39;s&nbsp;imports&nbsp;and&nbsp;performing&nbsp;base&nbsp;relocations.<br />When&nbsp;finished,&nbsp;it&nbsp;jumps&nbsp;to&nbsp;our&nbsp;injected&nbsp;DLL&#39;s&nbsp;DllMain().<br /><br />Because&nbsp;the&nbsp;Loader()&nbsp;function&nbsp;needs&nbsp;a&nbsp;few&nbsp;pieces&nbsp;of&nbsp;data&nbsp;to&nbsp;operate,&nbsp;like&nbsp;function&nbsp;addresses&nbsp;and&nbsp;the&nbsp;address&nbsp;of&nbsp;our&nbsp;injected&nbsp;DLL,<br />we&nbsp;store&nbsp;all&nbsp;this&nbsp;in&nbsp;a&nbsp;struct&nbsp;and&nbsp;write&nbsp;it&nbsp;into&nbsp;the&nbsp;target&nbsp;process&nbsp;so&nbsp;that&nbsp;the&nbsp;Loader()&nbsp;can&nbsp;access&nbsp;it.<br /><br />#&nbsp;Compiling<br />-&nbsp;Disable&nbsp;optimisations!&nbsp;It&nbsp;breaks&nbsp;the&nbsp;assembly&nbsp;code&nbsp;of&nbsp;the&nbsp;Loader()&nbsp;function&nbsp;that&#39;s&nbsp;injected&nbsp;into&nbsp;the&nbsp;target&nbsp;process<br />	-&nbsp;Project&nbsp;-&gt;&nbsp;Properties&nbsp;-&gt;&nbsp;C/C++&nbsp;-&gt;&nbsp;Optimization<br />	-&nbsp;Set&nbsp;`Optimization`&nbsp;to&nbsp;`Disabled`&nbsp;and&nbsp;`Whole&nbsp;Program&nbsp;Optimization`&nbsp;to&nbsp;`No`<br /><br />#&nbsp;What&nbsp;you&nbsp;can&nbsp;inject<br />All&nbsp;architectures&nbsp;must&nbsp;match:<br />-&nbsp;Use&nbsp;64bit&nbsp;injector&nbsp;with&nbsp;64bit&nbsp;DLL&nbsp;to&nbsp;inject&nbsp;into&nbsp;64bit&nbsp;process<br />-&nbsp;Use&nbsp;32bit&nbsp;injector&nbsp;with&nbsp;32bit&nbsp;DLL&nbsp;to&nbsp;inject&nbsp;into&nbsp;32bit&nbsp;process<br /><br />*/<br /><br />#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />typedef&nbsp;struct&nbsp;_INJECTED_DLL_INFO<br />{<br />	void*&nbsp;dll_base;<br />	void*&nbsp;LoadLibraryA_addr;<br />	void*&nbsp;GetProcAddress_addr;<br />	void*&nbsp;NtFlushInstructionCache_addr;<br />}&nbsp;INJECTED_DLL_INFO,&nbsp;*&nbsp;P_INJECTED_DLL_INFO;<br /><br />typedef&nbsp;HMODULE(__stdcall*&nbsp;t_LoadLibraryA)(LPCSTR&nbsp;lpLibFileName);<br />typedef&nbsp;FARPROC(__stdcall*&nbsp;t_GetProcAddress)(HMODULE&nbsp;hModule,&nbsp;LPCSTR&nbsp;lpProcName);<br />typedef&nbsp;DWORD(NTAPI*&nbsp;t_NtFlushInstructionCache)(IN&nbsp;HANDLE&nbsp;ProcessHandle,&nbsp;IN&nbsp;PVOID&nbsp;BaseAddress,&nbsp;IN&nbsp;ULONG&nbsp;NumberOfBytesToFlush);<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_DllMain)(HINSTANCE&nbsp;hinstDLL,&nbsp;DWORD&nbsp;fdwReason,&nbsp;LPVOID&nbsp;lpReserved);<br /><br />/*<br />Make&nbsp;sure&nbsp;to&nbsp;call&nbsp;free(file_buffer)&nbsp;after&nbsp;you&#39;re&nbsp;done.<br />*/<br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Loader&nbsp;function&nbsp;that&nbsp;is&nbsp;to&nbsp;be&nbsp;written&nbsp;into&nbsp;the&nbsp;target&nbsp;process.<br />It&nbsp;fixes&nbsp;the&nbsp;DLL&#39;s&nbsp;imports,&nbsp;performs&nbsp;base&nbsp;relocations,&nbsp;and&nbsp;executes&nbsp;our&nbsp;injected&nbsp;DLL&#39;s&nbsp;DllMain().<br />This&nbsp;function&nbsp;will&nbsp;be&nbsp;called&nbsp;inside&nbsp;of&nbsp;the&nbsp;target&nbsp;process,&nbsp;at&nbsp;which&nbsp;point&nbsp;the&nbsp;DLL&nbsp;will&nbsp;be&nbsp;mapped,&nbsp;so&nbsp;this&nbsp;function&nbsp;uses&nbsp;VirtualAddresses.<br /><br />NOTE:<br />-&nbsp;You&nbsp;can&#39;t&nbsp;use&nbsp;functions&nbsp;in&nbsp;this&nbsp;code&nbsp;because&nbsp;it&nbsp;won&#39;t&nbsp;know&nbsp;the&nbsp;location/addresses&nbsp;of&nbsp;these&nbsp;functions<br />-&nbsp;Any&nbsp;functions&nbsp;you&nbsp;use&nbsp;have&nbsp;to&nbsp;be&nbsp;used&nbsp;dynamically&nbsp;(this&nbsp;is&nbsp;why&nbsp;we&nbsp;pass&nbsp;the&nbsp;address&nbsp;of&nbsp;any&nbsp;functions&nbsp;we&nbsp;need&nbsp;in&nbsp;the&nbsp;struct&nbsp;`loader_info`&nbsp;paramter)<br /><br />Parameters:<br />	`loader_info`&nbsp;-&nbsp;a&nbsp;pointer&nbsp;TO&nbsp;the&nbsp;INJECTED_DLL_INFO&nbsp;struct&nbsp;in&nbsp;the&nbsp;target&nbsp;process<br />*/<br />__declspec(noinline)&nbsp;void*&nbsp;__stdcall&nbsp;DllLoader(void*&nbsp;ldr_info)<br />{<br />	P_INJECTED_DLL_INFO&nbsp;ldr_data&nbsp;=&nbsp;(P_INJECTED_DLL_INFO)ldr_info;<br /><br />	t_LoadLibraryA&nbsp;p_LoadLibraryA&nbsp;=&nbsp;(t_LoadLibraryA)ldr_data-&gt;LoadLibraryA_addr;<br />	t_GetProcAddress&nbsp;p_GetProcAddress&nbsp;=&nbsp;(t_GetProcAddress)ldr_data-&gt;GetProcAddress_addr;<br />	t_NtFlushInstructionCache&nbsp;p_NtFlushInstructionCache&nbsp;=&nbsp;(t_NtFlushInstructionCache)ldr_data-&gt;NtFlushInstructionCache_addr;<br />	t_DllMain&nbsp;p_DllMain&nbsp;=&nbsp;NULL;<br /><br />	/*<br />	#&nbsp;Step&nbsp;1<br />	Import&nbsp;other&nbsp;DLLs&nbsp;required&nbsp;by&nbsp;injected&nbsp;DLL.<br />	*/<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)ldr_data-&gt;dll_base;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)dos_header&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;import_dir&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);<br />	PIMAGE_THUNK_DATA&nbsp;lookup_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;addr_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_BY_NAME&nbsp;import_name&nbsp;=&nbsp;NULL;<br /><br />	HMODULE&nbsp;h_dll&nbsp;=&nbsp;NULL;<br />	FARPROC&nbsp;import_addr&nbsp;=&nbsp;NULL;<br />	ULONGLONG&nbsp;import_ordinal&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;DLLs&nbsp;in&nbsp;import&nbsp;directory&nbsp;&amp;&nbsp;load&nbsp;them<br />	while&nbsp;(import_dir-&gt;Name&nbsp;!=&nbsp;0)<br />	{<br />		char*&nbsp;dll_name&nbsp;=&nbsp;(char*)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;import_dir-&gt;Name);<br />		h_dll&nbsp;=&nbsp;p_LoadLibraryA(dll_name);<br />		if&nbsp;(h_dll&nbsp;==&nbsp;NULL)<br />			return&nbsp;0;<br /><br />		lookup_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;import_dir-&gt;OriginalFirstThunk);<br />		addr_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;import_dir-&gt;FirstThunk);<br /><br />		//&nbsp;Loop&nbsp;through&nbsp;functions&nbsp;in&nbsp;lookup&nbsp;table&nbsp;in&nbsp;DLL,&nbsp;get&nbsp;the&nbsp;function&#39;s&nbsp;address,&nbsp;and&nbsp;write&nbsp;address&nbsp;into&nbsp;the&nbsp;Import&nbsp;Address&nbsp;Table<br />		while&nbsp;(lookup_table-&gt;u1.AddressOfData&nbsp;!=&nbsp;0)<br />		{<br />			if&nbsp;(IMAGE_SNAP_BY_ORDINAL(lookup_table-&gt;u1.Ordinal))<br />			{<br />				import_ordinal&nbsp;=&nbsp;IMAGE_ORDINAL(lookup_table-&gt;u1.Ordinal);<br />				import_addr&nbsp;=&nbsp;p_GetProcAddress(h_dll,&nbsp;(LPCSTR)import_ordinal);<br /><br />				addr_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_addr;<br />			}<br />			else<br />			{<br />				import_name&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;lookup_table-&gt;u1.AddressOfData);<br />				import_addr&nbsp;=&nbsp;p_GetProcAddress(h_dll,&nbsp;import_name-&gt;Name);<br /><br />				addr_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_addr;<br />			}<br /><br />			lookup_table++;<br />			addr_table++;<br />		}<br /><br />		import_dir++;<br />	}<br /><br />	/*<br />	#&nbsp;Step&nbsp;2<br />	Perform&nbsp;DLL&nbsp;base&nbsp;relocations.<br />	*/<br />	size_t&nbsp;delta&nbsp;=&nbsp;(size_t)ldr_data-&gt;dll_base&nbsp;-&nbsp;(size_t)pe_header-&gt;OptionalHeader.ImageBase;<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_table&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br />	PIMAGE_BASE_RELOCATION&nbsp;reloc_block&nbsp;=&nbsp;reloc_table;<br />	DWORD&nbsp;table_size&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br /><br />	DWORD&nbsp;entries_in_block&nbsp;=&nbsp;0;<br />	DWORD&nbsp;table_position&nbsp;=&nbsp;0;<br />	PBASE_RELOCATION_ENTRY&nbsp;reloc_entry&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;blocks&nbsp;in&nbsp;relocation&nbsp;table<br />	while&nbsp;(table_position&nbsp;&lt;&nbsp;table_size)<br />	{<br />		entries_in_block&nbsp;=&nbsp;(reloc_block-&gt;SizeOfBlock&nbsp;-&nbsp;sizeof(IMAGE_BASE_RELOCATION))&nbsp;/&nbsp;sizeof(WORD);<br />		reloc_entry&nbsp;=&nbsp;(PBASE_RELOCATION_ENTRY)(reloc_block&nbsp;+&nbsp;1);<br /><br />		for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;entries_in_block;&nbsp;i++)<br />		{<br />			void*&nbsp;reloc_addr&nbsp;=&nbsp;(void*)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;reloc_block-&gt;VirtualAddress&nbsp;+&nbsp;reloc_entry-&gt;Offset);<br /><br />			if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGH)<br />				*(WORD*)((size_t)reloc_addr&nbsp;+&nbsp;0x2)&nbsp;+=&nbsp;HIWORD(delta);	//&nbsp;add&nbsp;higher&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;higher&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_LOW)<br />				*(WORD*)reloc_addr&nbsp;+=&nbsp;LOWORD(delta);					//&nbsp;add&nbsp;lower&nbsp;16&nbsp;bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;lower&nbsp;16&nbsp;bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_HIGHLOW)<br />				*(DWORD*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;32bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;32bits&nbsp;at&nbsp;relocation&nbsp;address<br />			else&nbsp;if&nbsp;(reloc_entry-&gt;Type&nbsp;==&nbsp;IMAGE_REL_BASED_DIR64)<br />				*(DWORD64*)reloc_addr&nbsp;+=&nbsp;delta;							//&nbsp;add&nbsp;all&nbsp;64bits&nbsp;of&nbsp;delta&nbsp;to&nbsp;the&nbsp;64bits&nbsp;at&nbsp;relocation&nbsp;address<br /><br />			reloc_entry&nbsp;+=&nbsp;1;<br />		}<br /><br />		//&nbsp;Advance&nbsp;to&nbsp;next&nbsp;block<br />		table_position&nbsp;+=&nbsp;reloc_block-&gt;SizeOfBlock;<br />		reloc_block&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((size_t)reloc_block&nbsp;+&nbsp;reloc_block-&gt;SizeOfBlock);<br />	}<br /><br />	/*<br />	#&nbsp;Step&nbsp;3<br />	Execute&nbsp;manually&nbsp;mapped&nbsp;DLL.<br />	*/<br />	void*&nbsp;dll_entrypoint&nbsp;=&nbsp;(void*)((size_t)ldr_data-&gt;dll_base&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint);<br />	p_DllMain&nbsp;=&nbsp;(t_DllMain)dll_entrypoint;<br /><br />	p_NtFlushInstructionCache((HANDLE)-1,&nbsp;NULL,&nbsp;0);<br />	p_DllMain((HINSTANCE)ldr_data-&gt;dll_base,&nbsp;DLL_PROCESS_ATTACH,&nbsp;NULL);<br /><br />	return&nbsp;dll_entrypoint;<br />}<br /><br />/*<br />Spawns&nbsp;a&nbsp;process,&nbsp;manually&nbsp;maps&nbsp;a&nbsp;DLL&nbsp;into&nbsp;it,&nbsp;writes&nbsp;a&nbsp;Loader()&nbsp;function&nbsp;into&nbsp;the&nbsp;process,<br />and&nbsp;then&nbsp;creates&nbsp;a&nbsp;new&nbsp;thread&nbsp;at&nbsp;the&nbsp;Loader()&nbsp;function&nbsp;to&nbsp;load&nbsp;the&nbsp;mapped&nbsp;DLL&nbsp;and&nbsp;all&nbsp;its&nbsp;dependencies.<br /><br />DOWNSIDE:<br />The&nbsp;spawned&nbsp;target&nbsp;process&nbsp;will&nbsp;remain&nbsp;after&nbsp;the&nbsp;DLL&nbsp;has&nbsp;exited.<br />*/<br />BOOL&nbsp;ManuallyMapDLL(void*&nbsp;dll_buffer,&nbsp;int&nbsp;target_pid)<br />{<br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br /><br />	//&nbsp;Create&nbsp;process&nbsp;&amp;&nbsp;map&nbsp;DLL&nbsp;into&nbsp;target<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_buffer;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)dll_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	LPVOID&nbsp;dll_base&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_process&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_thread&nbsp;=&nbsp;NULL;<br /><br />	h_process&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;target_pid);<br />	if&nbsp;(h_process&nbsp;==&nbsp;NULL)<br />	{<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;[+]&nbsp;opened&nbsp;PID:&nbsp;%d&nbsp;\n&quot;,&nbsp;target_pid);<br /><br />	dll_base&nbsp;=&nbsp;VirtualAllocEx(h_process,&nbsp;NULL,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(dll_base&nbsp;==&nbsp;NULL)<br />	{<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;[+]&nbsp;allocated&nbsp;memory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_base);<br /><br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_process,&nbsp;dll_base,&nbsp;dll_buffer,&nbsp;pe_header-&gt;OptionalHeader.SizeOfHeaders,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		VirtualFreeEx(h_process,&nbsp;dll_base,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_RELEASE);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;[+]&nbsp;wrote&nbsp;PE&nbsp;headers&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_base);<br /><br />	printf(&quot;[*]&nbsp;sections&nbsp;\n&quot;);<br />	LPVOID&nbsp;section_addr&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;write_addr&nbsp;=&nbsp;NULL;<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		section_addr&nbsp;=&nbsp;(LPVOID)((SIZE_T)dll_buffer&nbsp;+&nbsp;section_header-&gt;PointerToRawData);<br />		write_addr&nbsp;=&nbsp;(LPVOID)((SIZE_T)dll_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br /><br />		b_ret&nbsp;=&nbsp;WriteProcessMemory(h_process,&nbsp;write_addr,&nbsp;section_addr,&nbsp;section_header-&gt;SizeOfRawData,&nbsp;0);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		{<br />			VirtualFreeEx(h_process,&nbsp;dll_base,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_RELEASE);<br />			ok&nbsp;=&nbsp;FALSE;<br />			goto&nbsp;cleanup;<br />		}<br />		printf(&quot;\t&nbsp;+&nbsp;wrote&nbsp;%s&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;section_header-&gt;Name,&nbsp;write_addr);<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	//&nbsp;Write&nbsp;DllLoader&nbsp;function&nbsp;and&nbsp;info&nbsp;struct&nbsp;into&nbsp;target&nbsp;process<br />	LPVOID&nbsp;ldr_struct&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;ldr_func&nbsp;=&nbsp;NULL;<br />	INJECTED_DLL_INFO&nbsp;ldr_info&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	ldr_info.dll_base&nbsp;=&nbsp;dll_base;<br />	ldr_info.LoadLibraryA_addr&nbsp;=&nbsp;(t_LoadLibraryA)GetProcAddress(LoadLibraryA(&quot;Kernel32.dll&quot;),&nbsp;&quot;LoadLibraryA&quot;);<br />	ldr_info.GetProcAddress_addr&nbsp;=&nbsp;(t_GetProcAddress)GetProcAddress(LoadLibraryA(&quot;Kernel32.dll&quot;),&nbsp;&quot;GetProcAddress&quot;);<br />	ldr_info.NtFlushInstructionCache_addr&nbsp;=&nbsp;(t_NtFlushInstructionCache)GetProcAddress(LoadLibraryA(&quot;Ntdll.dll&quot;),&nbsp;&quot;NtFlushInstructionCache&quot;);<br /><br />	ldr_struct&nbsp;=&nbsp;VirtualAllocEx(h_process,&nbsp;NULL,&nbsp;4096,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(ldr_struct&nbsp;==&nbsp;NULL)<br />	{<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;[*]&nbsp;allocated&nbsp;space&nbsp;for&nbsp;DllLoader&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ldr_struct);<br /><br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_process,&nbsp;ldr_struct,&nbsp;&amp;ldr_info,&nbsp;sizeof(ldr_info),&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		VirtualFreeEx(h_process,&nbsp;dll_base,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_RELEASE);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;+&nbsp;wrote&nbsp;ldr_struct&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ldr_struct);<br /><br />	ldr_func&nbsp;=&nbsp;(LPVOID)((size_t)ldr_struct&nbsp;+&nbsp;sizeof(ldr_info));<br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(h_process,&nbsp;ldr_func,&nbsp;&amp;DllLoader,&nbsp;4096&nbsp;-&nbsp;sizeof(ldr_info),&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		VirtualFreeEx(h_process,&nbsp;dll_base,&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_RELEASE);<br />		ok&nbsp;=&nbsp;FALSE;<br />		goto&nbsp;cleanup;<br />	}<br />	printf(&quot;\t&nbsp;+&nbsp;wrote&nbsp;ldr_func&nbsp;to&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ldr_func);<br /><br />	//&nbsp;Execute&nbsp;DllLoader&nbsp;function&nbsp;in&nbsp;target&nbsp;proc&nbsp;(which&nbsp;relocate&nbsp;&amp;&nbsp;load&nbsp;our&nbsp;DLL)<br />	h_thread&nbsp;=&nbsp;CreateRemoteThread(h_process,&nbsp;NULL,&nbsp;0,&nbsp;(LPTHREAD_START_ROUTINE)ldr_func,&nbsp;ldr_struct,&nbsp;0,&nbsp;NULL);<br />	printf(&quot;[*]&nbsp;started&nbsp;remote&nbsp;thread&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;ldr_func);<br /><br />cleanup:<br />	if&nbsp;(h_process)&nbsp;CloseHandle(h_process);<br />	if&nbsp;(h_thread)&nbsp;CloseHandle(h_thread);<br /><br />	return&nbsp;ok;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	printf(&quot;#&nbsp;dll&nbsp;manual&nbsp;mapper&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;Manually&nbsp;maps&nbsp;a&nbsp;DLL&nbsp;into&nbsp;a&nbsp;target&nbsp;process&nbsp;and&nbsp;calls&nbsp;DllMain&nbsp;\n&quot;);<br />	printf(&quot;-&nbsp;advise&nbsp;running&nbsp;as&nbsp;Adminstrator&nbsp;\n&quot;);<br />	printf(&quot;\n&quot;);<br /><br />	if&nbsp;(argc&nbsp;!=&nbsp;3)<br />	{<br />		printf(&quot;[-]&nbsp;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;manual_mapper.exe&nbsp;[target&nbsp;pid]&nbsp;[dll&nbsp;path]&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	int&nbsp;target_pid&nbsp;=&nbsp;atoi(argv[1]);<br />	char*&nbsp;dll_path&nbsp;=&nbsp;argv[2];<br /><br />	printf(&quot;[*]&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;target_pid);<br />	printf(&quot;[*]&nbsp;dll&nbsp;to&nbsp;inject:&nbsp;%s&nbsp;\n\n&quot;,&nbsp;dll_path);<br /><br />	LPVOID&nbsp;dll_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;dll_buffer_size&nbsp;=&nbsp;0;<br />	dll_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(dll_path,&nbsp;&amp;dll_buffer_size);<br />	if&nbsp;(dll_buffer&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;DLL&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	ManuallyMapDLL(dll_buffer,&nbsp;target_pid);<br />		<br />cleanup:<br />	if&nbsp;(dll_buffer)&nbsp;free(dll_buffer);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>
</body>
</html>
