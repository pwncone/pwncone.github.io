<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Inline Hooking</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># x64 Inline Hooking</h1></strong><br /><strong>Links</strong><br />• <a href="http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html">http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html</a><br /><br /><strong>Examples</strong><br />• <a href="https://www.unknowncheats.me/forum/1223255-post2.html">https://www.unknowncheats.me/forum/1223255-post2.html</a> - Always uses 14 bytes. No length disassembler.<br />• <a href="https://www.unknowncheats.me/forum/c-and-c/134871-64-bit-detour-function.html">https://www.unknowncheats.me/forum/c-and-c/134871-64-bit-detour-function.html</a> - Uses length disassembler<br /><br />x64 inline hooking has a few more difficulties with it than x86,<br />and is therfore mostly about choosing the right hook method for the function you&#39;re trying to hook.<br />For techniques, refer to Hook Methods &gt; x64<br /><br />For examples of x64 inline hooking,<br />refer to the sub nodes here.<br /><br /><strong><h2>## The difficulties of x64</h2></strong><br /><strong><h3>### You can&#39;t rely on E9 jmp relative anymore</h3></strong><br />The classic technique in 32bit hooking is to a use a 5 byte <code>E9</code> jmp relative instruction to jump to the trampoline space. From the trampoline space, you can then jump to the hook code.<br /><br />However, the jmp relative instruction is limited to a + or - 2GB range.<br />On 32bit this isn&#39;t a problem, as 4GB covers the entire available address space on 32bit machines.<br />But on 64bit machines, the address of our trampoline or hook code might be more than 2GB away from the target function we&#39;re hooking, so an <code>E9</code> jmp relative instruction won&#39;t jump far enough to get us there.<br /><br />Therefore, it&#39;s only possible to use an E9 jump on x64 if you can find free memory <br />within a + or - 2GB range from your target function&#39;s address.<br /><br />Refer here for a function to find free memory within a 2gb range:<br /><a href="Malware_Dev--Windows--Kernel_land--About--Basics--Notifications.html">Useful &gt; Find Memory within 2gb</a><br /><br />If you find free memory within a 2gb range,<br />you could assign trampoline space there and jump to where to wherever you want.<br /><br /><strong><h3>### Function prologue code varies in length</h3></strong><br />On x64, the function prologue code for different functions varies quite a bit.<br />This is well explanied here:<br /><a href="https://www.codeproject.com/articles/44326/minhook-the-minimalistic-x-x-api-hooking-libra">https://www.codeproject.com/articles/44326/minhook-the-minimalistic-x-x-api-hooking-libra</a> <br />at the <em>Building the Trampoline Function</em> heading.<br /><br />For example:<br />Here&#39;s user32.dll&#39;s <strong>MessageBoxA on x64</strong><br /><a href=""><img src="images/1681-1.png" alt="images/1681-1.png" /></a><br /><br />A lot of the functions in kernel32.dll are jumps, but they vary in length.<br />Here&#39;s kernel32.dll&#39;s <strong>IsProcessorFeaturePresent on x64</strong><br /><a href=""><img src="images/1681-2.png" alt="images/1681-2.png" /></a><br /><br />Here&#39;s kernel32.dll&#39;s <strong>CreateFileA on x64</strong><br /><a href=""><img src="images/1681-3.png" alt="images/1681-3.png" /></a><br /><br />Here&#39;s kernel32.dll&#39;s <strong>GetCurrentProcessId on x64</strong><br /><a href=""><img src="images/1681-4.png" alt="images/1681-4.png" /></a><br /><br />You get the idea.<br /><br />The solution is to use a disassembler.<br /><br />You can build hooks without a disassembler,<br />but you will have to craft and check that the hook works for each individual hook you install.<br />For example:<br />• <a href="https://www.unknowncheats.me/forum/1223255-post2.html">https://www.unknowncheats.me/forum/1223255-post2.html</a><br /><br />With a disassembler, you can analyse the instructions at the function <br />and build a hook according to the bytes at the original function<br />e.g. fill extra bytes with NOPs, fix relative addresses in your trampoline, etc.<br /><br />This is well explanied here under the <em>Code Relocation</em> heading<br /><a href="https://www.codeproject.com/Articles/1100579/PolyHook-The-Cplusplus-x-x-Hooking-Library">https://www.codeproject.com/Articles/1100579/PolyHook-The-Cplusplus-x-x-Hooking-Library</a><br /><br />Examples of using a disassembler:<br />• <a href="https://www.unknowncheats.me/forum/c-and-c/134871-64-bit-detour-function.html">https://www.unknowncheats.me/forum/c-and-c/134871-64-bit-detour-function.html</a> - Uses BeaEngine to chech instructions length<br />• <a href="https://github.com/TsudaKageyu/minhook">https://github.com/TsudaKageyu/minhook</a> - Uses hde64<br />• <a href="https://github.com/stevemk14ebr/PolyHook_2_0">https://github.com/stevemk14ebr/PolyHook_2_0</a> - Uses Capstone<br /></div>
</body>
</html>
