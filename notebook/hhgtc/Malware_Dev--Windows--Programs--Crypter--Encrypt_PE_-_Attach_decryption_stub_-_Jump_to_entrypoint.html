<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Encrypt PE -> Attach decryption stub -> Jump to entrypoint</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Encrypt PE -&gt; Attach decryption stub -&gt; Jump to entrypoint</h1></strong><br /><br /><strong><h2>## Before Reading</h2></strong><br /><strong><span style="text-decoration:underline;">With this method, as far as I know,<br />you can only encrypt the .text and .data sections.</span></strong><br /><br />If you encrypt sections other than those 2, <br />when trying to run the .exe Windows will spit out an error:<br />&quot;The specified executable is <em>not</em> a <em>valid</em> application for this OS platform&quot;<br /><br />The same thing happens in Bill Blunden&#39;s source code crypter.<br />He only encrypts the .text and .data sections.<br /><br /><strong>I think this happens</strong> <strong>because</strong><br />if the .rdata section, which contains the import directory, is present but can&#39;t be read<br />then the Windows loader will fail to load the PE and will therefore deem it not valid for the platform.<br />The same I&#39;m guessing with the .reloc section - if it&#39;s present but can&#39;t read it the PE won&#39;t load.<br /><br />PE files without these sections run fine, e.g. just a .text section,<br />which is why I&#39;m guessing if the sections are present but can&#39;t read<br />then the Windows loader will fail.<br /><br /><strong>I&#39;m not 100% sure,</strong><br />but this is my best guess as to why we can only encrypt the .text and .data sections.<br />It&#39;s HIGHLY probably you can encrypt more, anything is possible,<br />but I don&#39;t know enough to figure that out.<br /><br /><strong><h2>## About</h2></strong><br />This is a fairly simple technique in principle,<br />but the execution is a little difficult.<br /><br />You encrypt the <code>.text</code> and <code>.data</code> sections of the original PE and attach a decryption stub.<br />The decryption stub will then decrypt those 2 sections at runtime and jump to the entrypoint in <code>.text</code>.<br /><br />Because the <code>.rdata</code> section isn&#39;t encrypted,<br />the original PE&#39;s imports will be visible (bit of a downside).<br /><br />Here&#39;s a diagram of the PE file:<br /><a href=""><img src="images/1876-1.png" alt="images/1876-1.png" /></a><br /><br />Here&#39;s what a final crypted PE file looks like in CFF Explorer.<br />The <code>.text</code> and <code>.data</code> sections have been encrypted,<br />and the <code>.stub</code> section is appended to the end.<br /><a href=""><img src="images/1876-2.png" alt="images/1876-2.png" /></a><br /><br />And the entry point has been set to the <code>.stub</code> section.<br /><a href=""><img src="images/1876-3.png" alt="images/1876-3.png" /></a><br /><br /><strong><h2>## Code &amp; Explanation</h2></strong><br /><strong><h3>### hello.exe</h3></strong><br />Here&#39;s the program I&#39;ll be encrypting and attaching a decryption stub to.<br />It spawns a simple message box.<br />I don&#39;t need to do anything special to this file, it&#39;s been compiled as normal.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;Windows.h&gt;<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	MessageBoxA(NULL,&nbsp;&quot;Hello&nbsp;world!&quot;,&nbsp;&quot;:)&quot;,&nbsp;MB_OK);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### .stub</h3></strong><br />Here&#39;s the decryption stub.<br />This code is designed to be (close to) position independent shellcode.<br />As in, it&#39;s code that can run on its own, at any location, and doesn&#39;t have any imports or relocations.<br /><br /><strong>Compiler Options</strong><br />Because I only want the .text section of this program (the actual code/shellcode),<br />I&#39;ve disabled the CRT (C RunTime) so there&#39;s no startup code.<br />As a result, this program jumps straight to executing my entrypoint function but has quite a few compiler options set.<br /><a href="https://stackoverflow.com/questions/39217241/visual-studio-2015-compile-c-c-without-a-runtime-library">https://stackoverflow.com/questions/39217241/visual-studio-2015-compile-c-c-without-a-runtime-library</a><br />By not using the CRT, you can&#39;t use function names like <code>main()</code> or <code>WinMain()</code>. Choose something else.<br /><br />Compile as <code>Release</code>.<br />In your Visual Studio Compiler settings:<br />• <code>Linker</code> settings:<br />   ◇ Advanced -&gt; Entrypoint -&gt; something other than main/wmain/WinMain etc. (e.g. <code>tinymain</code>)<br />      ▪ so it doesn&#39;t try to find main() and execute<br />   ◇ Input -&gt; Ignore All Default Libraries -&gt; YES<br />      ▪ don&#39;t include CRT<br />   ◇ Manifest File &gt; Generate Manifest &gt; No (/MANIFEST:NO)<br />      ▪ gets rid of the &lt;xml content in .rsrc section (results in no .rsrc section)<br />   ◇ Optimization &gt; References &gt; No(/OPT:NOREF)<br />   ◇ Optimization &gt; Link Time Code Generator &gt; /LTCG<br />      ▪ /OPT:NOREF and /LTCG helps remove debug directory<br />   ◇ Op<br />   ◇ Command Line &gt; Additional Options<br />      ▪ <code>/DEBUG:NONE /EMITPOGOPHASEINFO</code><br />      ▪ These 2 options together remove the debug data from the Debug Directory in .rdata<br />      ▪ <code>/NOCOFFGRPINFO</code>  with /OPT:NOREF and /LTCG removes the TimeDateStamp from the Debug Directory<br />• <code>C/C++</code> Compiler settings:<br />   ◇ Code Generation -&gt; Runtime Library -&gt; /MT<br />      ▪ use the multithread, static version of the run-time library<br />   ◇ Code Generation -&gt; /GS- (off)<br />      ▪ CRT does buffer overflow checks. Disable them<br />   ◇ Advanced -&gt; Compile As -&gt; /TC (only if you’re using C and not C++)<br />   ◇ All Options -&gt; Basic Runtime Checks -&gt; Default<br />      ▪ CRT does runtime checks e.g. <code>__RTC__CheckESP</code> - want to disable these<br /><br />My 32bit compiled stub looks like this:<br /><a href=""><img src="images/1876-4.png" alt="images/1876-4.png" /></a><br /><br />And my 64bit compiled stub looks like this:<br />(I don&#39;t know how to get rid of the Exception Directory)<br /><a href=""><img src="images/1876-5.png" alt="images/1876-5.png" /></a><br /><br />To grab just the code,<br />dump the <code>.text</code> section in CFF Explorer.<br />Our builder will then read this dumped .text code and attach it as a .stub section to the target PE.<br /><a href=""><img src="images/1876-6.png" alt="images/1876-6.png" /></a><br /><br /><strong>Code</strong><br />There&#39;s 1 hardcoded addresses in this code - <code>0x12C4</code> - down at the <code>void* entrypoint</code> calculation.<br /><code>0x12C4</code> is the entrypoint of the original encrypted PE.<br /><a href=""><img src="images/1876-7.png" alt="images/1876-7.png" /></a><br /><br />THIS VALUE WILL NEED CHANGING.<br />Change it to the AddressOfEntryPoint of the PE you&#39;re encrypting.<br /><br /><div class="codebox"><div class="codebox">/*<br />Decryption&nbsp;stub&nbsp;which&nbsp;decrypts&nbsp;and&nbsp;loads&nbsp;PE.<br />Designed&nbsp;to&nbsp;be&nbsp;position&nbsp;independent.<br />To&nbsp;be&nbsp;added&nbsp;as&nbsp;a&nbsp;section&nbsp;to&nbsp;an&nbsp;encrypted&nbsp;PE&nbsp;file.<br />Compile&nbsp;without&nbsp;C-runtime:&nbsp;<br />https://stackoverflow.com/questions/39217241/visual-studio-2015-compile-c-c-without-a-runtime-library<br /><br />Hash&nbsp;functions&nbsp;are&nbsp;used&nbsp;to&nbsp;compare&nbsp;strings&nbsp;because&nbsp;strcmp()&nbsp;is&nbsp;unavailable<br />(it&#39;s&nbsp;an&nbsp;external&nbsp;library&nbsp;-&nbsp;stdlib&nbsp;-&nbsp;which&nbsp;we&nbsp;can&#39;t&nbsp;use).<br />*/<br /><br />#define&nbsp;WIN32_LEAN_AND_MEAN<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br />#include&nbsp;&lt;intrin.h&gt;<br /><br />#include&nbsp;&quot;stub.h&quot;<br /><br />//&nbsp;Typedefs&nbsp;of&nbsp;functions&nbsp;we&nbsp;need&nbsp;in&nbsp;our&nbsp;stub<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_VirtualProtect)(LPVOID&nbsp;lpAddress,&nbsp;SIZE_T&nbsp;dwSize,&nbsp;DWORD&nbsp;flNewProtect,&nbsp;PDWORD&nbsp;lpflOldProtect);<br />typedef&nbsp;int(WINAPI*&nbsp;t_CRTmain)();<br /><br />//&nbsp;Undocumented&nbsp;struct&nbsp;for&nbsp;base&nbsp;relocations<br />typedef&nbsp;struct&nbsp;BASE_RELOCATION_ENTRY<br />{<br />	USHORT&nbsp;Offset&nbsp;:&nbsp;12;<br />	USHORT&nbsp;Type&nbsp;:&nbsp;4;<br />}&nbsp;BASE_RELOCATION_ENTRY,&nbsp;*&nbsp;PBASE_RELOCATION_ENTRY;<br /><br />/*<br />Hash&nbsp;functions<br />and&nbsp;hahes&nbsp;of&nbsp;paths/function&nbsp;names.<br />*/<br />#define&nbsp;HASH_KEY						13<br />#define&nbsp;hash_text_section				0xebc2f9b4		//&nbsp;&quot;.text&quot;<br />#define&nbsp;hash_data_section				0xcba2f8a1		//&nbsp;&quot;.data&quot;<br />#define&nbsp;hash_Kernel32path				0x90F5112C		//&nbsp;L&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;<br />#define&nbsp;hash_VirtualProtect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x7946C61B		//&nbsp;&quot;VirtualProtect&quot;<br /><br />//&nbsp;Hash&nbsp;functions<br />#pragma&nbsp;intrinsic(&nbsp;_rotr&nbsp;)<br />__forceinline&nbsp;DWORD&nbsp;ror(DWORD&nbsp;d)<br />{<br />	return&nbsp;_rotr(d,&nbsp;HASH_KEY);<br />}<br /><br />__forceinline&nbsp;DWORD&nbsp;hashA(char*&nbsp;c)<br />{<br />	register&nbsp;DWORD&nbsp;h&nbsp;=&nbsp;0;<br />	do<br />	{<br />		h&nbsp;=&nbsp;ror(h);<br />		h&nbsp;+=&nbsp;*c;<br />	}&nbsp;while&nbsp;(*++c);<br /><br />	return&nbsp;h;<br />}<br /><br />__forceinline&nbsp;DWORD&nbsp;hashW(wchar_t*&nbsp;c)<br />{<br />	register&nbsp;DWORD&nbsp;h&nbsp;=&nbsp;0;<br />	do<br />	{<br />		h&nbsp;=&nbsp;ror(h);<br />		h&nbsp;+=&nbsp;*c;<br />	}&nbsp;while&nbsp;(*++c);<br /><br />	return&nbsp;h;<br />}<br /><br />#pragma&nbsp;intrinsic(_ReturnAddress)<br />__declspec(noinline)&nbsp;ULONG_PTR&nbsp;GetCurrentAddress(void)<br />{<br />	return&nbsp;(ULONG_PTR)_ReturnAddress();<br />}<br /><br />//&nbsp;Entrypoint<br />void&nbsp;stub(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	/*<br />	#&nbsp;Step&nbsp;1&nbsp;<br />	Locate&nbsp;Kernel32.dll&nbsp;in&nbsp;host&nbsp;PE&nbsp;<br />	so&nbsp;we&nbsp;can&nbsp;grab&nbsp;the&nbsp;functions&nbsp;we&nbsp;need&nbsp;from&nbsp;it.<br />	*/<br />	void*&nbsp;k32_base&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;Grab&nbsp;process&nbsp;PEB<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br />	<br />	//&nbsp;Grab&nbsp;list&nbsp;of&nbsp;loaded&nbsp;DLLs,&nbsp;grab&nbsp;first&nbsp;DLL,&nbsp;and&nbsp;loop&nbsp;through&nbsp;DLLs<br />	PLIST_ENTRY&nbsp;dll_list&nbsp;=&nbsp;(PLIST_ENTRY)&amp;p_peb-&gt;Ldr-&gt;InMemoryOrderModuleList;<br />	PLIST_ENTRY&nbsp;dll_entry&nbsp;=&nbsp;dll_list-&gt;Flink;<br />	while&nbsp;(dll_list&nbsp;!=&nbsp;dll_entry)<br />	{<br />		//&nbsp;Grab&nbsp;DLL&nbsp;and&nbsp;hash<br />		PLDR_DATA_TABLE_ENTRY&nbsp;module&nbsp;=&nbsp;CONTAINING_RECORD(dll_entry,&nbsp;LDR_DATA_TABLE_ENTRY,&nbsp;InMemoryOrderLinks);<br />		DWORD&nbsp;hashed_dll&nbsp;=&nbsp;hashW(module-&gt;FullDllName.Buffer);<br />		if&nbsp;(hashed_dll&nbsp;==&nbsp;hash_Kernel32path)<br />		{<br />			k32_base&nbsp;=&nbsp;module-&gt;DllBase;<br />			break;<br />		}<br />		<br />		dll_entry&nbsp;=&nbsp;dll_entry-&gt;Flink;<br />	}<br /><br />	/*<br />	#&nbsp;Step&nbsp;2<br />	Loop&nbsp;through&nbsp;kernel32&nbsp;exports&nbsp;to&nbsp;grab&nbsp;function&nbsp;address&nbsp;of&nbsp;VirtualProtect<br />	(we&nbsp;need&nbsp;ti&nbsp;to<br />	LoadLibraryA,&nbsp;GetProcAddress,&nbsp;and&nbsp;VirtualProtect.<br />	*/<br />	t_VirtualProtect&nbsp;d_VirtualProtect&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;k32_dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)k32_base;<br />	PIMAGE_NT_HEADERS&nbsp;k32_pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)k32_base&nbsp;+&nbsp;k32_dos_header-&gt;e_lfanew);<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;k32_export_dir&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((size_t)k32_base&nbsp;+&nbsp;k32_pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br />	DWORD*&nbsp;k32_export_names&nbsp;=&nbsp;(DWORD*)((size_t)k32_base&nbsp;+&nbsp;k32_export_dir-&gt;AddressOfNames);<br />	WORD*&nbsp;k32_export_ordinals&nbsp;=&nbsp;(WORD*)((size_t)k32_base&nbsp;+&nbsp;k32_export_dir-&gt;AddressOfNameOrdinals);<br />	DWORD*&nbsp;k32_export_functions&nbsp;=&nbsp;(DWORD*)((size_t)k32_base&nbsp;+&nbsp;k32_export_dir-&gt;AddressOfFunctions);<br /><br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;k32_export_dir-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		char*&nbsp;function_name&nbsp;=&nbsp;(char*)((size_t)k32_base&nbsp;+&nbsp;k32_export_names[i]);<br />		DWORD&nbsp;hashed_function&nbsp;=&nbsp;hashA(function_name);<br />		if&nbsp;(hashed_function&nbsp;==&nbsp;hash_VirtualProtect)<br />		{<br />			d_VirtualProtect&nbsp;=&nbsp;(t_VirtualProtect)((size_t)k32_base&nbsp;+&nbsp;k32_export_functions[k32_export_ordinals[i]]);<br />			break;<br />		}<br />	}<br /><br />	/*<br />	#&nbsp;Step&nbsp;3<br />	Loop&nbsp;through&nbsp;host&nbsp;PE&#39;s&nbsp;sections&nbsp;and&nbsp;xor&nbsp;decrypt&nbsp;.text&nbsp;and&nbsp;data.<br />	Only&nbsp;.text&nbsp;and&nbsp;.data&nbsp;are&nbsp;encrypted&nbsp;because&nbsp;encrypting&nbsp;other&nbsp;sections&nbsp;means&nbsp;Windwos&nbsp;doesn&#39;t&nbsp;recognisethe&nbsp;PE.<br />	PEB-&gt;ImageBaseAddress&nbsp;is&nbsp;undocumented,&nbsp;so&nbsp;can&nbsp;use&nbsp;Reserved3[1]&nbsp;instead.<br />	Loop&nbsp;`NumberOfSections&nbsp;-&nbsp;1`&nbsp;so&nbsp;we&nbsp;don&#39;t&nbsp;decrypt&nbsp;ourselves&nbsp;-&nbsp;`.stub`.<br />	Have&nbsp;to&nbsp;set&nbsp;section&nbsp;to&nbsp;PAGE_EXECUTE_READWRITE&nbsp;so&nbsp;that&nbsp;we&nbsp;can&nbsp;xor&nbsp;decrypt.&nbsp;Restore&nbsp;after.<br />	*/<br />	void*&nbsp;pe_base&nbsp;=&nbsp;p_peb-&gt;Reserved3[1];<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_base;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	DWORD&nbsp;old_protect&nbsp;=&nbsp;0;<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;h&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;t&#39;,&nbsp;&#39;h&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;e&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;7;<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections&nbsp;-&nbsp;1;&nbsp;i++)<br />	{<br />		DWORD&nbsp;hashed_section&nbsp;=&nbsp;hashA(section_header-&gt;Name);<br />		if&nbsp;(hashed_section&nbsp;==&nbsp;hash_text_section&nbsp;||&nbsp;hashed_section&nbsp;==&nbsp;hash_data_section)<br />		{<br />			char*&nbsp;section&nbsp;=&nbsp;(char*)((size_t)pe_base&nbsp;+&nbsp;section_header-&gt;VirtualAddress);<br />			d_VirtualProtect((void*)section,&nbsp;section_header-&gt;Misc.VirtualSize,&nbsp;PAGE_EXECUTE_READWRITE,&nbsp;&amp;old_protect);<br /><br />			//&nbsp;Null-preserving&nbsp;xor.<br />			for&nbsp;(DWORD&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;section_header-&gt;Misc.VirtualSize;&nbsp;j++)<br />			{<br />				if&nbsp;((section[j]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(section[j]&nbsp;==&nbsp;key[j&nbsp;%&nbsp;key_len]))<br />					continue;<br />				else<br />					section[j]&nbsp;^=&nbsp;key[j&nbsp;%&nbsp;key_len];<br />			}<br /><br />			d_VirtualProtect((void*)section,&nbsp;section_header-&gt;Misc.VirtualSize,&nbsp;old_protect,&nbsp;&amp;old_protect);<br />		}<br />		section_header++;<br />	}<br /><br />	/*<br />	#&nbsp;Step&nbsp;4<br />	Execute&nbsp;decrypted&nbsp;PE<br />	by&nbsp;jumping&nbsp;to&nbsp;the&nbsp;C&nbsp;RunTime&nbsp;main()&nbsp;function&nbsp;in&nbsp;the&nbsp;decrypted&nbsp;PE.<br />	*/<br />	void*&nbsp;entrypoint&nbsp;=&nbsp;(void*)((size_t)pe_base&nbsp;+&nbsp;0x12C4);		//&nbsp;TODO:&nbsp;FIND&nbsp;WAY&nbsp;TO&nbsp;NOT&nbsp;HARDCODE&nbsp;ORIGINAL&nbsp;PE&#39;S&nbsp;ENTRYPOINT<br />	t_CRTmain&nbsp;d_CRTmain&nbsp;=&nbsp;(t_CRTmain)entrypoint;<br />	d_CRTmain();<br /><br />	return;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h3>### builder.exe</h3></strong><br />Lastly, here&#39;s the builder that encrypts the target PE&#39;s sections<br />and attaches the decryption stub.<br /><br />There&#39;s 1 hardcoded addresses in this code - <code>0xE0</code> - when modifying the AddressOfEntryPoint.<br /><code>0xE0</code> is the entrypoint of the decryption stub<br />(the address of the <code>stub()</code> function. the earlier code is the hash functions.)<br /><a href=""><img src="images/1876-8.png" alt="images/1876-8.png" /></a><br /><br />THIS VALUE WILL NEED CHANGING.<br />Change it to the AddressOfEntryPoint of the <code>decryption_stub.exe</code> you compiled.<br />(-0x1000 because we don&#39;t need the .text address, which is at 0x1000)<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />/*<br />Align&nbsp;a&nbsp;value&nbsp;to&nbsp;an&nbsp;address.<br />	curr_value&nbsp;is&nbsp;the&nbsp;value&nbsp;to&nbsp;align.<br />	align_value&nbsp;is&nbsp;how&nbsp;to&nbsp;align&nbsp;it&nbsp;(page&nbsp;size,&nbsp;etc.)<br />	target_addr&nbsp;is&nbsp;where&nbsp;to&nbsp;align&nbsp;the&nbsp;value&nbsp;to.<br />*/<br />DWORD&nbsp;align(DWORD&nbsp;curr_value,&nbsp;DWORD&nbsp;align_value,&nbsp;size_t&nbsp;target_addr)<br />{<br />	if&nbsp;(!(curr_value&nbsp;%&nbsp;align_value))<br />		return&nbsp;target_addr&nbsp;+&nbsp;curr_value;<br /><br />	return&nbsp;target_addr&nbsp;+&nbsp;(curr_value&nbsp;/&nbsp;align_value&nbsp;+&nbsp;1)&nbsp;*&nbsp;align_value;<br />}<br /><br />/*<br />Null&nbsp;preserving&nbsp;XOR&nbsp;function&nbsp;to&nbsp;encrypt/decrypt&nbsp;bytes.<br />*/<br />void&nbsp;xor_bytes(unsigned&nbsp;char*&nbsp;data,&nbsp;int&nbsp;data_size)<br />{<br />	char&nbsp;key[]&nbsp;=&nbsp;{&nbsp;&#39;h&#39;,&nbsp;&#39;i&#39;,&nbsp;&#39;t&#39;,&nbsp;&#39;h&#39;,&nbsp;&#39;e&#39;,&nbsp;&#39;r&#39;,&nbsp;&#39;e&#39;&nbsp;};<br />	int&nbsp;key_len&nbsp;=&nbsp;sizeof(key);<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;data_size;&nbsp;i++)<br />	{<br />		if&nbsp;((data[i]&nbsp;==&nbsp;0x00)&nbsp;||&nbsp;(data[i]&nbsp;==&nbsp;key[i&nbsp;%&nbsp;key_len]))<br />			continue;<br />		else<br />			data[i]&nbsp;^=&nbsp;key[i&nbsp;%&nbsp;key_len];<br />	}<br /><br />	return;<br />}<br /><br />void&nbsp;die(const&nbsp;char*&nbsp;fmt,&nbsp;...)<br />{<br />	va_list&nbsp;argp;<br />	va_start(argp,&nbsp;fmt);<br />	vfprintf(stderr,&nbsp;fmt,&nbsp;argp);<br />	va_end(argp);<br />	fputc(&#39;\n&#39;,&nbsp;stderr);<br />	exit(1);<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br />{<br />	BOOL&nbsp;b&nbsp;=&nbsp;FALSE;<br />	<br />	printf(&quot;#&nbsp;builder&nbsp;\n\n&quot;);<br />	if&nbsp;(argc&nbsp;!=&nbsp;4)<br />	{<br />		printf(&quot;not&nbsp;enough&nbsp;arguments&nbsp;:/&nbsp;\n&quot;);<br />		printf(&quot;usage:&nbsp;&lt;path/to/target.exe&gt;&nbsp;&lt;path/to/stub.dat&gt;&nbsp;&lt;path/to/outfile.exe&quot;);<br />		return&nbsp;-1;<br />	}<br /><br />	char*&nbsp;infile&nbsp;=&nbsp;argv[1];<br />	char*&nbsp;stubfile&nbsp;=&nbsp;argv[2];<br />	char*&nbsp;outfile&nbsp;=&nbsp;argv[3];<br /><br />	//&nbsp;Read&nbsp;infile&nbsp;into&nbsp;buffer<br />	HANDLE&nbsp;h_infile&nbsp;=&nbsp;CreateFileA(infile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_infile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;infile:&nbsp;%s&nbsp;\n&quot;,&nbsp;GetLastError());<br /><br />	DWORD&nbsp;infile_size&nbsp;=&nbsp;GetFileSize(h_infile,&nbsp;NULL);<br />	void*&nbsp;inbuf&nbsp;=&nbsp;malloc(infile_size);	<br />	DWORD&nbsp;bytes_read&nbsp;=&nbsp;0;<br />	b&nbsp;=&nbsp;ReadFile(h_infile,&nbsp;inbuf,&nbsp;infile_size,&nbsp;&amp;bytes_read,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;infile&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	CloseHandle(h_infile);<br /><br />	//&nbsp;Check&nbsp;it&#39;s&nbsp;a&nbsp;valid&nbsp;PE&nbsp;file<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)inbuf;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)inbuf&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br />	<br />	if&nbsp;(dos_header-&gt;e_magic&nbsp;!=&nbsp;IMAGE_DOS_SIGNATURE)<br />		die(&quot;[-]&nbsp;PE&nbsp;infile&nbsp;not&nbsp;a&nbsp;valid&nbsp;DOS&nbsp;file&nbsp;\n&quot;);<br />	if&nbsp;(pe_header-&gt;Signature&nbsp;!=&nbsp;IMAGE_NT_SIGNATURE)<br />		die(&quot;[-]&nbsp;infile&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;PE&nbsp;file&nbsp;\n&quot;);<br /><br />	/*&nbsp;<br />	Loop&nbsp;through&nbsp;sections&nbsp;and&nbsp;encrypt&nbsp;.text&nbsp;and&nbsp;.data.<br />	Encrypting&nbsp;other&nbsp;sections&nbsp;causes&nbsp;Windows&nbsp;to&nbsp;classify&nbsp;the&nbsp;PE&nbsp;as<br />	&quot;not&nbsp;a&nbsp;valid&nbsp;application&nbsp;for&nbsp;this&nbsp;OS&nbsp;platform&quot;.<br />	*/<br />	printf(&quot;[*]&nbsp;encrypting&nbsp;sections&nbsp;\n&quot;);<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		if&nbsp;(strcmp(section-&gt;Name,&nbsp;&quot;.text&quot;)&nbsp;==&nbsp;0&nbsp;||&nbsp;strcmp(section-&gt;Name,&nbsp;&quot;.data&quot;)&nbsp;==&nbsp;0)<br />		{<br />			unsigned&nbsp;char*&nbsp;section_data&nbsp;=&nbsp;(unsigned&nbsp;char*)((size_t)inbuf&nbsp;+&nbsp;section-&gt;PointerToRawData);<br />			xor_bytes(section_data,&nbsp;section-&gt;SizeOfRawData);<br /><br />			printf(&quot;encrypted&nbsp;%s&nbsp;\n&quot;,&nbsp;section-&gt;Name);<br />		}<br />		<br />		section++;<br />	}<br /><br />	//&nbsp;Read&nbsp;stub&nbsp;into&nbsp;buffer<br />	HANDLE&nbsp;h_stubfile&nbsp;=&nbsp;CreateFileA(stubfile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_stubfile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;stubfile:&nbsp;%s&nbsp;\n&quot;,&nbsp;GetLastError());<br /><br />	DWORD&nbsp;stubfile_size&nbsp;=&nbsp;GetFileSize(h_stubfile,&nbsp;NULL);<br />	void*&nbsp;stubbuf&nbsp;=&nbsp;malloc(stubfile_size);<br />	b&nbsp;=&nbsp;ReadFile(h_stubfile,&nbsp;stubbuf,&nbsp;stubfile_size,&nbsp;&amp;bytes_read,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;stubfile&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	CloseHandle(h_stubfile);<br /><br />	//&nbsp;Write&nbsp;new&nbsp;section&nbsp;info&nbsp;into&nbsp;PE&nbsp;header<br />	PIMAGE_SECTION_HEADER&nbsp;last_section&nbsp;=&nbsp;(IMAGE_FIRST_SECTION(pe_header)&nbsp;+&nbsp;pe_header-&gt;FileHeader.NumberOfSections)&nbsp;-&nbsp;1;<br />	PIMAGE_SECTION_HEADER&nbsp;new_section&nbsp;=&nbsp;last_section&nbsp;+&nbsp;1;<br />	char&nbsp;section_name[8]&nbsp;=&nbsp;&quot;.stub&quot;;		//&nbsp;max&nbsp;section&nbsp;name&nbsp;length&nbsp;is&nbsp;8&nbsp;bytes&nbsp;e.g.&nbsp;&quot;.bigtest&quot;<br /><br />	memset(new_section,&nbsp;0,&nbsp;sizeof(IMAGE_SECTION_HEADER));<br />	memcpy_s(new_section-&gt;Name,&nbsp;8,&nbsp;section_name,&nbsp;8);		//&nbsp;max&nbsp;section&nbsp;name&nbsp;length&nbsp;is&nbsp;8&nbsp;bytes<br />	new_section-&gt;Misc.VirtualSize&nbsp;=&nbsp;align(stubfile_size,&nbsp;pe_header-&gt;OptionalHeader.SectionAlignment,&nbsp;0);<br />	new_section-&gt;VirtualAddress&nbsp;=&nbsp;align(last_section-&gt;Misc.VirtualSize,&nbsp;pe_header-&gt;OptionalHeader.SectionAlignment,&nbsp;last_section-&gt;VirtualAddress);<br />	new_section-&gt;SizeOfRawData&nbsp;=&nbsp;align(stubfile_size,&nbsp;pe_header-&gt;OptionalHeader.FileAlignment,&nbsp;0);<br />	new_section-&gt;PointerToRawData&nbsp;=&nbsp;align(last_section-&gt;SizeOfRawData,&nbsp;pe_header-&gt;OptionalHeader.FileAlignment,&nbsp;last_section-&gt;PointerToRawData);<br />	new_section-&gt;Characteristics&nbsp;=&nbsp;0xE00000E0;<br /><br />	/*&nbsp;<br />	Update&nbsp;PE&nbsp;header:<br />	-&nbsp;+1&nbsp;section<br />	-&nbsp;increased&nbsp;SizeOfImage<br />	-&nbsp;change&nbsp;entrypoint&nbsp;to&nbsp;added&nbsp;section<br />	*/<br />	pe_header-&gt;FileHeader.NumberOfSections&nbsp;+=&nbsp;1;<br />	pe_header-&gt;OptionalHeader.SizeOfImage&nbsp;=&nbsp;pe_header-&gt;OptionalHeader.SizeOfImage&nbsp;+&nbsp;stubfile_size;<br />	pe_header-&gt;OptionalHeader.AddressOfEntryPoint&nbsp;=&nbsp;new_section-&gt;VirtualAddress&nbsp;+&nbsp;0xE0;		//&nbsp;TODO:&nbsp;FIND&nbsp;WAY&nbsp;TO&nbsp;NOT&nbsp;HARDCODE&nbsp;STUB&#39;S&nbsp;ENTRPOINT<br /><br />	/*<br />	Resize&nbsp;PE&nbsp;buffer&nbsp;to&nbsp;store&nbsp;new&nbsp;data<br />	New&nbsp;size&nbsp;should&nbsp;be&nbsp;(inbuf_size&nbsp;+&nbsp;stubfile_size&nbsp;after&nbsp;alignment)<br />	(inbuf_size&nbsp;+&nbsp;stubfile_size)&nbsp;doesn&#39;t&nbsp;allocate&nbsp;enough&nbsp;space.<br />	Therefore,&nbsp;SizeOfRawData&nbsp;is&nbsp;used&nbsp;because&nbsp;it&#39;s&nbsp;aligned.<br />	*/<br />	DWORD&nbsp;outfile_size&nbsp;=&nbsp;infile_size&nbsp;+&nbsp;new_section-&gt;SizeOfRawData;<br />	void*&nbsp;tmp_pointer&nbsp;=&nbsp;realloc(inbuf,&nbsp;outfile_size);<br />	if&nbsp;(tmp_pointer&nbsp;==&nbsp;NULL)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;resize&nbsp;inbuf&nbsp;\n&quot;);<br />	else<br />		inbuf&nbsp;=&nbsp;tmp_pointer;<br /><br />	//&nbsp;Write&nbsp;data&nbsp;into&nbsp;new&nbsp;section<br />	void*&nbsp;rawdata_addr&nbsp;=&nbsp;(void*)((size_t)inbuf&nbsp;+&nbsp;new_section-&gt;PointerToRawData);<br />	memset(rawdata_addr,&nbsp;0,&nbsp;new_section-&gt;SizeOfRawData);<br />	memcpy_s(rawdata_addr,&nbsp;new_section-&gt;SizeOfRawData,&nbsp;stubbuf,&nbsp;stubfile_size);<br /><br />	//&nbsp;Write&nbsp;buffer&nbsp;out&nbsp;to&nbsp;new&nbsp;file<br />	HANDLE&nbsp;h_outfile&nbsp;=&nbsp;CreateFileA(outfile,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;CREATE_ALWAYS,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_outfile&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;create&nbsp;output&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	<br />	DWORD&nbsp;bytes_written&nbsp;=&nbsp;0;<br />	b&nbsp;=&nbsp;WriteFile(h_outfile,&nbsp;inbuf,&nbsp;outfile_size,&nbsp;&amp;bytes_written,&nbsp;NULL);<br />	if&nbsp;(b&nbsp;==&nbsp;FALSE)<br />		die(&quot;[-]&nbsp;failed&nbsp;to&nbsp;write&nbsp;buffer&nbsp;into&nbsp;outfile:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />	CloseHandle(h_outfile);<br /><br />	//&nbsp;Cleanup&nbsp;and&nbsp;leave!<br />	free(inbuf);<br />	free(stubbuf);<br /><br />	printf(&quot;\n[+]&nbsp;done!&nbsp;\n&quot;);<br />	printf(&quot;[*]&nbsp;encrypted&nbsp;sections&nbsp;in:&nbsp;%s&nbsp;\n&quot;,&nbsp;infile);<br />	printf(&quot;[*]&nbsp;added&nbsp;%s&nbsp;decryption&nbsp;stub&nbsp;to&nbsp;infile&nbsp;\n&quot;,&nbsp;section_name);<br />	printf(&quot;[*]&nbsp;set&nbsp;entrypoint&nbsp;to:&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(void*)(pe_header-&gt;OptionalHeader.ImageBase&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.AddressOfEntryPoint));<br />	printf(&quot;[*]&nbsp;outfile:&nbsp;%s&nbsp;\n&quot;,&nbsp;outfile);<br /><br />	return&nbsp;0;<br />}<br /></div></div><br /><br /><strong><h2>## Usage</h2></strong><br />1. In <code>decryption_stub</code> source code, modify hardcoded entrypoint value at <code>void* entrypoint</code> to the AddressOfEntryPoint in the target PE you&#39;re encrypting <br />   e.g. target PE AddressOfEntryPoint == <code>0x12b3</code> &lt;-- modify it to that<br />2. Compile decryption stub<br />3. Dump <code>.text</code> section from compiled decryption stub to a file e.g. <code>stub.dat</code><br />4. In <code>builder</code> source code, modify hardcoded value at <code>new_section-&gt;VirtualAddress + value</code> to the AddressOfEntryPoint of the decryption stub PE<br />   e.g. decryption_stub PE AddressOfEntryPoint == <code>0xE2</code> &lt;--- modify it to that<br />5. Run <code>builder.exe</code><br />   Use 32bit version for 32bit stub and PE file<br />   Use 64bit version for 64bit stub and PE file<br /><div class="codebox"><div class="codebox">.\builder.exe&nbsp;C:\Users\Bob\tmp\hello_messagebox64.exe&nbsp;C:\Users\bob\source\malware_programs\crypter\stub_as_decrypter\decryption_stub\x64\Release\stub64.dat&nbsp;C:\Users\Bob\Desktop\tmp\crypter\crypted64.exe</div></div><br />6. Run the <code>crypted.exe</code> file. It should work!</div>
</body>
</html>
