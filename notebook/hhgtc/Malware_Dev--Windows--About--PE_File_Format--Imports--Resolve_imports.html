<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Resolve imports</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Resolve imports</h1></strong><br />You can resolve imports by:<br />• looping through the imported DLLs<br />• loading the required DLL with <code>LoadLibrary</code><br />• grabbing the function address from the library with <code>GetProcAddress</code><br />   ◇ GetProcAddress accepts both function names and function ordinals<br />• and writing the function address into the Import Address Table<br /><br />The example below uses a PE on disk and raw addresses, not a memory mapped PE and virtual addresses.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br /><br />LPVOID&nbsp;ReadFileIntoBuffer(char*&nbsp;file_name,&nbsp;OUT&nbsp;DWORD*&nbsp;file_buffer_size)<br />{<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	BOOL&nbsp;b_ret&nbsp;=&nbsp;TRUE;<br />	HANDLE&nbsp;h_file&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	//&nbsp;open&nbsp;target&nbsp;file<br />	h_file&nbsp;=&nbsp;CreateFileA(file_name,&nbsp;GENERIC_READ&nbsp;|&nbsp;GENERIC_WRITE,&nbsp;0,&nbsp;NULL,&nbsp;OPEN_EXISTING,&nbsp;FILE_ATTRIBUTE_NORMAL,&nbsp;NULL);<br />	if&nbsp;(h_file&nbsp;==&nbsp;INVALID_HANDLE_VALUE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;open&nbsp;target&nbsp;file:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		goto&nbsp;cleanup;<br />	}<br /><br />	//&nbsp;get&nbsp;file&nbsp;size<br />	file_size&nbsp;=&nbsp;GetFileSize(h_file,&nbsp;NULL);<br />	(*file_buffer_size)&nbsp;=&nbsp;file_size;<br /><br />	//&nbsp;create&nbsp;buffer&nbsp;to&nbsp;read&nbsp;file&nbsp;into<br />	file_buffer&nbsp;=&nbsp;malloc(file_size);<br /><br />	//&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer<br />	b_ret&nbsp;=&nbsp;ReadFile(h_file,&nbsp;file_buffer,&nbsp;file_size,&nbsp;NULL,&nbsp;NULL);<br />	if&nbsp;(b_ret&nbsp;==&nbsp;FALSE)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		free(file_buffer);<br />		goto&nbsp;cleanup;<br />	}<br /><br />cleanup:<br />	if&nbsp;(h_file)&nbsp;CloseHandle(h_file);<br /><br />	return&nbsp;file_buffer;<br />}<br /><br />/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />*/<br />DWORD&nbsp;rva2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;rva)<br />{<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;section&nbsp;header<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(rva&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;rva;<br /><br />	//&nbsp;loop&nbsp;through&nbsp;sections<br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		//&nbsp;find&nbsp;start&nbsp;and&nbsp;end&nbsp;of&nbsp;current&nbsp;section<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;if&nbsp;the&nbsp;provided&nbsp;RVA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(rva&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;rva&nbsp;&lt;&nbsp;section_end)<br />		{<br />			//&nbsp;calculate&nbsp;raw&nbsp;address<br />			raw_address&nbsp;=&nbsp;(rva&nbsp;-&nbsp;section_start)&nbsp;+&nbsp;section_header-&gt;PointerToRawData;<br />			break;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;section<br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />BOOL&nbsp;ResolveImports(LPVOID&nbsp;file_buffer)<br />{<br />	BOOL&nbsp;okay&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_FILE_HEADER&nbsp;coff_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_OPTIONAL_HEADER&nbsp;pe_optional_header&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;import_directory&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;import_lookup_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;import_address_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_BY_NAME&nbsp;import_name&nbsp;=&nbsp;NULL;<br /><br />	HMODULE&nbsp;h_library&nbsp;=&nbsp;NULL;<br />	FARPROC&nbsp;import_address&nbsp;=&nbsp;NULL;<br /><br />	dos_header&nbsp;=&nbsp;file_buffer;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header&nbsp;+&nbsp;(DWORD_PTR)dos_header-&gt;e_lfanew);<br />	import_directory&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)file_buffer&nbsp;+&nbsp;rva2raw(file_buffer,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress));<br />	printf(&quot;import&nbsp;directory&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;import_directory);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;DLLs<br />	while&nbsp;(import_directory-&gt;Name&nbsp;!=&nbsp;0)<br />	{<br />		//&nbsp;grab&nbsp;DLL&nbsp;name<br />		char*&nbsp;dll_name&nbsp;=&nbsp;(char*)((DWORD_PTR)file_buffer&nbsp;+&nbsp;rva2raw(file_buffer,&nbsp;import_directory-&gt;Name));<br /><br />		//&nbsp;load&nbsp;DLL<br />		h_library&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />		if&nbsp;(h_library&nbsp;==&nbsp;NULL)<br />			return&nbsp;FALSE;<br /><br />		printf(&quot;[+]&nbsp;loaded&nbsp;%s&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_name,&nbsp;h_library);<br /><br />		import_lookup_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((DWORD_PTR)file_buffer&nbsp;+&nbsp;rva2raw(file_buffer,&nbsp;import_directory-&gt;OriginalFirstThunk));<br />		import_address_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((DWORD_PTR)file_buffer&nbsp;+&nbsp;rva2raw(file_buffer,&nbsp;import_directory-&gt;FirstThunk));<br /><br />		//&nbsp;loop&nbsp;through&nbsp;imported&nbsp;functions&nbsp;in&nbsp;DLL<br />		while&nbsp;(import_lookup_table-&gt;u1.AddressOfData&nbsp;!=&nbsp;0)<br />		{<br />			//&nbsp;if&nbsp;import&nbsp;by&nbsp;ordinal<br />			if&nbsp;(IMAGE_SNAP_BY_ORDINAL(import_lookup_table-&gt;u1.Ordinal))<br />			{<br />				//&nbsp;grab&nbsp;import&nbsp;ordinal&nbsp;number<br />				ULONGLONG&nbsp;import_ordinal&nbsp;=&nbsp;IMAGE_ORDINAL(import_lookup_table-&gt;u1.Ordinal);<br />				printf(&quot;\t&nbsp;[import&nbsp;by&nbsp;ordinal]&nbsp;%37llx&nbsp;&quot;,&nbsp;import_ordinal);<br />				<br />				//&nbsp;grab&nbsp;function&nbsp;address&nbsp;from&nbsp;loaded&nbsp;library&nbsp;&amp;&nbsp;write&nbsp;into&nbsp;Import&nbsp;Address&nbsp;Table<br />				import_address&nbsp;=&nbsp;GetProcAddress(h_library,&nbsp;(LPCSTR)import_ordinal);<br />				import_address_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_address;<br /><br />				printf(&quot;\t&nbsp;[value&nbsp;in&nbsp;ILT]&nbsp;0x%p&nbsp;\t&nbsp;[modified&nbsp;to&nbsp;in&nbsp;IAT]&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)import_lookup_table-&gt;u1.Function,&nbsp;import_address);<br />			}<br />			//&nbsp;if&nbsp;import&nbsp;by&nbsp;name<br />			else<br />			{<br />				//&nbsp;grab&nbsp;import&nbsp;name&nbsp;from&nbsp;IMAGE_IMPORT_NAME&nbsp;struct<br />				import_name&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)file_buffer&nbsp;+&nbsp;rva2raw(file_buffer,&nbsp;import_lookup_table-&gt;u1.AddressOfData));<br />				printf(&quot;\t&nbsp;[import&nbsp;by&nbsp;name]&nbsp;%40s&nbsp;&quot;,&nbsp;import_name-&gt;Name);<br /><br />				//&nbsp;grab&nbsp;function&nbsp;address&nbsp;from&nbsp;loaded&nbsp;library&nbsp;&amp;&nbsp;write&nbsp;into&nbsp;Import&nbsp;Address&nbsp;Table<br />				import_address&nbsp;=&nbsp;GetProcAddress(h_library,&nbsp;import_name-&gt;Name);<br />				import_address_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_address;<br /><br />				printf(&quot;\t&nbsp;[value&nbsp;in&nbsp;ILT]&nbsp;0x%p&nbsp;\t&nbsp;[modified&nbsp;to&nbsp;in&nbsp;IAT]&nbsp;0x%p&nbsp;\n&quot;,&nbsp;(LPVOID)import_lookup_table-&gt;u1.Function,&nbsp;import_address);<br />			}<br /><br />			//&nbsp;advance&nbsp;to&nbsp;next&nbsp;function<br />			import_lookup_table++;<br />			import_address_table++;<br />		}<br /><br />		//&nbsp;advance&nbsp;to&nbsp;next&nbsp;DLL<br />		import_directory++;<br />	}<br /><br />	return&nbsp;okay;<br />}<br /><br />int&nbsp;main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])<br /><span style="color:#000000;font-weight:400">{</span><br />	//&nbsp;arguments&nbsp;setup<br />	if&nbsp;(argc&nbsp;!=&nbsp;2)<br />	{<br />		printf(&quot;[-]&nbsp;1&nbsp;argument&nbsp;required&nbsp;:/&nbsp;\n&quot;);<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	char*&nbsp;arg1_filename&nbsp;=&nbsp;argv[1];<br /><br />	//&nbsp;main<br />	LPVOID&nbsp;file_buffer&nbsp;=&nbsp;NULL;<br />	DWORD&nbsp;file_size&nbsp;=&nbsp;0;<br /><br />	file_buffer&nbsp;=&nbsp;ReadFileIntoBuffer(arg1_filename,&nbsp;&amp;file_size);<br />	if&nbsp;(file_buffer&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;read&nbsp;file&nbsp;into&nbsp;buffer:&nbsp;%d&nbsp;\n&quot;,&nbsp;GetLastError());<br />		return&nbsp;EXIT_FAILURE;<br />	}<br /><br />	ResolveImports(file_buffer);<br /><br />	free(file_buffer);<br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /><strong><h2>## Version 2</h2></strong><br />Uses raw addresses.<br /><br /><div class="codebox"><div class="codebox">/*<br />Convert&nbsp;VirtualAddress&nbsp;(address&nbsp;in&nbsp;memory)&nbsp;to&nbsp;raw&nbsp;address&nbsp;(address&nbsp;on&nbsp;disk).<br />Does&nbsp;so&nbsp;by&nbsp;finding&nbsp;which&nbsp;PE&nbsp;section&nbsp;your&nbsp;VirtualAddress&nbsp;is&nbsp;in,<br />subtracting&nbsp;the&nbsp;section&#39;s&nbsp;start&nbsp;address&nbsp;to&nbsp;find&nbsp;the&nbsp;relative&nbsp;virtual&nbsp;address,<br />and&nbsp;then&nbsp;adding&nbsp;the&nbsp;RVA&nbsp;to&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;section&nbsp;on&nbsp;disk.<br />*/<br />DWORD&nbsp;va2raw(LPVOID&nbsp;file_buffer,&nbsp;DWORD&nbsp;va)<br />{<br />	DWORD&nbsp;rva&nbsp;=&nbsp;0;<br />	DWORD&nbsp;raw_address&nbsp;=&nbsp;0;<br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)file_buffer;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)file_buffer&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_SECTION_HEADER&nbsp;section_header&nbsp;=&nbsp;IMAGE_FIRST_SECTION(pe_header);<br /><br />	if&nbsp;(va&nbsp;&lt;&nbsp;section_header-&gt;PointerToRawData)<br />		return&nbsp;va;<br /><br />	for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pe_header-&gt;FileHeader.NumberOfSections;&nbsp;i++)<br />	{<br />		DWORD&nbsp;section_start&nbsp;=&nbsp;section_header-&gt;VirtualAddress;<br />		DWORD&nbsp;section_end&nbsp;=&nbsp;section_header-&gt;VirtualAddress&nbsp;+&nbsp;section_header-&gt;SizeOfRawData;<br /><br />		//&nbsp;If&nbsp;the&nbsp;provided&nbsp;VA&nbsp;is&nbsp;within&nbsp;the&nbsp;bounds&nbsp;of&nbsp;this&nbsp;current&nbsp;section<br />		if&nbsp;(va&nbsp;&gt;=&nbsp;section_start&nbsp;&amp;&amp;&nbsp;va&nbsp;&lt;&nbsp;section_end)<br />		{<br />			rva&nbsp;=&nbsp;va&nbsp;-&nbsp;section_start;<br />			raw_address&nbsp;=&nbsp;section_header-&gt;PointerToRawData&nbsp;+&nbsp;rva;<br />			break;<br />		}<br /><br />		section_header&nbsp;+=&nbsp;1;<br />	}<br /><br />	return&nbsp;raw_address;<br />}<br /><br />BOOL&nbsp;ProcessImportsRaw(void*&nbsp;pe_base)<br /><span style="color:#000000;font-weight:400">{</span><br />	BOOL&nbsp;ok&nbsp;=&nbsp;TRUE;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pe_base;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((size_t)pe_base&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;import_dir&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress));<br />	PIMAGE_THUNK_DATA&nbsp;lookup_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_THUNK_DATA&nbsp;addr_table&nbsp;=&nbsp;NULL;<br />	PIMAGE_IMPORT_BY_NAME&nbsp;import_name&nbsp;=&nbsp;NULL;<br /><br />	HMODULE&nbsp;h_dll&nbsp;=&nbsp;NULL;<br />	FARPROC&nbsp;import_addr&nbsp;=&nbsp;NULL;<br />	ULONGLONG&nbsp;import_ordinal&nbsp;=&nbsp;0;<br /><br />	//&nbsp;Loop&nbsp;through&nbsp;DLLs&nbsp;in&nbsp;import&nbsp;directory&nbsp;&amp;&nbsp;load&nbsp;them<br />	while&nbsp;(import_dir-&gt;Name&nbsp;!=&nbsp;0)<br />	{<br />		char*&nbsp;dll_name&nbsp;=&nbsp;(char*)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;import_dir-&gt;Name));<br />		h_dll&nbsp;=&nbsp;LoadLibraryA(dll_name);<br />		if&nbsp;(h_dll&nbsp;==&nbsp;NULL)<br />		{<br />			printf(&quot;[-]&nbsp;failed&nbsp;to&nbsp;load&nbsp;library:&nbsp;%s&nbsp;\n&quot;,&nbsp;dll_name);<br />			return&nbsp;FALSE;<br />		}<br /><br />		printf(&quot;\t&nbsp;[+]&nbsp;loaded&nbsp;%s&nbsp;\n&quot;,&nbsp;dll_name);<br /><br />		lookup_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;import_dir-&gt;OriginalFirstThunk));<br />		addr_table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;import_dir-&gt;FirstThunk));<br /><br />		//&nbsp;Loop&nbsp;through&nbsp;functions&nbsp;in&nbsp;lookup&nbsp;table&nbsp;in&nbsp;DLL,&nbsp;get&nbsp;the&nbsp;function&#39;s&nbsp;address,&nbsp;and&nbsp;write&nbsp;address&nbsp;into&nbsp;the&nbsp;Import&nbsp;Address&nbsp;Table<br />		while&nbsp;(lookup_table-&gt;u1.AddressOfData&nbsp;!=&nbsp;0)<br />		{<br />			if&nbsp;(IMAGE_SNAP_BY_ORDINAL(lookup_table-&gt;u1.Ordinal))<br />			{<br />				import_ordinal&nbsp;=&nbsp;IMAGE_ORDINAL(lookup_table-&gt;u1.Ordinal);<br />				import_addr&nbsp;=&nbsp;GetProcAddress(h_dll,&nbsp;(LPCSTR)import_ordinal);<br /><br />				printf(&quot;\t\t&nbsp;[ordinal&nbsp;%lld]&nbsp;(orig)&nbsp;0x%x&nbsp;&quot;,&nbsp;import_ordinal,&nbsp;addr_table-&gt;u1.Function);<br />				addr_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_addr;<br />				printf(&quot;(new)&nbsp;0x%x&nbsp;\n&quot;,&nbsp;addr_table-&gt;u1.Function);<br />			}<br />			else<br />			{<br />				import_name&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)((size_t)pe_base&nbsp;+&nbsp;va2raw(pe_base,&nbsp;lookup_table-&gt;u1.AddressOfData));<br />				import_addr&nbsp;=&nbsp;GetProcAddress(h_dll,&nbsp;import_name-&gt;Name);<br /><br />				printf(&quot;\t\t&nbsp;[%s]&nbsp;orig:&nbsp;0x%x&nbsp;&quot;,&nbsp;import_name-&gt;Name,&nbsp;addr_table-&gt;u1.Function);<br />				addr_table-&gt;u1.Function&nbsp;=&nbsp;(ULONGLONG)import_addr;<br />				printf(&quot;(new)&nbsp;0x%x&nbsp;\n&quot;,&nbsp;addr_table-&gt;u1.Function);<br />			}<br /><br />			lookup_table++;<br />			addr_table++;<br />		}<br /><br />		import_dir++;<br />	}<br /><br />	return&nbsp;ok;<br /><span style="color:#000000;font-weight:400">}</span></div></div></div>
</body>
</html>
