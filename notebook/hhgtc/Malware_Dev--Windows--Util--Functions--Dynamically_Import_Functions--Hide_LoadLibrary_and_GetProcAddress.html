<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Hide LoadLibrary and GetProcAddress</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1># Hide LoadLibrary and GetProcAddress</h1></strong><br />By dynamically importing functions, the only functions that will show up in your PE&#39;s imports are<br /><code>LoadLibrary</code> / <code>GetModuleHandle</code> and <code>GetProcAddress</code><br /><a href=""><img src="images/1560-1.png" alt="images/1560-1.png" /></a><br /><br />However, you can get remove these too.<br /><br /><code>LoadLibrary</code> and <code>GetProcAddress</code> are located in <code>Kernel32.dll</code>.<br /><code>Kernel32.dll</code> is loaded automatically into a program&#39;s address space on startup.<br /><br /><a href=""><img src="images/1560-2.png" alt="images/1560-2.png" /></a><br /><br />If we find the address of where <code>Kernel32.dll</code> is loaded in our program - its base address - we can walk the DLL&#39;s exported functions to find the address of any function we want - like <code>LoadLibraryA</code> or <code>GetProcAddress</code><br /><br />• Resolving Kernel32 <br />   ◇ <a href="https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode">https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode</a><br /><br /><strong><h2>## Find Kernel32 base -&gt; Grab function you want </h2></strong><br />Obviously this will only work for functions that are stored in <code>Kernel32.dll</code><br />If you want other functions in other DLLs, you&#39;ll have to grab <code>LoadLibraryA</code>, load those DLLs, and then grab the functions.<br /><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />//&nbsp;function&nbsp;typedefs<br />typedef&nbsp;BOOL(WINAPI*&nbsp;t_Beep)(DWORD&nbsp;dwFreq,&nbsp;DWORD&nbsp;dwDuration);<br /><br />/*<br />Grabs&nbsp;PEB,<br />grabs&nbsp;PED_LDR_DATA&nbsp;from&nbsp;PEB&nbsp;to&nbsp;get&nbsp;info&nbsp;about&nbsp;loaded&nbsp;DLLs,<br />and&nbsp;loops&nbsp;through&nbsp;the&nbsp;loaded&nbsp;DLLs&nbsp;to&nbsp;find&nbsp;the&nbsp;DLL&nbsp;we&nbsp;want&nbsp;and&nbsp;grabs&nbsp;its&nbsp;base&nbsp;address.<br /><br />Be&nbsp;careful.&nbsp;The&nbsp;DLL&nbsp;name&nbsp;has&nbsp;to&nbsp;be&nbsp;exact&nbsp;(could&nbsp;use&nbsp;something&nbsp;else&nbsp;than&nbsp;strcmp&nbsp;tbf)<br />e.g:&nbsp;&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;&nbsp;vs&nbsp;&quot;C:\\WINDOWS\\System32\\KERNEL32.DLL&quot;<br /><br />Return:<br />NULL&nbsp;on&nbsp;error.<br />*/<br />LPVOID&nbsp;FindLoadedDLLBaseAddress(const&nbsp;wchar_t*&nbsp;dll_name)<br />{<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_list&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_entry&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;dll_base&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;PEB<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br /><br />	//&nbsp;grab&nbsp;list&nbsp;of&nbsp;loaded&nbsp;DLLs<br />	dll_list&nbsp;=&nbsp;(PLIST_ENTRY)&amp;p_peb-&gt;Ldr-&gt;InMemoryOrderModuleList;<br />	//&nbsp;grab&nbsp;first&nbsp;DLL&nbsp;in&nbsp;list&nbsp;of&nbsp;DLLs<br />	dll_entry&nbsp;=&nbsp;dll_list-&gt;Flink;<br /><br />	printf(&quot;peb&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_peb);<br />	printf(&quot;dll&nbsp;list&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_list);<br />	printf(&quot;dll&nbsp;entry&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_entry);<br /><br />	printf(&quot;[*]&nbsp;looping&nbsp;through&nbsp;loaded&nbsp;DLLs...&nbsp;\n&quot;);<br />	//&nbsp;loop&nbsp;through&nbsp;loaded&nbsp;DLLs<br />	while&nbsp;(dll_list&nbsp;!=&nbsp;dll_entry)<br />	{<br />		//&nbsp;grab&nbsp;DLL<br />		PLDR_DATA_TABLE_ENTRY&nbsp;module&nbsp;=&nbsp;CONTAINING_RECORD(dll_entry,&nbsp;LDR_DATA_TABLE_ENTRY,&nbsp;InMemoryOrderLinks);<br /><br />		printf(&quot;\t&nbsp;%ws&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;module-&gt;FullDllName.Buffer,&nbsp;module-&gt;DllBase);<br /><br />		//&nbsp;compare&nbsp;grabbed&nbsp;DLL&nbsp;to&nbsp;requested&nbsp;DLL&nbsp;name.&nbsp;if&nbsp;DLL&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />		if&nbsp;(wcscmp(dll_name,&nbsp;module-&gt;FullDllName.Buffer)&nbsp;==&nbsp;0)<br />		{<br />			dll_base&nbsp;=&nbsp;module-&gt;DllBase;<br />			break;<br />		}<br /><br />		//&nbsp;increment&nbsp;to&nbsp;next&nbsp;DLL<br />		dll_entry&nbsp;=&nbsp;dll_entry-&gt;Flink;<br />	}<br /><br />	return&nbsp;dll_base;<br />}<br /><br />/*<br />Find&nbsp;the&nbsp;address&nbsp;of&nbsp;an&nbsp;exported&nbsp;function&nbsp;from&nbsp;a&nbsp;DLL.<br />Only&nbsp;tested&nbsp;with&nbsp;a&nbsp;DLL&nbsp;already&nbsp;loaded&nbsp;in&nbsp;memory.<br />*/<br />LPVOID&nbsp;FindExportedDLLFunctionAddress(LPVOID&nbsp;dll_base_address,&nbsp;const&nbsp;char*&nbsp;requested_function)<br />{<br />	LPVOID&nbsp;function_address&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_directory&nbsp;=&nbsp;NULL;<br /><br />	DWORD*&nbsp;export_dir_names&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;export_dir_ordinals&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_dir_functions&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;export&nbsp;directory&nbsp;from&nbsp;DLL<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_base_address;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	export_directory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br /><br />	printf(&quot;\t&nbsp;exports&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;export_directory);<br /><br />	export_dir_names&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNames);<br />	export_dir_ordinals&nbsp;=&nbsp;(WORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNameOrdinals);<br />	export_dir_functions&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfFunctions);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;exports<br />	//&nbsp;if&nbsp;requested&nbsp;function&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;export_directory-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		//&nbsp;grab&nbsp;function&nbsp;name<br />		char*&nbsp;function_name&nbsp;=&nbsp;(char*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_names[i]);<br />		printf(&quot;\t\t&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br />		<br />		//&nbsp;compare&nbsp;function&nbsp;name&nbsp;to&nbsp;requested&nbsp;function.&nbsp;if&nbsp;correct,&nbsp;save&nbsp;address&nbsp;and&nbsp;exit<br />		if&nbsp;(strcmp(function_name,&nbsp;requested_function)&nbsp;==&nbsp;0)<br />		{<br />			function_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_functions[export_dir_ordinals[i]]);<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;function_address;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	LPVOID&nbsp;kernel32_base_address&nbsp;=&nbsp;NULL;<br />	<br />	kernel32_base_address&nbsp;=&nbsp;FindLoadedDLLBaseAddress(L&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;);<br />	t_Beep&nbsp;d_Beep&nbsp;=&nbsp;(t_Beep)FindExportedDLLFunctionAddress(kernel32_base_address,&nbsp;&quot;Beep&quot;);<br />	if&nbsp;(d_Beep&nbsp;==&nbsp;NULL)<br />	{<br />		printf(&quot;failed&nbsp;to&nbsp;resolve&nbsp;Beep&nbsp;\n&quot;);<br />		return&nbsp;1;<br />	}<br /><br />	d_Beep(1000,&nbsp;1000);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><strong><h2>## Find Kernel32 base -&gt; Grab LoadLibrary -&gt; Grab GetProcAddress -&gt; Use dynamic LoadLibrary and dynamic GetProcAddress to load every other function you want</h2></strong><br />If we find the address of where <code>Kernel32.dll</code> is loaded in our program - its base address - we can walk the DLL&#39;s exported functions to find the address of <code>LoadLibraryA</code> and <code>GetProcAddress</code><br /><br />We can then use our dynamically imported <code>LoadLibrary</code> and <code>GetProcAddress</code> functions to grab every other function we want.<br /><br />The code below is the same as above except that we grab <code>LoadLibraryA</code> and <code>GetProcAddress</code> from <code>kernel32.dll</code> instead of <code>Beep</code><br /><div class="codebox"><div class="codebox">#include&nbsp;&lt;stdio.h&gt;<br />#include&nbsp;&lt;Windows.h&gt;<br />#include&nbsp;&lt;winternl.h&gt;<br /><br />//&nbsp;function&nbsp;typedefs<br />typedef&nbsp;FARPROC(__stdcall*&nbsp;t_GetProcAddress)(HMODULE&nbsp;hModule,&nbsp;LPCSTR&nbsp;lpProcName);<br />typedef&nbsp;HMODULE(__stdcall*&nbsp;t_LoadLibraryA)(LPCSTR&nbsp;lpLibFileName);<br />typedef&nbsp;int(__stdcall*&nbsp;t_MessageBoxA)(HWND&nbsp;hWnd,&nbsp;LPCSTR&nbsp;lpText,&nbsp;LPCSTR&nbsp;lpCaption,&nbsp;UINT&nbsp;uType);<br /><br />/*<br />Grabs&nbsp;PEB,<br />grabs&nbsp;PED_LDR_DATA&nbsp;from&nbsp;PEB&nbsp;to&nbsp;get&nbsp;info&nbsp;about&nbsp;loaded&nbsp;DLLs,<br />and&nbsp;loops&nbsp;through&nbsp;the&nbsp;loaded&nbsp;DLLs&nbsp;to&nbsp;find&nbsp;the&nbsp;DLL&nbsp;we&nbsp;want&nbsp;and&nbsp;grabs&nbsp;its&nbsp;base&nbsp;address.<br /><br />Be&nbsp;careful.&nbsp;The&nbsp;DLL&nbsp;name&nbsp;has&nbsp;to&nbsp;be&nbsp;exact&nbsp;(could&nbsp;use&nbsp;something&nbsp;else&nbsp;than&nbsp;strcmp&nbsp;tbf)<br />e.g:&nbsp;&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;&nbsp;vs&nbsp;&quot;C:\\WINDOWS\\System32\\KERNEL32.DLL&quot;<br /><br />Return:<br />NULL&nbsp;on&nbsp;error.<br />*/<br />LPVOID&nbsp;FindLoadedDLLBaseAddress(const&nbsp;wchar_t*&nbsp;dll_name)<br />{<br />	PPEB&nbsp;p_peb&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_list&nbsp;=&nbsp;NULL;<br />	PLIST_ENTRY&nbsp;dll_entry&nbsp;=&nbsp;NULL;<br />	LPVOID&nbsp;dll_base&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;PEB<br />#ifdef&nbsp;_WIN64<br />	p_peb&nbsp;=&nbsp;(PPEB)__readgsqword(0x60);<br />#else<br />	p_peb&nbsp;=&nbsp;(PPEB)__readfsdword(0x30);<br />#endif<br /><br />	//&nbsp;grab&nbsp;list&nbsp;of&nbsp;loaded&nbsp;DLLs<br />	dll_list&nbsp;=&nbsp;(PLIST_ENTRY)&amp;p_peb-&gt;Ldr-&gt;InMemoryOrderModuleList;<br />	//&nbsp;grab&nbsp;first&nbsp;DLL&nbsp;in&nbsp;list&nbsp;of&nbsp;DLLs<br />	dll_entry&nbsp;=&nbsp;dll_list-&gt;Flink;<br /><br />	printf(&quot;peb&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;p_peb);<br />	printf(&quot;dll&nbsp;list&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_list);<br />	printf(&quot;dll&nbsp;entry&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;dll_entry);<br /><br />	printf(&quot;[*]&nbsp;looping&nbsp;through&nbsp;loaded&nbsp;DLLs...&nbsp;\n&quot;);<br />	//&nbsp;loop&nbsp;through&nbsp;loaded&nbsp;DLLs<br />	while&nbsp;(dll_list&nbsp;!=&nbsp;dll_entry)<br />	{<br />		//&nbsp;grab&nbsp;DLL<br />		PLDR_DATA_TABLE_ENTRY&nbsp;module&nbsp;=&nbsp;CONTAINING_RECORD(dll_entry,&nbsp;LDR_DATA_TABLE_ENTRY,&nbsp;InMemoryOrderLinks);<br /><br />		printf(&quot;\t&nbsp;%ws&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;module-&gt;FullDllName.Buffer,&nbsp;module-&gt;DllBase);<br /><br />		//&nbsp;if&nbsp;DLL&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />		if&nbsp;(wcscmp(dll_name,&nbsp;module-&gt;FullDllName.Buffer)&nbsp;==&nbsp;0)<br />		{<br />			dll_base&nbsp;=&nbsp;module-&gt;DllBase;<br />			break;<br />		}<br /><br />		//&nbsp;increment&nbsp;to&nbsp;next&nbsp;DLL<br />		dll_entry&nbsp;=&nbsp;dll_entry-&gt;Flink;<br />	}<br /><br />	return&nbsp;dll_base;<br />}<br /><br />/*<br />Find&nbsp;the&nbsp;address&nbsp;of&nbsp;an&nbsp;exported&nbsp;function&nbsp;from&nbsp;a&nbsp;DLL.<br />Only&nbsp;tested&nbsp;with&nbsp;a&nbsp;DLL&nbsp;already&nbsp;loaded&nbsp;in&nbsp;memory.<br />*/<br />LPVOID&nbsp;FindExportedDLLFunctionAddress(LPVOID&nbsp;dll_base_address,&nbsp;const&nbsp;char*&nbsp;requested_function)<br />{<br />	LPVOID&nbsp;function_address&nbsp;=&nbsp;NULL;<br /><br />	PIMAGE_DOS_HEADER&nbsp;dos_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_NT_HEADERS&nbsp;pe_header&nbsp;=&nbsp;NULL;<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;export_directory&nbsp;=&nbsp;NULL;<br /><br />	DWORD*&nbsp;export_dir_names&nbsp;=&nbsp;NULL;<br />	WORD*&nbsp;export_dir_ordinals&nbsp;=&nbsp;NULL;<br />	DWORD*&nbsp;export_dir_functions&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;export&nbsp;directory&nbsp;from&nbsp;DLL<br />	dos_header&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)dll_base_address;<br />	pe_header&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;dos_header-&gt;e_lfanew);<br />	export_directory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;pe_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br /><br />	printf(&quot;\t&nbsp;exports&nbsp;@&nbsp;0x%p&nbsp;\n&quot;,&nbsp;export_directory);<br /><br />	export_dir_names&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNames);<br />	export_dir_ordinals&nbsp;=&nbsp;(WORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfNameOrdinals);<br />	export_dir_functions&nbsp;=&nbsp;(DWORD*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_directory-&gt;AddressOfFunctions);<br /><br />	//&nbsp;loop&nbsp;through&nbsp;exports<br />	//&nbsp;if&nbsp;requested&nbsp;function&nbsp;found,&nbsp;save&nbsp;address&nbsp;&amp;&nbsp;exit<br />	for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;export_directory-&gt;NumberOfNames;&nbsp;i++)<br />	{<br />		//&nbsp;grab&nbsp;function&nbsp;name<br />		char*&nbsp;function_name&nbsp;=&nbsp;(char*)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_names[i]);<br />		printf(&quot;\t\t&nbsp;%s&nbsp;\n&quot;,&nbsp;function_name);<br /><br />		//&nbsp;compare&nbsp;function&nbsp;name&nbsp;to&nbsp;requested&nbsp;function.&nbsp;if&nbsp;correct,&nbsp;save&nbsp;address&nbsp;and&nbsp;exit<br />		if&nbsp;(strcmp(function_name,&nbsp;requested_function)&nbsp;==&nbsp;0)<br />		{<br />			function_address&nbsp;=&nbsp;(LPVOID)((DWORD_PTR)dll_base_address&nbsp;+&nbsp;export_dir_functions[export_dir_ordinals[i]]);<br />			break;<br />		}<br />	}<br /><br />	return&nbsp;function_address;<br />}<br /><br />int&nbsp;main(void)<br /><span style="color:#000000;font-weight:400">{</span><br />	LPVOID&nbsp;kernel32_base_address&nbsp;=&nbsp;NULL;<br />	t_LoadLibraryA&nbsp;d_LoadLibraryA&nbsp;=&nbsp;NULL;<br />	t_GetProcAddress&nbsp;d_GetProcAddress&nbsp;=&nbsp;NULL;<br />	t_MessageBoxA&nbsp;d_MessageBoxA&nbsp;=&nbsp;NULL;<br /><br />	//&nbsp;grab&nbsp;kernel32.dll&nbsp;base&nbsp;address<br />	kernel32_base_address&nbsp;=&nbsp;FindLoadedDLLBaseAddress(L&quot;C:\\Windows\\System32\\KERNEL32.DLL&quot;);<br /><br />	//&nbsp;grab&nbsp;address&nbsp;of&nbsp;LoadLibraryA&nbsp;and&nbsp;GetProcAddress&nbsp;from&nbsp;kernel32.dll<br />	d_LoadLibraryA&nbsp;=&nbsp;(t_LoadLibraryA)FindExportedDLLFunctionAddress(kernel32_base_address,&nbsp;&quot;LoadLibraryA&quot;);<br />	d_GetProcAddress&nbsp;=&nbsp;(t_GetProcAddress)FindExportedDLLFunctionAddress(kernel32_base_address,&nbsp;&quot;GetProcAddress&quot;);<br />	if&nbsp;(d_LoadLibraryA&nbsp;==&nbsp;NULL&nbsp;||&nbsp;d_GetProcAddress&nbsp;==&nbsp;NULL)<br />		return&nbsp;1;<br /><br />	//&nbsp;use&nbsp;dynamic&nbsp;LoadLibraryA&nbsp;and&nbsp;GetProcAddress&nbsp;to&nbsp;dynamically&nbsp;import&nbsp;MessageBoxA<br />	d_MessageBoxA&nbsp;=&nbsp;(t_MessageBoxA)GetProcAddress(d_LoadLibraryA(&quot;User32.dll&quot;),&nbsp;&quot;MessageBoxA&quot;);<br /><br />	//&nbsp;use&nbsp;dynamically&nbsp;imported&nbsp;MessageBoxA<br />	d_MessageBoxA(NULL,&nbsp;&quot;hey&nbsp;:)&quot;,&nbsp;&quot;dynamic&nbsp;imports&quot;,&nbsp;MB_OK);<br /><br />	return&nbsp;0;<br /><span style="color:#000000;font-weight:400">}</span></div></div><br /><br /><br /><br /><br /></div>
</body>
</html>
